#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass book
\begin_preamble
\usepackage{qtree}
\newsavebox{\partbox} % Declare this only once, in your preamble!
\newsavebox{\partboxx} % Declare this only once, in your preamble!
\usepackage{pdflscape}
\usepackage{colortbl}
\AtBeginDocument{%
\let\ref\autoref
}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\begin_local_layout
InsetLayout Flex:Code
    LyxType               charstyle
    LabelString           code
    LatexType             command
    LatexName             code
    Font
      Family              Typewriter
    EndFont
    Preamble
    \newcommand{\code}[1]{\texttt{#1}}
    EndPreamble
    InToc                 true
    HTMLTag               code
End
\end_local_layout
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command bibtex
\index_command default
\paperfontsize 11
\spacing other 1.2
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type numerical
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\notefontcolor #ff0027
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.5cm
\topmargin 2.5cm
\rightmargin 2.5cm
\bottommargin 2.5cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Date
Imperial College London
\begin_inset Newline newline
\end_inset

Department of Computing
\end_layout

\begin_layout Title

\series bold
\size huge
Solving Cryptic Crosswords through Functional Programming
\end_layout

\begin_layout Author
by
\end_layout

\begin_layout Author
Michael Skelly
\end_layout

\begin_layout Date
April 25
\begin_inset script superscript

\begin_layout Plain Layout
th
\end_layout

\end_inset

 2014
\end_layout

\begin_layout Date
Submitted in partial fulfilment of the requirements for the MSc Degree in
 Advanced Computing of Imperial College London 
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Paragraph*
This is the abstract
\end_layout

\begin_layout Standard
DK
\end_layout

\begin_layout Standard
\align center
\begin_inset Newpage pagebreak
\end_inset


\series bold
Acknowledgements
\series default

\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
For Bob Hargrave, who taught me how to solve crosswords, and for Richard
 Bird, who taught me how to teach computers to solve them.
\end_layout

\begin_layout Standard
\align center
\begin_inset Newpage pagebreak
\end_inset


\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Chapter
Introduction to the Problem / Field
\end_layout

\begin_layout Quotation

\shape italic
\begin_inset Quotes eld
\end_inset

A provost at Eton once boasted that he could do The Times crossword in the
 time it took his morning egg to boil, prompting one wag to suggest that
 the school may have been Eton but the egg almost certainly wasn't.
\begin_inset Quotes erd
\end_inset

 
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Quotation
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

 
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

 
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

 
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

 
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

 
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

 
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

 
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

 
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

 
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

 
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

 
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

–
\begin_inset space ~
\end_inset

Bill Bryson, 
\shape italic
Mother Tongue
\end_layout

\begin_layout Subsection
Motivation and Objectives
\end_layout

\begin_layout Standard
Cryptic crosswords are widely thought to be at the junction of various fields
 of human endevour considered to be right at the limit of current Artificial
 Intelligence (AI) and Machine Learning – featuring wit, slang, allusion,
 linguistic ambiguity and misdirection.
 Clues cryptic clues appear to be in the form of a sentance fragment in
 natural English: 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Sweetheart takes Non-Commissioned Officer to dance (8)
\end_layout

\end_inset

.
 Actually, however, they communicate a set of instructions to derive the
 correct answer.
 In this case, a word for sweetheart (`flame') is next to an abbreviation
 of Non-Commisioned Officer (`nco') to form a word for a dance (`flamenco').
 
\end_layout

\begin_layout Standard
More and more, the artificial intelligence community is making inroads into
 problems like cryptic crosswords though to be only within the abilities
 of humans.
 In 2011 a computer system from IBM called Watson competed in the TV Gameshow
 Jeopardy: a game in which players have to give the answers to cryptically
 worded questions in as short a time as possible.
 Watson, armed with 200-million pages worth of data and 16 terrabytes of
 RAM, beat two former Jeopardy champions.
 
\end_layout

\begin_layout Standard
As well as all the human features like specialist knowledge and linguistic
 ambiguity, cryptic crosswords also possess other characteristics that make
 brute force solutions difficult, if not impossible: the state space of
 all possible crossword grids is of the order 10
\begin_inset script superscript

\begin_layout Plain Layout
90
\end_layout

\end_inset

(compare, for example, an upper bound on all the possible chess positions
 is merely 10
\begin_inset script superscript

\begin_layout Plain Layout
50
\end_layout

\end_inset

), and worse still, a solution to a grid is non-trivial to verify (as the
 verification process is the nearly same as solving the clue!).
 Nevertheless, techniques from combinatorics, compiler design and Natural
 Language Processing (
\noun on
NLP)
\noun default
 and Artificial Intelligence (
\noun on
ai
\noun default
) all have applications that can help elucidate and simplify the problem,
 along with heuristics adapted from both human solvers and analytical optimisati
ons that can help improve the time taken to arrive at at the correct solution.
\end_layout

\begin_layout Standard
This project seeks to create a system which can solve clues from cryptic
 crossword puzzles by correctly parsing and solving as a human does, through
 understanding of the internal structure of the clue, rather than by brute
 force and statistical methods across a whole grid.
 
\end_layout

\begin_layout Subsection
Contributions
\end_layout

\begin_layout Subsubsection
Produced a framework capable of correctly parsing most cryptic clues
\end_layout

\begin_layout Standard
In 
\series bold
Part III
\series default
, I derive a framework in the functional programing language Haskell capable
 of parsing an unseen crossword clue into the multiple possible parse trees.
 Based on definitions of different clue-type expressions, such as anagrams
 and hidden words, I specify conditions for a parse to include that clue
 type.
 I then show how these multiple parses can be further evaluated to eventually
 yield the correct answer, along with a structural representation of how
 the answer was derived.
 
\end_layout

\begin_layout Subsubsection
Optimised to make the problem computationally tractable
\end_layout

\begin_layout Standard
In 
\series bold
Part IV
\series default
, I show how the correct but essentially computationally intractable solution
 from 
\series bold
Part III 
\series default
can be optimised.
 I use both systematic transformations as well as heuristics borrowed from
 the techniques of human solvers to reduce the computation required.
 I analyse the results, and show that I have reduced the state space and
 evaluation time to within practical bounds.
 
\end_layout

\begin_layout Subsubsection
Analysed the performance of the solver against a suite of real clues given
 a limited knowledgebase
\end_layout

\begin_layout Standard
In 
\series bold
Part V, 
\series default
I apply my solution to a collection of unseen clues collected from the archives
 of a British newspaper.
 I present an overview of the clues that can be solved, as well as analysis
 of those currently unsolveable.
 I also discuss how, using only a very basic knowledgebase, I can solve
 28% of the sampled clues, and show that a further 42% could be solved using
 further data without modification to the system.
 In 
\series bold
Part VI 
\series default
I propose how this figure could be improved with techniques from the field
 of Knowledge Representation, and how the current approach could be applied
 to the wider problem of whole-grid solving.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Chapter
Literature Review
\end_layout

\begin_layout Section
Summary of Cryptic Crosswords 
\end_layout

\begin_layout Subsection
Definition of Cryptic Crosswords 
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
Insert a crossword grid here to illustrate
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A crossword is a puzzle, usually published in newspapers or magazines.
 They consist of a grid of squares, often 15 x 15.
 Some of the squares are white (i.e.
 blank) and some are blacked out.
 Any contiguous run of more than one white square, either down (vertically)
 or across (horizontally, left to right) is a space for a word, to be written.
 These are marked by numbers in the initial square (the top-leftmost one),
 and referred to by those numbers, and the direction (e.g.
 `5 down', `8 across').
 Horizontal runs can overlap vertical runs, and at the points at which they
 meet, each of the two words, when completed, must have the same letter
 in that square, as well as being a valid answer for each clue.
 
\end_layout

\begin_layout Standard
Along with the grid are a set of clues, which the solver can use to determine
 which word to write in each space (the `answer' or `solution').
 The aim of the puzzle is to find the set of solution words such that each
 clue's solution is correct for that clue, and fits in the grid correctly,
 with respect to the overlapping words.
\end_layout

\begin_layout Standard
Grids can be very densely white, with few black squares and most squares
 shared by two words (usually called 
\noun on
American Style
\noun default
) or more sparse, with fewer overlapped clues (called 
\emph on
\noun on
British Style
\emph default
\noun default
).
 Clues can also be in two styles.
 
\noun on
Straight
\noun default
 or 
\noun on
Quick
\noun default
 crossword clues usually provide a single straightforward indicator as to
 what the correct word might be - often a synonym for the clue (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Joyful
\end_layout

\end_inset

 = HAPPY) or a missing word (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Stitch in ____ saves nine
\end_layout

\end_inset

 = TIME).
 
\noun on
Cryptic
\series bold
\noun default
 
\series default
clues are less straightforward, appearing on the surface to be a valid syntactic
 utterance in English, but actually consisting of a definition (as in the
 straight clue) and some wordplay which the solver can use to arrive at
 the same answer as with the definition by applying a series of transformations
 and operations.
 
\end_layout

\begin_layout Standard
One example of a clue could be 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Rule amended to include married primate (5)
\end_layout

\end_inset

.
 In this, the surfact reading (legislation being changed to accomodate coupled
 apes) is not relevant.
 What is actually required is to find a word which matches the definition,
 which `primate', and also fulfils the wordplay, which in this case asks
 us to insert an equivalent for `married' into an anagram of the letters
 in `rule'.
 Here, we insert `m' into `leur' to form the solution `LEMUR'.
 
\end_layout

\begin_layout Standard
The challenge is that the definition and the wordplay are not clearly separated
 (in this case, `rule', or `rule amended' could equally be definitions),
 and that there are multiple ways to apply to the transformations, but with
 only one yielding the correct answer.
 
\end_layout

\begin_layout Standard
It is the task of determining the correct answer for this type of clue that
 this report will address.
\end_layout

\begin_layout Subsection
Cryptic Crosswords in the Literature 
\end_layout

\begin_layout Standard
While not a topic well covered in scientific literature.
 In general, analystical studies on cryptic crosswords tend to be classifiable
 into three main groups:
\end_layout

\begin_layout Paragraph
Generation of Cryptic Clues
\end_layout

\begin_layout Standard
The largest body of work is centered on the generation of cryptic clues,
 focusing largely around analysis of how string literals from a pre-determined
 answer can be transformed by set clueing patterns, as well as some work
 around measures of the quality of generated clues.
\end_layout

\begin_layout Paragraph
Interpreting Clues
\end_layout

\begin_layout Standard
The next set are those similar to the current study, which have done prior,
 similar investigations into interpreting cryptic clues, with some work
 put into formalizing definitions and notation for the sorts of clue types
 that appear in the majority of cryptic crosswords, and some attempts at
 solving based on these interpretations.
 
\end_layout

\begin_layout Paragraph
Other Work
\end_layout

\begin_layout Standard
There has also been some work aimed at solving non-cryptic crosswords probabilis
tically, working on whole-grid solutions rather than individual clues.
 A number of left-of-field studies have also been undertaken, e.g.
 statistical studies into errors made during manual solving, and psychological
 studies into solving.
 
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
More here TF
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Complexity
\end_layout

\begin_layout Standard
A variety of factors make solving cryptic crosswords a difficult problem:
 
\end_layout

\begin_layout Paragraph*
Ambiguity 
\end_layout

\begin_layout Standard
Cryptic crosswords are deliberately ambiguous.
 Instruction indicators are indistinguishable from string literals, which
 are identical to words’ semantic meanings.
 Often, the setter will deliberately choose words to give rise to further
 ambiguities.
 For example, 
\emph on
The Telegraph
\emph default
 printed
\end_layout

\begin_layout LyX-Code
Bug starts to move in dark, glowing endlessly (5)
\end_layout

\begin_layout Standard
clueing for `MIDGE'.
 Usually "endlessly" and similar mean "remove the last letter", but here
 it is one of five consecutive words to form an acronym from, with the words
 "starts to" as an indicator.
\end_layout

\begin_layout Paragraph
State Space 
\end_layout

\begin_layout Standard
Even with only a few different clue types, the number of different readings
 of one clue based on those grows exponentially with the length of the clue.
 This means that unless heuristics are applied, the evaluation time for
 a whole grid longer clues may be unfeasibly long.
 
\end_layout

\begin_layout Paragraph
Lack of Standardization 
\end_layout

\begin_layout Standard
Although all cryptic crosswords share some common conventions, there are
 no fixed rules shared between publications for what can and can’t be a
 clue, indicator etc.
 Although most publications have internal guidelines or style-guides, these
 are not accessible to the solver, and some publications (such as the 
\emph on
Guardian
\emph default
) have named setters whose styles and self-imposed rule sets differ, even
 between one publication.
 Alistair Ferguson Ricthie, who set for 
\emph on
Listener
\emph default
 for many years, referenced the concept of fairness in his book 
\emph on
Armchair Crosswords 
\emph default
in 1946.
 He defers the judgement of fairness to a notional rulebook:
\end_layout

\begin_layout Quote
\begin_inset Quotes eld
\end_inset

We must expect the composer to play tricks, but we shall insist that he
 play fair.
 
\emph on
The Book of the Crossword
\emph default
 lays this injunction upon him: "You need not mean what you say, but you
 must say what you mean." This is a superior way of saying that he can't
 have it both ways.
 He may attempt to mislead by employing a form of words which can be taken
 in more than one way, and it is your fault if you take it the wrong way,
 but it is his fault if you can't logically take it the right way.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Although there have been many books written on the subject of what should
 and should not constitute a valid cryptic crossword clue.
 One of the most notable and influential was written by 
\emph on
Observer
\emph default
 setter Derrick Somerset Macnutt, who clued under the pseudonym Ximenes,
 in his book 
\emph on
Ximenes on the Art of the Crossword Puzzle
\emph default
.
 The book contains many in-depth guidelines about what a fair clue entails,
 summed up by his successor Azed (Jonathan Crowther, born 1942):
\end_layout

\begin_layout Quote
\begin_inset Quotes eld
\end_inset

A good cryptic clue contains three elements: 
\end_layout

\begin_deeper
\begin_layout Quote
1.
 a precise definition
\end_layout

\begin_layout Quote
2.
 a fair subsidiary indication 
\end_layout

\begin_layout Quote
3.
 nothing else
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
A crossword setter following these rules is said to adhere to `Ximenean
 principles' and their produced work to be Ximenean.
 Most mainstream crosswords exist on a continuum between being more closely
 Ximenean (examples include 
\emph on
The Times
\emph default
, 
\emph on
The Independent
\emph default
) to being very libertarian (e.g.
 
\emph on
The Guardian
\emph default
).
 No crossword in a major UK newspaper is `strictly Ximenean'.
 
\end_layout

\begin_layout Paragraph*
Knowledge Base
\end_layout

\begin_layout Standard
As well as being made up of encrypted and hidden meanings, cryptic crosswords
 also draws on a diverse knowledge base of synonyms, abbreviations, facts
 etc.
 These can include information as diverse as names of capital cities, common
 sayings, and the fact that one may carry a wallet in one's pocket.
 
\end_layout

\begin_layout Standard
In order to run a fully working cryptic crossword solver against any arbitrary
 clue, all of these pieces of information must be encoded, stored and accessible
 to the solver in a machine readable form.
 Understandably, this is subject to an entire field of study itself.
 
\end_layout

\begin_layout Subsection
Programming Language Analogues
\end_layout

\begin_layout Standard
Much of the current work on interpreting crosswords draws on studies by
 Backus, Naur and Chomsky in creating a specification for the grammar of
 crosswords.
 While these frameworks are useful for describing many different languages,
 interpretations of the grammar of cryptic crosswords seem to be perversely
 somewhat closer to mathematical and programming languages than to natural
 language.
 In some ways, the cryptic clue as a whole can be thought of as a program
 that generates the output string as its answer.
 The wordplay section is analogous to a program, and the definition section
 of a clue can be thought of as a checksum to verify the final answer.
\end_layout

\begin_layout Subsubsection
Lexing, Parsing, Evaluating 
\end_layout

\begin_layout Standard
The steps for compiling and running a computer program apply also to solving
 (or `running') a crossword as a program.
 Each word in the input string needs to be tokenized, parsed into a relevant
 structure.
 That structure is then evaluated to produce the final answer.
 Unusually for a programming language, however, the grammar of a cryptic
 crossword is highly ambiguous, and requires complex parsing.
 Firstly, programming languages are only usually required to output the
 one valid abstract syntax tree, however here we may need to output many
 thousands in order to evaluate them to see which yields the correct answer.
 Secondly, the grammar cannot be expressed without using complex context-sensiti
ve features such as lookbacks, lookaheads and backtracking.
 Most major programming languages are parsed without these features, allowing
 information to flow in one direction from the lexer to the parser.
 To parse a cryptic crossword, lexing and parsing need to take place simultaneou
sly in a process referred to as 
\begin_inset Quotes eld
\end_inset

Scannerless Parsing
\begin_inset Quotes erd
\end_inset

.
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
citation TF
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
There's No Accounting for Wit
\end_layout

\begin_layout Standard
Along with clearly defined and program-like cryptic crossword clues, there
 exist other clues that rely on humour, imagery and wit, rather than following
 the regimented classical structure, as set out by Ximenes.
 Some examples include:
\end_layout

\begin_layout LyX-Code
Flower of London? (6)    
\end_layout

\begin_layout LyX-Code
    (= THAMES, flower = that which flows)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
In which you can get three couples together and have sex (5) 
\end_layout

\begin_layout LyX-Code
    (= LATIN, 'sex' is 6 in Latin)
\end_layout

\begin_layout Standard
Clues such as these, and the question of computerised wit and humour, exist
 outside the scope of this project.
\end_layout

\begin_layout Section
Parsing Frameworks and Notation
\end_layout

\begin_layout Standard
Some different notations for denoting parsing of cryptic clues have come
 out of previous work – in order to provide a rigorous analysis of the structure
s and conventions of cryptic crosswords, it is necessary to analyze and
 choose a framework in which to do it.
 
\end_layout

\begin_layout Subsection
LACROSS
\end_layout

\begin_layout Standard
William and Woodhead produced language called LACROSS, which forms a sort
 of calculus for describing crossword clues.
 They also provide a Backus–Naur Form (BNF) definition of this grammar.
 Their clues are of the general form 
\end_layout

\begin_layout LyX-Code
Clue := Δ = G | G = Δ 
\end_layout

\begin_layout Standard
the orientation of which corresponds to the order in which we find the definitio
n (Δ) and the wordplay (G) in the clue.
 The wordplay may be further expanded out – the wordplay section of the
 clue is expressed as a sequential annotation for the constituent parts,
 either as ‘text’ (t), ‘shortening’ (S) (etc.) or as placeholders for the
 operators (*), which are detailed afterwards, including a reference to
 the substituted indicator.
 So for instance: 
\end_layout

\begin_layout LyX-Code
Get in odd bit of colour (5) [= tinge] 
\end_layout

\begin_layout LyX-Code
t* = Δ, a (odd, a) 
\end_layout

\begin_layout Standard
There are several issues with this grammar.
 Firstly, all unitary operators are treated the same, as are all binary
 operators, and there is some issue with binding and precedence which they
 address with an underlining notation, in addition to brackets.
 Secondly, the grammar attempts to include both the structure of the parsed
 cluing and how that structure relates to the original sequence of words
 at the same time.
 As a result, we end up with complex grammar that does not aid human parsing
 of the solution well, nor does it lend itself easily to computer or mathematica
l manipulation
\end_layout

\begin_layout Standard
Regardless, the paper provides a basis for future work, and begins a basic
 enumeration of clue types.
 
\end_layout

\begin_layout Subsection
Simple Clue Markup Language 
\end_layout

\begin_layout Standard
Proposed by Hall and Rapanotti, Simple Clue Markup Language (SCML) attempts
 to notate the structure of the solution directly onto the clue.
 
\end_layout

\begin_layout Standard
Double underlining is used to denote the definition, underlining denotes
 an operator, with its class as an optional subscript, with scope provided
 by brackets and concatenation (and definition/wordplay separation) given
 by a semi-colon.
 The following example is taken from their paper:
\end_layout

\begin_layout LyX-Code
Note the shuddering appliance Bill regularly installed, noisy thing (6,7)
 
\end_layout

\begin_layout LyX-Code

\bar under
Note
\bar default
;(the)
\bar under
shuddering
\bar default

\begin_inset script subscript

\begin_layout Plain Layout
a
\end_layout

\end_inset

;(appliance,(Bill)
\bar under
regularly
\bar default

\begin_inset script subscript

\begin_layout Plain Layout
t
\end_layout

\end_inset

)
\bar under
installed
\bar default

\begin_inset script subscript

\begin_layout Plain Layout
e
\end_layout

\end_inset

;
\uuline on
noisy thing
\uuline default
 
\end_layout

\begin_layout Quote
Note’ often indicates a musical note, resolving to one of ‘a’ to ‘g’, ‘do’,
 ‘re’, ‘mi’, etc; 
\end_layout

\begin_layout Quote
‘the shuddering’ may be an anagram indicator applied to ‘the’; 
\end_layout

\begin_layout Quote
the ‘regularly’ of ‘Bill regularly’ may indicate alternate letters (‘t’);
 i.e., ‘bl’ or ‘il’; and 
\end_layout

\begin_layout Quote
‘installed’ suggests the embedding (‘e’) of those letters within something
 meaning ‘appliance’.
\end_layout

\begin_layout Standard
In this, we have no markup differentiation for literal strings (‘Bill’)
 against words with their semantic context (‘appliance’), and we also take
 certain words that reduce to abbreviations (‘Note’) to be non-deterministic
 nullary operators.
 With some changes and additions (tagging of string vs.
 semantic word, for example), this markup serves as a good way to represent
 a parsing of a clue in a human readable way.
 It even has the advantage that a printed clue could be annotated (carefully)
 by hand, as a teaching aid, for example.
 Unfortunately, the language as it stands is not expressible as a BNF grammar,
 nor is it a particularly good format for representing the clue and its
 parsings internally in a program (as it would need to be re-parsed to use!)
 
\end_layout

\begin_layout Subsection
Clue-answer notation 
\end_layout

\begin_layout Standard
There are several emergent solutions within online cryptic crossword communities
 for notation to explain solutions derived from clues.
 From http://cryptics.wikia.com: 
\end_layout

\begin_layout Quote
Consider the down clue A message from the setter, hauled up with broken
 arm after heroin withdrawal (8) yielding the answer TELEGRAM.
 The corresponding wordplay, having the prolix and possibly ambiguous explanatio
n THE next to LEG reversed next to an anagram of ARM, all with H (heroin)
 removed could be concisely represented in clue-answer notation simply as
 T[h]E,GEL<=,(ARM)*.
 
\end_layout

\begin_layout Standard
These meanings are not fixed, but some definitions are given here: 
\end_layout

\begin_layout Paragraph
ABC<= or ABC (rev.) ABC reversed.	
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
The (rev.) notation is most commonly used when the wordplay consists of a
 single reversal.					
\end_layout

\begin_layout Paragraph
[abc] or -abc or (abc) 
\end_layout

\begin_layout Standard
Letters abc removed, as in [c]OUNT to represent `count' with c removed;
 the convention is to use lower case for the removed letters.
 
\end_layout

\begin_layout Paragraph
(ABC) 
\end_layout

\begin_layout Standard
Letters placed inside others, as inC(AND)ID to mean `and' inside `cid'.
 
\end_layout

\begin_layout Paragraph
"ABC" 
\end_layout

\begin_layout Standard
Homophone of ABC.
 
\end_layout

\begin_layout Paragraph
(ABC)* 
\end_layout

\begin_layout Standard
Anagram of ABC.
\end_layout

\begin_layout Paragraph
A+B or A,B 
\end_layout

\begin_layout Standard
A concatenated with B.
 Sometimes both notations are used together where ambiguities may arise.
 
\end_layout

\begin_layout Paragraph
aBcDeF 
\end_layout

\begin_layout Standard
Alternate letters of ABCDEF (shorthand for[a]B[c]D[e]F).
 
\end_layout

\begin_layout Subsection
PICCUP
\end_layout

\begin_layout Standard
Hart and Davies define what is currently the most satisfying proposal for
 a formal syntactical definition of cryptic crossword syntax, in a BNF-like
 grammar.
 Theirs is the only current definition that closely resembles a usable formally
 defined language.
\end_layout

\begin_layout Standard
Their interpretation only specifies the grammar in terms of building an
 abstract syntax tree, rather than attempting to include a notation for
 clue or answer.
 The syntax is as given in their paper.
\end_layout

\begin_layout LyX-Code
Anagram → Synonym(.Equ Indicator).AnagramSentence
\end_layout

\begin_layout LyX-Code
/AnagramSentence(.Equ Indicator).Synonym 
\end_layout

\begin_layout LyX-Code
AnagramSentence → AnagramPointer.AnagramMaterial
\end_layout

\begin_layout LyX-Code
/ Anagram Material.Anagram Pointer AnagramPointer~ Word(.Word)* 
\end_layout

\begin_layout LyX-Code
AnagramMaterial → Word(.Word)* 
\end_layout

\begin_layout LyX-Code
Synonym → Word(.Word)* 
\end_layout

\begin_layout LyX-Code
Equ Indicator → Word (.Word)*
\end_layout

\begin_layout Subsection
Context Free?
\end_layout

\begin_layout Standard
The grammar we will describe in chapter 3 is not a Regular Grammar (for
 example: any of the binary operators generate two non-terminals), but it
 can be formulated as a context-free grammar.
 
\end_layout

\begin_layout Standard
We define a 
\noun on
context-free grammar
\noun default
 (CFG) as one in which the expansion of a non-terminal is not affected by
 the symbols before and after it.
 While we can certainly define a working grammar for cryptic crossword clues
 in terms of a CFG, it may be useful to consider other options as a means
 of reducing the number of trees generated during the parsing phase to speed
 up the evaluation phase.
 We could take, for example, the clue length as a contextual variable.
 In the clue
\end_layout

\begin_layout LyX-Code
Story about bishop and food (5)
\end_layout

\begin_layout Standard
then if we read this clue as requiring a word for `story' around a word
 for `bishop', selecting `tale' as the first word means that we are limited
 to only one-letter long options for `bishop'.
 In this case, we would choose `b' as an abbreviation for bishop, to correctly
 form `table'.
 
\end_layout

\begin_layout Subsection
Syntax vs Semantics
\end_layout

\begin_layout Standard
Due to the ambiguous and duplicitous nature of the structure of cryptic
 crosswords, especially the deliberate challenges in the lexing phase, the
 boundaries between parsing the syntax and evaluating the semantics become
 less clear.
 
\end_layout

\begin_layout Standard
Strings consisting of one or more words can be at once tokens representing
 different operators, they can be strings, and can be split in multiple
 ways into combinations.
 This is especially true when we have token that, in the original text,
 represent their semantic meaning in English, and evaluate out to a finite
 number of equivalent words.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "90col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Strings as operators:
\end_layout

\begin_layout Quote
\begin_inset Flex Code
status open

\begin_layout Plain Layout
rough sleep
\end_layout

\end_inset

 →  anagram of 
\begin_inset Quotes eld
\end_inset

sleep
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout
Strings as semantic objects 
\end_layout

\begin_layout Quote
\begin_inset Flex Code
status open

\begin_layout Plain Layout
rough
\end_layout

\end_inset

 →  some synonym of 
\begin_inset Quotes eld
\end_inset

rough
\begin_inset Quotes erd
\end_inset

: scrappy, ungentlemanly, hard
\end_layout

\begin_layout Plain Layout
Strings as strings 
\end_layout

\begin_layout Quote
\begin_inset Flex Code
status open

\begin_layout Plain Layout
in the rough
\end_layout

\end_inset

 →  some letters in the string 
\begin_inset Quotes eld
\end_inset

the rough
\begin_inset Quotes erd
\end_inset

 = hero
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Hall and Rapanotti treated these roughly as their own operators: so the
 string 
\begin_inset Quotes eld
\end_inset

rough
\begin_inset Quotes erd
\end_inset

 would parse to the token 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Rough
\end_layout

\end_inset

, which is latter treated each way during evaluation.
 This may be tempting, as we can specify each word individually instead
 of having multiple treatments of the same word.
 Unfortunately, the number of words which function as indicators is very
 large.
 We also need to differentiate words functioning as indicators (here, 'rough
 as an anagram indidcator') from raw string literals that are subject to
 Hidden Word or Anagram operators, or occasionally concatenated in their
 raw form (as the letters 
\begin_inset Quotes eld
\end_inset

rough
\begin_inset Quotes erd
\end_inset

) .
\end_layout

\begin_layout Standard
The other option is to use data structures to represent these different
 cases independently.
 So in this case, we would have 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Operator 
\begin_inset Quotes eld
\end_inset

rough
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
SemanticObject 
\begin_inset Quotes eld
\end_inset

rough
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
String 
\begin_inset Quotes eld
\end_inset

rough
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

.
 
\end_layout

\begin_layout Section
The Cryptic Crossword Clue 
\end_layout

\begin_layout Subsection
Syntactic and Metasyntactic Notation
\end_layout

\begin_layout Standard
In the definitions here we write not literate Haskell, but in a convention
 similar to the one used by Hart, in using a modified Backus Naur Form (BNF).
 We have seen that a context-free grammar may not be sufficient to model
 a cryptic crossword, and may have further deficiencies as a basis for finding
 a solution.
 Nevertheless, we will adopt a similar notation for clarity: 
\end_layout

\begin_layout LyX-Code
→ = is composed of 
\end_layout

\begin_layout LyX-Code
, = followed by 
\end_layout

\begin_layout LyX-Code
| = or
\end_layout

\begin_layout LyX-Code
(x) = x is optional 
\end_layout

\begin_layout LyX-Code
x* = 1 or more occurrences of x 
\end_layout

\begin_layout LyX-Code
(x)* = 0 or more occurrences of x 
\end_layout

\begin_layout Standard
We also take the BNF conventions 
\end_layout

\begin_layout LyX-Code
Word = non-terminal symbol 
\end_layout

\begin_layout LyX-Code
“word” = string literal 
\end_layout

\begin_layout LyX-Code
[x, y, z] = list containing x y and z 
\end_layout

\begin_layout LyX-Code
(x, y) = pair x and y 
\end_layout

\begin_layout Standard
For clarity, we additionally pre-define the type 
\end_layout

\begin_layout LyX-Code
String 
\end_layout

\begin_layout Standard
to represent any string literal.
\end_layout

\begin_layout Subsection
Structure of a cryptic clue
\end_layout

\begin_layout Standard
A cryptic crossword can be split into wo parts.
 One is the definition, which will perform the same function as a clue in
 a `regular' crossword.
 The answer to the clue is usually a synonym for the definition (`circular'
 and `round') or may be an example of the definition (`farm animal' and
 `pig').
 The other is the wordplay.
 This is an encoded and often ambiguous second method of deriving the answer,
 using techniques such as anagram, substitution and concatenation.
 The clue as a whole is presented as a concatenation of the two parts, sometimes
 with a subsidiary word indicating that one can be derived from the other
 (for example, `from' or `is').
 We can present this breakdown as: 
\end_layout

\begin_layout LyX-Code
Clue → Definition, (Indicator), Wordplay 
\end_layout

\begin_layout LyX-Code
       | Wordplay, (Indicator), Definition 
\end_layout

\begin_layout Standard
The final clue will often resemble a valid English utterance, although this
 `surface reading' very rarely has any relation to the answer.
 Later on we will consider other information and context within the definition
 of a clue.
\end_layout

\begin_layout Subsection
Definition 
\end_layout

\begin_layout Standard
The definition of the clue consists of one or more English words.
 The answer to the clue will be a word or phrase that fits an appropriate
 equivalence function (that we will define later).
\end_layout

\begin_layout Standard
The definition carries a variety of linguistic features with it that the
 overall answer, and so the answer as derived by the wordplay, must match.
 These include aspect (noun, verb, adjective), plurality (tree, trees),
 tense (go, going, gone).
 These features may also be considered as `context' to the clue itself.
 We can define the definition as 
\end_layout

\begin_layout LyX-Code
Definition → Words
\end_layout

\begin_layout Subsection
Wordplay 
\end_layout

\begin_layout Standard
The wordplay section of a clue is a set of deliberately ambiguous instructions
 that allows the solver to arrive at the eventual answer.
 As the instructions are ambiguous, multiple possible parsings of the instructio
ns are possible.
 Some of these parsing will not lead to a valid English word: 
\end_layout

\begin_layout LyX-Code
Imbecile, bonkers, in a cult (7) 
\end_layout

\begin_layout LyX-Code
==> Wordplay ‘Imbecile, bonkers = definition ‘in a cult’
\end_layout

\begin_layout LyX-Code
==> Anagram ‘imbecile’ [indicator = bonkers] = definition ‘in a cult’ 
\end_layout

\begin_layout LyX-Code
==> ??? (no anagrams of imbecile in english language) 
\end_layout

\begin_layout LyX-Code
(correct reading was anagram of in a cult = lunatic)
\end_layout

\begin_layout Standard
Others will lead to a valid English word, but one that is not equivalent
 to the definition: 
\end_layout

\begin_layout LyX-Code
Minder shredded corset (6) 
\end_layout

\begin_layout LyX-Code
==> Wordplay ‘minder shredded’ = definition ‘corset’ 
\end_layout

\begin_layout LyX-Code
==> Anagram ‘minder’ [indicator = shredded] = definition ‘corset’ 
\end_layout

\begin_layout LyX-Code
==> ‘remind’ = definition ‘corset?’ X 
\begin_inset Newline newline
\end_inset

(correct reading was anagram ‘corset’ = escort = minder)
\end_layout

\begin_layout Standard
The solver must find the correct parsing of the wordplay that yields the
 correct definition: even though they may not know which part is wordplay
 and which is definition.
\end_layout

\begin_layout Standard
We can categorize the different types of wordplay into different operators:
\end_layout

\begin_layout LyX-Code
Wordplay → Words | Concatenation | Anagram | Reversion | Contraction 
\end_layout

\begin_layout LyX-Code
          | Selection | Hidden Word | Insertion | Subtraction 
\end_layout

\begin_layout LyX-Code
          | Homophone
\end_layout

\begin_layout Subsection
Special Operators 
\end_layout

\begin_layout Standard
There are two operators which are special in that they are most commonly
 found operators, and that they have no indicators required to show their
 presence.
\end_layout

\begin_layout Paragraph
Word Equivalence
\end_layout

\begin_layout Standard
In the most simple of clues, we have the definition, along with a word or
 phrase that is somehow semantically equivalent to that definition.
 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
In this case, it becomes a difficult task to be precise about exactly which
 of these is the definition and which is the wordplay! Sometimes there is
 a defined answer: From `Oinking tendency? (8)' we get both `pen chant'
 and `penchant', and we can see from the letters required (no space) that
 the second half is the solution.
 In other cases, this may not be defined at all! 
\end_layout

\end_inset

 A clue that contains just this structure is said to be `double definition'
\end_layout

\begin_layout LyX-Code
Metal guide (4) [= LEAD]
\end_layout

\begin_layout Standard
However, even in this simple example we see that this equivalence relationship
 is not at all straightforward.
 While `guide' and `lead' are synonyms (as verbs in the present tense),
 it's not true that `lead' is a synonym for `metal'.
 We must also include `for example' in this relationship too, which causes
 us to have to discard reflexivity.
 Although `metal' can be a clue for `lead', it's not the case that `lead'
 can be a clue for `metal' (in that case, we signify `an example of' by
 writing `lead, say' or `bronze, for instance').
 
\end_layout

\begin_layout Standard
We also include abbreviations, which are perhaps more closely related to
 synonyms, although not usually found in thesauruses, along with some useful
 `setters favourites', where an abbreviation of a synonym or of an example
 is particularly useful for cluing a difficult letter combination used in
 a wordplay (`Books' becomes `NT', for `New Testament').
\end_layout

\begin_layout LyX-Code
Words → Synonym | Abbreviation | Example 
\end_layout

\begin_layout LyX-Code
Synonym → String
\end_layout

\begin_layout LyX-Code
Abbreviation → String
\end_layout

\begin_layout LyX-Code
Example → String
\end_layout

\begin_layout Standard
The semantic task of evaluating this will be discussed later.
\end_layout

\begin_layout Paragraph
Concatenation
\end_layout

\begin_layout Standard
This is sometimes known in the literature as `charade', and indicates one
 word placed beside another.
 
\end_layout

\begin_layout LyX-Code
Climb a trail (6)appliance
\end_layout

\begin_layout Standard
would yield the answer ASCENT, as the letter `A' is placed next to a word
 for trail (`SCENT').
 We represent this syntactically:
\end_layout

\begin_layout LyX-Code
Concatenation → Wordplay (ConcatIndicator) Wordplay
\end_layout

\begin_layout Standard
This represents a key tool for cluers to create more complex wordplay clues
 in the form of a charade, where two or more parts can be split out (sometimes
 syllabically as in `bath', `tub', or sometimes otherwise `bat',`htub')
 and clued separately, and then later joined to form the overall solution.
\end_layout

\begin_layout Subsection
Other Wordplay Operators
\end_layout

\begin_layout Standard
These operators all include an indicator word to show they are being applied.
 Each operator will usually have many different indicators (lists of anagram
 indicators on the web span multiple hundreds).
 Only select ones are included in the specification here.
\end_layout

\begin_layout Subsubsection
Unitary Operators 
\end_layout

\begin_layout Paragraph
Anagram 
\end_layout

\begin_layout Standard
A very commonly used operator in crossword clues is an anagram.
 In the clue
\end_layout

\begin_layout LyX-Code
Melon mistaken for a citrus fruit (5)
\end_layout

\begin_layout Standard
we have an indicator (`mistaken') to show that we can find an anaagram of
 `melon' to create a citrus fruit as the answer (`LEMON').
\end_layout

\begin_layout Standard
These take the form of an indicator word that denotes that the anagram function
 is being used (called an ‘anagrind’ by regular cruciverbalists ), along
 with the candidate letters to be anagrammed.
 
\end_layout

\begin_layout LyX-Code
Anagram → Anagrind, String | String, Anagrind 
\end_layout

\begin_layout Standard
We see that this grammar means that the words are anagrammed as given: `melon'
 is not transformed to `honeydew' before anagramming.
 Sometimes, however, in certain publications we find clues where there is
 some sort of operation applied to the letters before the anagram is applied.
 For example: 
\end_layout

\begin_layout LyX-Code
Comic bare for short comedy play (7,5) 
\end_layout

\begin_layout LyX-Code
==> Wordplay ‘Comic bare for short comedy’ = Definition ‘play’ 
\end_layout

\begin_layout LyX-Code
==> Anagram ‘bare for short comedy’ [anagrind = ‘comic’] 
\end_layout

\begin_layout LyX-Code
==> Anagram (“bare for” + Shorten ‘comedy’) 
\end_layout

\begin_layout LyX-Code
==> Anagram (“bare fore” + “comed”) 
\end_layout

\begin_layout LyX-Code
==> Anagram (“bare fore” + “comed”) 
\end_layout

\begin_layout LyX-Code
==> Anagram (“bareforecomed”) 
\end_layout

\begin_layout LyX-Code
==> “Bedroom Farce” 
\end_layout

\begin_layout Standard
In which case we find the more general case one proposed structure: 
\end_layout

\begin_layout LyX-Code
Anagram` → Anagrind, Wordplay | Wordplay, Anagrind 
\end_layout

\begin_layout Standard
Wherein we know that the repeated evaluation of the Wordplay will eventually
 result in a string literal that can be anagrammed.
 In 
\emph on
Art of the Crossword Puzzle, 
\emph default
Ximenes argued against this form of indirect anagram: 
\end_layout

\begin_layout Quote
\begin_inset Quotes eld
\end_inset

Secondly – and here, for once, I differ from Afrit – I hate what I call
 an indirect anagram.
 By that I mean "Tough form of monster" for HARDY (anagram of HYDRA).
 There may not be many monsters in five letters; but all the same I think
 the clue-writer is being mean and withholding information which the solver
 can reasonably demand.
 Why should he have to solve something before he can begin to use part of
 a clue? He has first to find "hydra" – and why shouldn't it be "giant"?
 – and then use the anagrammatic information to help him think of "hardy".
 ...
 My real point is that the secondary part of the clue – other than the definitio
n – is meant to help the solver.
 The indirect anagram, unless there are virtually no alternatives, hardly
 ever does.
 He only sees it after he has got his answer by other means.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
In sticking to solving Ximinean crosswords, we will treat clues such as
 these as `ungramatical'.
 Thus, our original definition of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Anagram
\end_layout

\end_inset

 is the correct one.
\end_layout

\begin_layout Paragraph
Reversal 
\end_layout

\begin_layout Standard
Clues can also be reversed.
 For example in
\end_layout

\begin_layout LyX-Code
Canine turned around for divine being (3) 
\end_layout

\begin_layout Standard
we have an indicator (`turned around') that a word for canine (`dog') can
 be reversed to form a divine being (`GOD').
\end_layout

\begin_layout Standard
While this is functionally a subset of anagrams, there are some crucial
 differences.
 Firstly the ‘directionality’ of the clue (i.e.
 whether it is a ‘down’ or an ‘across’) comes into effect, in determining
 the sorts of indicators that can form it: “turned back” may only apply
 to ‘across’ clues, where “taken up” may only apply to ‘down’ clues.
 
\end_layout

\begin_layout Standard
Further, while in anagrams, nested wordplay is not permitted, here we allow
 other operations (for example, finding a synonym of `canine') before applying
 the transformation.
 Therefore, while the nested wordplay in 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Canine turned around for divine being (3)
\end_layout

\end_inset

 is acceptable, where an equivalent clue as an anagram (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Canine messed around for divine being (3)
\end_layout

\end_inset

) would often not be seen as Ximenean.
 
\end_layout

\begin_layout LyX-Code
Anagram → ReversalIndictator, Wordplay | Wordplay, ReversalIndictator
\end_layout

\begin_layout LyX-Code
ReversalIndicator → 
\begin_inset Quotes eld
\end_inset

around
\begin_inset Quotes erd
\end_inset

 | 
\begin_inset Quotes eld
\end_inset

turned back
\begin_inset Quotes erd
\end_inset

 | 
\begin_inset Quotes eld
\end_inset

taken up
\begin_inset Quotes erd
\end_inset

 [...]
\end_layout

\begin_layout Paragraph
Contraction 
\end_layout

\begin_layout Standard
Clues of this form range from specific, such of first/last letters (`first
 in line' = `l', `last of the Mohicans' = `m') to more general operators
 (`mostly harmless' can yield `armless', `harmles', `harmle'...) whose definitions
 are more flexible.
\end_layout

\begin_layout LyX-Code
Contraction → FirstLetterContraction | LastLetterContraction | GeneralContractio
n 
\end_layout

\begin_layout LyX-Code
FirstLetterContraction → PreFLCIndicator, Wordplay | Wordplay, PostFLCIndicator
\end_layout

\begin_layout LyX-Code
LastLetterContraction → PreLLCIndicator, Wordplay | Wordplay, PostLLCIndicator
\end_layout

\begin_layout LyX-Code
GeneralContraction → PreGCIndicator, Wordplay | Wordplay, PostGCIndicator
\end_layout

\begin_layout Paragraph
Selection 
\end_layout

\begin_layout Standard
There are three similar operators here: A pair which selects even or odd
 letters respectively, and one which takes initial letters across multiple
 words.
 These are usually applied only to strings.
 The initials indicator needs to be applied to an argument consisting of
 multiple words.
\end_layout

\begin_layout LyX-Code
Selection → Evens | Odds | Initials
\end_layout

\begin_layout LyX-Code
Evens → EvensIndicator, String | String, EvensIndicator
\end_layout

\begin_layout LyX-Code
Odds → OddsIndicator, String | String, OddsIndicator
\end_layout

\begin_layout LyX-Code
Initials → InitialsIndicator, String, 
\begin_inset Quotes eld
\end_inset

 
\begin_inset Quotes eld
\end_inset

, String* | 
\begin_inset Newline newline
\end_inset

           String, 
\begin_inset Quotes eld
\end_inset

 
\begin_inset Quotes eld
\end_inset

, String*, InitialsIndicator
\end_layout

\begin_layout Standard
An example of the inital operator could be:
\end_layout

\begin_layout LyX-Code
Notice supervisor is going nuts at first (4)
\end_layout

\begin_layout Standard
cluing the answer `SIGN' as with the indicator `at first' and the first
 letters of each word in the phrase `supervisor is going nuts'.
\end_layout

\begin_layout Paragraph
Hidden word 
\end_layout

\begin_layout Standard
The hidden word clue finds a word which appears as a substring (ignoring
 spaces) inside its operand.
 These typically only occur once per puzzle, and are always accompanied
 by a clear indicator.
 In this example clue:
\end_layout

\begin_layout LyX-Code
Dog found in culdesac or ginnel (5)
\end_layout

\begin_layout Standard
the solution is CORGI, and which is concealed (indicated by `found in')
 in `culdesaC OR GInnel'.
 
\end_layout

\begin_layout LyX-Code
HiddenWord → HWIndictator String | String HWIndicator
\end_layout

\begin_layout Standard

\series bold
Homophone
\end_layout

\begin_layout Standard
Also called `sounds like', this operator produces homophones of a given
 word, for example `right' and `rite'.
 This operator is not applied to words that are both spelled and said the
 same, but with different meanings (`must' as an imperative and `must' as
 a noun).
 
\end_layout

\begin_layout Standard
Often, if clues are straightforward, placement of this operator can determine
 the spelling of the answer.
 
\end_layout

\begin_layout LyX-Code
We hear twins shave (4)
\end_layout

\begin_layout Standard
yields `pare' whereas
\end_layout

\begin_layout LyX-Code
Twins shave, we hear (4)
\end_layout

\begin_layout Standard
yields `pair'.
 A formulation with the indicator in the middle, in this case, would result
 in a strong ambiguity.
 The homophone indicator is only applied to equivalence words, not to clued
 wordplay.
\end_layout

\begin_layout LyX-Code
Homophone → HomophoneIndicator Words | Words HomophoneIndicator
\end_layout

\begin_layout Subsubsection
Binary Operators 
\end_layout

\begin_layout Standard
As with the unitary operator, each of the arguments of binary operators
 can be one or more words.
\end_layout

\begin_layout Paragraph
Insertion 
\end_layout

\begin_layout Standard
Here are two styles of wordplay which are clued very differently, but are
 actually the same operator, which places one set of letter inside another.
 This is either presented as a insertion (e.g..
 `end inside ls') or as a containment (e.g.
 `ls around end').
 This operation always preserves letter order, unless some nested indicator
 allows otherwise.
 
\end_layout

\begin_layout LyX-Code
Insertion → Wordplay InsertionIndicator Wordplay  
\end_layout

\begin_layout LyX-Code
InsertionIndicator → 
\begin_inset Quotes eld
\end_inset

inside
\begin_inset Quotes erd
\end_inset

 | 
\begin_inset Quotes eld
\end_inset

around
\begin_inset Quotes erd
\end_inset

 [...]
\end_layout

\begin_layout Paragraph
Subtraction 
\end_layout

\begin_layout Standard
In a subtraction clue, a number of letters are removed from the target.
 Usually, the target is some wordplay itself, although sometimes just a
 string literal.
 The letters to be subtracted are also often the product of some sort of
 cluing, although this is usually fairly limited in scope (abbreviations,
 contractions, first letters of string literals).
 There are two constraints on this: all the letters from the subtraction
 set must be in the target, and the length of the subtraction set must be
 less than the length of the target.
 
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
Give example
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
Subtraction → SubPreIndictator1 Wordplay (SubPreIndictator2) Wordplay 
\begin_inset Newline newline
\end_inset

   | Wordplay SubMidIndictator Wordplay 
\begin_inset Newline newline
\end_inset

   | Wordplay (SubPostIndictator1) Wordplay SubPostIndictator2 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
SubPreIndictator1 → 
\begin_inset Quotes eld
\end_inset

took
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

without
\begin_inset Quotes erd
\end_inset

 [...]
\end_layout

\begin_layout LyX-Code
SubPreIndictator2 → 
\begin_inset Quotes eld
\end_inset

from
\begin_inset Quotes erd
\end_inset

 [...]
\end_layout

\begin_layout LyX-Code
SubMidIndictator → 
\begin_inset Quotes eld
\end_inset

without
\begin_inset Quotes erd
\end_inset

 [...]
\end_layout

\begin_layout LyX-Code
SubPostIndictator1 → 
\begin_inset Quotes eld
\end_inset

with
\begin_inset Quotes erd
\end_inset

 [...]
\end_layout

\begin_layout LyX-Code
SubPostIndictator2 → 
\begin_inset Quotes eld
\end_inset

removed
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

deleted
\begin_inset Quotes erd
\end_inset

 [...]
\end_layout

\begin_layout Standard
Semantically here, we have the difference in pre- and post- as the difference
 between 
\begin_inset Quotes eld
\end_inset

wanted ant removed
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

removing ant wanted
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Standard
The letters in the set are thought to be removed in the order in which they’re
 found in order to be a properly clued wordplay.
\end_layout

\begin_layout Subsection
Meta-references 
\end_layout

\begin_layout Standard
Sometimes, clues contain references that cannot be parsed in isolation,
 or contain a cluing structure that is incompatible with the main model
 of cluing.
 Due to their complexity and requirement for context, I consider clues such
 as these outside of the scope of this project.
 These include:
\end_layout

\begin_layout Subsubsection
Self reference
\end_layout

\begin_layout Standard
A type of clue called an `&lit' clue allows the setter to not include a
 definition part if the text that makes up the wordplay also can also be
 read as the definition.
 Thus in 
\end_layout

\begin_layout LyX-Code
Spoil vote! (4)
\end_layout

\begin_layout Standard
we have the wordplay Anagram (=spoil) 
\begin_inset Quotes eld
\end_inset

vote
\begin_inset Quotes erd
\end_inset

 to give `VETO', as well as the clue as a whole `spoil vote' meaning `veto'.
\end_layout

\begin_layout Subsubsection
Reference to other clues
\end_layout

\begin_layout Standard
Some publications will have clues that reference the answer to other clues
 (`8 across.
 Cake made badly by 7 down.').
 Sometimes these may also be cyclical (in this example, 7 down would reference
 8 across too).
 
\end_layout

\begin_layout Subsubsection
Contextual References
\end_layout

\begin_layout Standard
Sometimes references will refer outside of the crossword itself.
 For example, The 
\emph on
Sunday Telegraph
\emph default
 on Easter Sunday 2014 had an anagram clue whose answer was EASTER SUNDAY,
 and its definition part was "today".
 In a crossword by setter 
\emph on
Araucaria
\emph default
, "Araucaria is" coded for IAM (= "I am") as part of an answer.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Chapter
Naive Solution 
\end_layout

\begin_layout Section
Solving Through Functional Programming
\end_layout

\begin_layout Standard
The approach taken to parsing and solving cryptic crossword clues in this
 project will be by using the functional programming language Haskell to
 generate and evaluate abstract syntax trees.
 
\end_layout

\begin_layout Standard
Haskell lends itself well to parsing languages: there are Haskell parsers
 for javascript
\begin_inset Foot
status open

\begin_layout Plain Layout
https://github.com/alanz/language-javascript
\end_layout

\end_inset

, scheme
\begin_inset Foot
status open

\begin_layout Plain Layout
https://github.com/zenazn/scheme-in-haskell/
\end_layout

\end_inset

, and even natural language
\begin_inset Foot
status open

\begin_layout Plain Layout
http://homepages.inf.ed.ac.uk/wadler/realworld/natlangproc.html
\end_layout

\end_inset

.
 The Glasgow Haskell Compiler itself is written largely in Haskell
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.haskell.org/haskellwiki/Implementations#Glasgow_Haskell_Compiler_.28GHC.2
9
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
There may be many reasons for this.
 Firstly, Haskell's data structures lend themselves well to modelling abstract
 syntax trees.
 Secondly, lazy evaluation means that large quantities of trees may be produced
 symbolically and only analysed when necessary, meaning that large and complex
 grammars which produce many parses can be handled elegantly.
 Finally, Haskell's type strictness makes it possible to write complex programs
 that act upon complex external data structures without requiring large
 quantities of unit or integration testing.
 
\end_layout

\begin_layout Standard
While the described program benefits heavily from many of the features of
 Haskell, the work here could be implemented without too much adjustment
 in many other functional languages, and many modern multi-paradigm languages,
 such as Python.
\end_layout

\begin_layout Section
Parsing and Evaluating everything 
\end_layout

\begin_layout Subsection
Solving a Clue
\end_layout

\begin_layout Standard
Our motivation here is to take a cryptic crossword clue, for example:
\end_layout

\begin_layout LyX-Code
[A]  Ship carrying right flag (8)
\end_layout

\begin_layout LyX-Code
[B]  Companion shredded corset (6)
\end_layout

\begin_layout Standard
and attempt to parse and solve it to provide the correct answer.
 We will define the datatype of Clue thus:
\end_layout

\begin_layout LyX-Code
data Clue = Clue String AnswerLength
\end_layout

\begin_layout LyX-Code
where
\end_layout

\begin_layout LyX-Code
type Length = Int
\end_layout

\begin_layout Standard
In order to solve this clue, we want to find a function that takes a clue,
 which consists of a string containing the text of the clue and an integer
 representing the length of the required answer, and returns us the answer.
\end_layout

\begin_layout LyX-Code
solve :: Clue → Answer 
\end_layout

\begin_layout Standard
The intuition behind how our naive solver will work is that it will generated
 all possible ways of parsing a clue, then generate all possible answers
 that could be derived from those parses, and then attempt to match those
 up with the definition and the length constraints.
 In order to evaluate, measure and optimize each of these steps independently,
 we split the structure of our program into four parts:
\end_layout

\begin_layout LyX-Code
solve = choose .
 evaluate .
 parse .
 split
\end_layout

\begin_layout Standard
where the types are given below:
\end_layout

\begin_layout LyX-Code
split    :: Clue → [Split]
\end_layout

\begin_layout LyX-Code
parse    :: [Split] → [Parse]
\end_layout

\begin_layout LyX-Code
evaluate :: [Parse] → [Answer]
\end_layout

\begin_layout LyX-Code
choose   :: [Answer] → Answer
\end_layout

\begin_layout Subsection
Splitting
\end_layout

\begin_layout Standard
While a clue has a surface reading involving the semantic natural language
 parsing of it as a sentence fragment (which would yield a phrase, with
 an subject, a past tense verb and an object), we are only interested in
 the crossword interpretation of this, which is of the form: 
\end_layout

\begin_layout LyX-Code
  Definition Indicator* Wordplay 
\end_layout

\begin_layout LyX-Code
| Wordplay Indicator* Definition
\end_layout

\begin_layout Standard
Let us forget about the optional indicators for now – we will deal with
 these properly later .
 We are looking to define a function 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
split
\end_layout

\end_inset

 which splits the clue into a wordplay portion and a definition portion.
 So for example, clue 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
A
\end_layout

\end_inset

 can be split 6 different ways:
\end_layout

\begin_layout LyX-Code
 wordplay  definition         definition  wordplay
\end_layout

\begin_layout LyX-Code
   
\begin_inset Formula $\mathtt{\overbrace{Ship}\:\overbrace{carrying\: right\: flag}}$
\end_inset

         
\begin_inset Formula $\mathtt{\overbrace{Ship}\:\overbrace{carrying\: right\: flag}}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \thinspace{}
\end_inset


\end_layout

\begin_layout LyX-Code
    wordplay  definition         definition  wordplay
\end_layout

\begin_layout LyX-Code
   
\begin_inset Formula $\mathtt{\overbrace{Ship\, carrying}\:\overbrace{right\: flag}}$
\end_inset

         
\begin_inset Formula $\mathtt{\overbrace{Ship\, carrying}\:\overbrace{right\: flag}}$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset space \thinspace{}
\end_inset


\end_layout

\begin_layout LyX-Code
       wordplay definition       definition   wordplay
\end_layout

\begin_layout LyX-Code
   
\begin_inset Formula $\mathtt{\overbrace{Ship\, carrying\, right}\:\overbrace{flag}}$
\end_inset

        
\begin_inset Formula $\mathtt{\overbrace{Ship\, carrying\, right}\:\overbrace{flag}}$
\end_inset

  
\end_layout

\begin_layout Standard
From the types of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Wordplay
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Definition
\end_layout

\end_inset

:
\end_layout

\begin_layout LyX-Code
type Definition = String
\end_layout

\begin_layout LyX-Code
type Wordplay = String
\end_layout

\begin_layout Standard
we can create a datatype
\end_layout

\begin_layout LyX-Code
data Split = Def Definition Wordplay AnswerLength
\end_layout

\begin_layout Standard
as well as the signature of a function 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
split
\end_layout

\end_inset

:
\end_layout

\begin_layout LyX-Code
split :: Clue → [Split]
\end_layout

\begin_layout LyX-Code
split (text length) = 
\end_layout

\begin_layout LyX-Code
    let parts = partitions .
 words $ text 
\end_layout

\begin_layout LyX-Code
    in [Def (unwords d) (unwords w) length | [d,w] <- parts]
\end_layout

\begin_layout Standard
where partitions finds all ways of partitioning a list, and is defined as
\end_layout

\begin_layout LyX-Code
partitions [] = [[]] 
\end_layout

\begin_layout LyX-Code
partitions (x:xs) = [[x]:p | p <- partitions xs] 
\end_layout

\begin_layout LyX-Code
                ++ [(x:ys):yss | (ys:yss) <- partitions xs]
\end_layout

\begin_layout Subsection
Parsing
\end_layout

\begin_layout Standard
Now we have consumed one portion of the string to form the definition in
 each of a list of splits.
 Now we need to parse the rest of the clue into a structure which we can
 evaluate to produce our answer.
 Let us take for an example the correct split (of the 6 available) of clue
 A:
\end_layout

\begin_layout LyX-Code
       wordplay  definition       
\end_layout

\begin_layout LyX-Code
   
\begin_inset Formula $\mathtt{\overbrace{Ship\, carrying\, right}\:\overbrace{flag}}$
\end_inset

     
\end_layout

\begin_layout Standard
which would have the Haskell structure of 
\end_layout

\begin_layout LyX-Code
Def 
\begin_inset Quotes eld
\end_inset

flag
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

ship carrying right
\begin_inset Quotes erd
\end_inset

 8
\end_layout

\begin_layout Standard
The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
parse
\end_layout

\end_inset

 function must, for each split, consume the wordplay and return all possible
 parses for that wordplay.
 Since each split will return multiple parses, we will want to collect these
 afterwards.
 We define datatype 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Parse
\end_layout

\end_inset

:
\end_layout

\begin_layout LyX-Code
data Parse = Parse Definition ParseTree AnswerLength
\end_layout

\begin_layout Standard
where 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
ParseTree
\end_layout

\end_inset

 will be an Abstract Syntax Tree based on the structure of our clue.
\end_layout

\begin_layout LyX-Code
data ParseTree =  ConcatNode ParseTree ParseTree | SynonymNode String  
   
\end_layout

\begin_layout LyX-Code
   | AnagramNode Anagrind String 
\end_layout

\begin_layout LyX-Code
   | InsertionNode InsertionIndicator ParseTree ParseTree 
\end_layout

\begin_layout LyX-Code
   | SubtractionNode SubtractionIndicator ParseTree ParseTree 
\end_layout

\begin_layout LyX-Code
   | HiddenWordNode HWIndicator [String] 
\end_layout

\begin_layout LyX-Code
   | ReversalNode ReversalIndicator ParseTree 
\end_layout

\begin_layout LyX-Code
   | FirstLetterNode FLIndicator [String] 
\end_layout

\begin_layout LyX-Code
   | LastLetterNode LLIndicator [String] 
\end_layout

\begin_layout LyX-Code
   | PartialNode PartialIndicator ParseTree 
\end_layout

\begin_layout Standard
So we will define:
\end_layout

\begin_layout LyX-Code
parse :: [Split] -> [Parse]
\end_layout

\begin_layout LyX-Code
parse = concatMap parseClue
\end_layout

\begin_layout Standard
where
\end_layout

\begin_layout LyX-Code
parseClue :: Split -> [Parse]
\end_layout

\begin_layout Standard
In our example, we would require 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
parseClue
\end_layout

\end_inset

 to consume the string 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Ship carrying right flag 
\end_layout

\end_inset

 to generate the following parse trees 
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.CONCATENATION [.SYNONYM "ship" ][.LAST
\backslash
 LETTER
\backslash
 ("right") [.SYNONYM "carrying" ]]]
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.CONCATENATION [.SYNONYM "ship" ][.CONCATENATION [.SYNONYM "carrying" ][.SYNONYM
 "flag" ]]]
\end_layout

\end_inset

 
\begin_inset VSpace defskip
\end_inset


\begin_inset VSpace defskip
\end_inset

as well as the correct one:
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.INSERTION
\backslash
 ("carrying") [.SYNONYM "ship" ] [.ABBREVIATION "right" ]]
\end_layout

\end_inset

 
\begin_inset VSpace defskip
\end_inset

and so on.
\end_layout

\begin_layout Subsubsection
Traditional Scanner-Based Parsing
\end_layout

\begin_layout Standard
In order to perform the lexical analysis required to parse a programming
 lanaguage, first a step is performed called tokenisation.
 This is the process of grouping characters together into functional groups
 called 
\noun on
tokens
\noun default
, to later pass to the parser to perform the semantic analysis on.
 Tokens consist of a 
\noun on
lexeme
\noun default
 the string of characters known to be of a certain type, and the value they
 represent (for example 
\noun on
integer 3
\noun default
 or 
\noun on
variable name 
\noun default

\begin_inset Flex Code
status open

\begin_layout Plain Layout
`available_credit'
\end_layout

\end_inset

).
 The process is often split into two stages.
 
\end_layout

\begin_layout Paragraph
The Scanner
\end_layout

\begin_layout Standard
The first is the 
\noun on
scanner: 
\noun default
this is often a finite state machine, which will consume characters based
 on rules to produce potential lexemes.
 In a traditional programming language, the scanner might consume a string
 such as 
\end_layout

\begin_layout LyX-Code
x = y + 3
\end_layout

\begin_layout Standard
to give the lexemes
\end_layout

\begin_layout LyX-Code
x
\end_layout

\begin_layout LyX-Code
=
\end_layout

\begin_layout LyX-Code
y
\end_layout

\begin_layout LyX-Code
+
\end_layout

\begin_layout LyX-Code
3
\end_layout

\begin_layout Standard
Simple scanners can operate under greedy assumptions (called the Maximal
 Munch principle by R.G.G.
 Cattel), and some require backtracking (for example, the language 
\noun on
C
\noun default
).
 
\end_layout

\begin_layout Paragraph
The Evaluator
\end_layout

\begin_layout Standard
This stage of the tokeniser takes each lexeme, and assigns it to a representatio
n of what it functionally means.
 In the example above, our evaluator would output
\end_layout

\begin_layout Standard

\noun on
variable 
\noun default
x
\end_layout

\begin_layout Standard

\noun on
function =
\end_layout

\begin_layout Standard

\noun on
variable y
\end_layout

\begin_layout Standard

\noun on
Function +
\end_layout

\begin_layout Standard

\noun on
Integer 3
\end_layout

\begin_layout Paragraph
Scannerless Parsing
\end_layout

\begin_layout Standard
The separation betwen scanner and evaluation is considered advantageous
 design as the separation of concerns means that each component can be written
 and proved correct individually.
 Some languages, however, parse without having separate scanner and evaluator
 stages, in a process known as 
\noun on
Scannerless Parsing.

\noun default
 This is used where the grammar of the language is not regular, or is designed
 to be composable with other gramatical definitions.
\end_layout

\begin_layout Standard
Due to the complexity and ambiguity of the language of cryptic crossword
 clues, it is not possible to produce an accurate scanner that produces
 anything other than a trivial tagging of lexical elements
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
It would, of course, be possible to produce a trivial parser for most languages,
 in which we lex every character or group of letters to a function with
 the value of itself.
 For the input string 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

x = 3
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 so instead of the desired 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

 →
\end_layout

\end_inset

 
\noun on
variable 
\noun default
x
\noun on
, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout

\noun on
\begin_inset Quotes eld
\end_inset

=
\begin_inset Quotes erd
\end_inset

 
\noun default
→
\end_layout

\end_inset

 equals, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout

\noun on
\begin_inset Quotes eld
\end_inset

3
\begin_inset Quotes erd
\end_inset

 
\noun default
→
\end_layout

\end_inset

 integer 3 
\noun default
we could instead simply parse to 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

 →
\end_layout

\end_inset

 
\noun on
function 
\noun default
x
\noun on
, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout

\noun on
\begin_inset Quotes eld
\end_inset

=
\begin_inset Quotes erd
\end_inset

 
\noun default
→
\end_layout

\end_inset

 function =, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout

\noun on
\begin_inset Quotes eld
\end_inset

3
\begin_inset Quotes erd
\end_inset

 
\noun default
→
\end_layout

\end_inset

 function 3
\noun default
, and leave it to the rest of the pipeline to determine that 
\noun on
function 3
\noun default
 is a constant function which always yields the integer literal 3.
 This, however, missed the point of having the scanner at all!
\end_layout

\end_inset

: one word may represent the string of its letters (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

messed
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

), an indicator 
\noun on
(AnagramIndicator
\noun default
 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

messed
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

), or its semantic meaning 
\noun on
(Synonym
\noun default
 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

messed
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

, which would evaluate to `disarrayed', `untidy' etc.).
 The parser we produce will therefore combine a scanner and evaluator together
 into a scannerless parser.
\end_layout

\begin_layout Subsubsection
Parsing different clue types
\end_layout

\begin_layout Standard
So we need to define a function 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
parseClue
\end_layout

\end_inset

 which will produce a parse tree from an unconsumed split.
 So we have
\end_layout

\begin_layout LyX-Code
parseClue :: Split → ParseTree
\end_layout

\begin_layout Standard
We will define parseString in terms of its parsing of various clue types,
 starting with one of the more simple unary ones.
 We will then write a parser combination function [Frost, Launchbury] to
 combine the different sub-parsers into one top-level parser.
 We will hold back from the details of unpacking a split into the string
 to be consumed until later.
\end_layout

\begin_layout LyX-Code
parseAnagram :: String → [ParseTree]
\end_layout

\begin_layout LyX-Code
parseAnagram xs = 
\end_layout

\begin_layout LyX-Code
 [AnagramNode (AIndicator x) y |
\end_layout

\begin_layout LyX-Code
              (x,y) <- includeReversals .
 twoPartitions $ xs
\end_layout

\begin_layout LyX-Code
                                     , isAnagramIndicator(x)]
\end_layout

\begin_layout Standard
where
\end_layout

\begin_layout LyX-Code
twoPartitions xs = [(x,y) | [x,y] <- partitions xs]
\end_layout

\begin_layout LyX-Code
includeReversals xs = xs ++ [(snd(x),fst(x)) | x <- xs]  
\end_layout

\begin_layout Standard
We allow both (x, y) and (y, x) through 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
includeReversals
\end_layout

\end_inset

 in order to allow 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
muddled word
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
word muddled
\end_layout

\end_inset

 both to indicate anagrams of 
\begin_inset Quotes eld
\end_inset

word
\begin_inset Quotes erd
\end_inset

.
 This means a that in example [B] we parse both 
\end_layout

\begin_layout Standard
.
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.DEFINITION
\backslash
 "companion" [.ANAGRAM
\backslash
 ("shredded") "corset" ]]
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "5col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Plain Layout
and
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.DEFINITION
\backslash
 "corset" [.ANAGRAM
\backslash
 ("shredded") "companion" ]]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
.
\end_layout

\begin_layout Standard
Anagram clues, along with Hidden Word clues only require a definition and
 a string, so their operands don't require any further parsing.
 Other clues, though, may require the operands to be parsed.
 For example, the parsing of the clue 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Almost perfect concept (5)
\end_layout

\end_inset

 as 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
IDEA(L)
\end_layout

\end_inset

 requires 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
PERFECT
\end_layout

\end_inset

 to be parsed into a synonym node after we consumer nearly to be an indicator
 for a partial word node.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.DEFINITION
\backslash
 "concept" [.PARTIAL
\backslash
 ("almost") [.
\backslash
emph{
\backslash
{unparsed: "perfect"
\backslash
}} ] ] ]
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "5col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

 ⇒ 
\end_layout

\begin_layout Plain Layout
parse
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.DEFINITION
\backslash
 "concept" [.PARTIAL
\backslash
 ("almost") [.SYNONYM "perfect" ] ] ]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset

we therefore perform what is called Recursive Descent Parsing [Lewis]
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
citation
\end_layout

\end_inset

, letting Haskell's list comprehension take care of matching the correct
 partition to the correct parse.
\end_layout

\begin_layout LyX-Code
parsePartialNode :: String → [ParseTree]
\end_layout

\begin_layout LyX-Code
parsePartialNode xs = [PartialNode (LLIndicator x) y' 
\end_layout

\begin_layout LyX-Code
         |(x,y) <- includeReversals .
 twoPartitions $ xs
\end_layout

\begin_layout LyX-Code
          , isPartialIndicator(x)
\end_layout

\begin_layout LyX-Code
          , y' <- parseClue y]
\end_layout

\begin_layout Standard
Still more complex clue types require splitting into three parts – two branches
 and an indicator – and often both of these branches require further parsing.
 For example, in the case of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
SHIP CARRYING RIGHT FLAG
\end_layout

\end_inset

, choosing 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
FLAG
\end_layout

\end_inset

 as the definition, we can generate
\end_layout

\begin_layout Verse
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.INSERTION
\backslash
 ("carrying") [.
\backslash
emph{
\backslash
{unparsed string:
\backslash
 "ship"
\backslash
}} ] [.
\backslash
emph{
\backslash
{unparsed string:
\backslash
 "right"
\backslash
}} ]]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and then consume each of the unparsed strings in turn to produce
\end_layout

\begin_layout Verse
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.INSERTION
\backslash
 ("carrying") [.SYNONYM "ship" ] [.ABBREVIATION "right" ]]
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
It is worth noting here that as well as the top-level parse generating multiple
 different options, each of these sub-parses may also generate several different
 parses, and these themselves may be complex with multiple sub-parses.
 In the clue 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
WORK HARD IN ATTEMPT TO GET CUP
\end_layout

\end_inset

, with definition (=`
\begin_inset Flex Code
status open

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset


\begin_inset Quotes erd
\end_inset

to get
\end_layout

\end_inset

') of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
CUP
\end_layout

\end_inset

, we can parse the wordplay as
\end_layout

\begin_layout Verse
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.INSERTION
\backslash
 ("in") [.
\backslash
emph{
\backslash
{unparsed string:
\backslash
 "work hard"}
\backslash
} ] [.SYNONYM "attempt" ]]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
which may subsequently evaluate to the (correct, in this case) parse:
\end_layout

\begin_layout Verse
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.INSERTION
\backslash
 ("in") [.CONCATENATION [.SYNONYM "work" ]  [.ABBREVIATION "hard" ] ] [.SYNONYM
 "attempt" ]]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
as well as others, such as: 
\end_layout

\begin_layout Verse
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.INSERTION
\backslash
 ("in") [.ANAGRAM
\backslash
 ("work") "hard" ] [.SYNONYM "attempt" ]]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here, again, we allow Haskell's list comprehension take care of constructing
 the sub- parse-trees from our recursive calls and constructing them into
 our final list of trees, for example in
\end_layout

\begin_layout LyX-Code
parseConcatNodes :: String -> [ParseTree] 
\end_layout

\begin_layout LyX-Code
parseConcatNodes xs n = let parts = twoParts xs 
\end_layout

\begin_layout LyX-Code
      in [ConcatNode x' y' |( x,y,z) <- parts
\end_layout

\begin_layout LyX-Code
                                  , x' <- (parseClue x)
\end_layout

\begin_layout LyX-Code
                                  , y' <- (parseClue y)]
\end_layout

\begin_layout Standard
and in 
\end_layout

\begin_layout LyX-Code
 parseInsertionNodes :: String -> [ParseTree] 
\end_layout

\begin_layout LyX-Code
 parseInsertionNodes xs n = let parts = threeParts xs                  
 
\end_layout

\begin_layout LyX-Code
       in [InsertionNode (IIndicator y) x' z' 
\end_layout

\begin_layout LyX-Code
           | (x,y,z) <- parts, isInsertionWord(y)
\end_layout

\begin_layout LyX-Code
             , x' <- (parseClue x)
\end_layout

\begin_layout LyX-Code
             , z' <- (parseClue z)] 
\end_layout

\begin_layout Standard
We can then compose each expression type together to form our final definition
 of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
parseClue
\end_layout

\end_inset

, checking the number of words in the phrase to check that we will be able
 to split the string correctly into 2 or 3 parts.
\end_layout

\begin_layout LyX-Code
parseClue :: Split -> [ParseTree] 
\end_layout

\begin_layout LyX-Code
parseClue (Def def ys n) = let len = length .
 words $ ys in
\end_layout

\begin_layout LyX-Code
[SynonymNode ys]    
\end_layout

\begin_layout LyX-Code
++ (if len > 1 then parseConcatNodes ys else [] )  
\end_layout

\begin_layout LyX-Code
++ (if len > 1 then parseAnagramNodes ys else [] )   
\end_layout

\begin_layout LyX-Code
++ (if len > 1 then parseHiddenWordNodes ys else [])   
\end_layout

\begin_layout LyX-Code
++ (if len > 2 then parseInsertionNodes ys else [])   
\end_layout

\begin_layout LyX-Code
++ (if len > 2 then parseSubtractionNodes ys else [])   
\end_layout

\begin_layout LyX-Code
++ (if len > 1 then parseReversalNodes ys else [])  
\end_layout

\begin_layout LyX-Code
++ (if len > 1 then parseFirstLetterNodes ys else [])   
\end_layout

\begin_layout LyX-Code
++ (if len > 1 then parseLastLetterNodes ys else [])   
\end_layout

\begin_layout LyX-Code
++ (if len > 1 then parsePartialNodes ys else [])
\end_layout

\begin_layout Standard
We can then define 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
parse
\end_layout

\end_inset

as
\end_layout

\begin_layout LyX-Code
parse = concatMap parseClue
\end_layout

\begin_layout Subsection
Evaluation
\end_layout

\begin_layout Standard
In the evaluation stage we look to define a function 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
evaluate
\end_layout

\end_inset

with the type signature: 
\end_layout

\begin_layout LyX-Code
evaluate :: [Parse] → [Answer]
\end_layout

\begin_layout Standard
where 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
evaluate
\end_layout

\end_inset

 will consume 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Parse
\end_layout

\end_inset

 data in the form 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Def Definition ParseTree AnswerLength
\end_layout

\end_inset

and produce 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
[Answer]
\end_layout

\end_inset

, where:
\end_layout

\begin_layout LyX-Code
data Answer = Answer String Parse
\end_layout

\begin_layout Standard
The parse is included along with the answer, as it contains the definition
 for that parse, which will later allow us to check that our generated answer
 has some relation to what we thought we were looking for in that parse,
 and also allows us to reconstruct the reasoning behind the clue by inspecting
 the parse tree.
\end_layout

\begin_layout Standard
We can define a function 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
evalTree
\end_layout

\end_inset

Refeerence in terms of the different types of node in our 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
ParseTree
\end_layout

\end_inset

 type.
 Those without subtrees will be defined simply with reference to a Haskell
 function that performs their action:
\end_layout

\begin_layout LyX-Code
eval_tree :: ParseTree -> [String]
\end_layout

\begin_layout LyX-Code
eval_tree (AnagramNode ind xs) c = anagrams xs
\end_layout

\begin_layout LyX-Code
eval_tree (SynonymNode xs) = synonyms xs
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code
anagrams :: String -> [String] 
\end_layout

\begin_layout LyX-Code
anagrams [] = [[]] 
\end_layout

\begin_layout LyX-Code
anagrams xs = [x:ys | x<- nub xs, ys <- anagrams $ delete x xs]
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code
synonyms :: String -> [String] 
\end_layout

\begin_layout LyX-Code
synonyms xs = Map.lookup xs thesaurus
\end_layout

\begin_layout Standard
and so on.
 Clues with sub-trees are treated with a similar recursive call, with either
 a map, or a list comprehension applying the expressions function to each
 generated sub-answer
\end_layout

\begin_layout LyX-Code
eval_tree (ReversalNode ind ys) = map reverse (eval_tree ys)
\end_layout

\begin_layout LyX-Code
eval_tree (ConcatNode ind xs ys) = [x ++ y | x <- eval_tree xs
\end_layout

\begin_layout LyX-Code
                                           , y <- eval_tree ys]
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
From these definitions, we can define a function 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
eval
\end_layout

\end_inset

, which consumes the initial clue string and packages the output string
 along with the parse in the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Answer
\end_layout

\end_inset

 data structure:
\end_layout

\begin_layout LyX-Code
eval (Def d pt l) = [Answer x (Def d pt l) |
\end_layout

\begin_layout LyX-Code
                                        x <- evalTree pt]
\end_layout

\begin_layout Standard
As the evaluation of each 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Parse
\end_layout

\end_inset

 will yield a list of multiple 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Answer
\end_layout

\end_inset

 (e.g.
 an anagram node of a five-letter word will evaluate to 120 different answers,
 although very few of them will be valid words), we finally define 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
evaluate
\end_layout

\end_inset

as 
\end_layout

\begin_layout LyX-Code
evaluate = concatMap eval
\end_layout

\begin_layout Subsection
Selection
\end_layout

\begin_layout Standard
Finally, given that we've produced our list of answers, most of which will
 be meaningless combinations of jumbled letters and synonyms pressed together,
 we need to filter down to the answer containing a string which in some
 way meets the criteria set for us in the clue, that is 1.
 finding an answer that is a synonym of the part of the clue we chose as
 the definition 2.
 being the right number of letters.
\end_layout

\begin_layout Standard
So we can define 
\end_layout

\begin_layout LyX-Code
choose :: [Answer] → Answer
\end_layout

\begin_layout LyX-Code
choose = head .
 filter valid 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code
valid (Answer ans (Def def pt len)) = (length ans == len) 
\end_layout

\begin_layout LyX-Code
                                      && (is_synonym ans def)
\end_layout

\begin_layout Standard
Of course, we may not have generated a valid solution, so we can redefine
 to include this uncertainty:
\end_layout

\begin_layout LyX-Code
choose :: [Answer] → Maybe Answer
\end_layout

\begin_layout LyX-Code
choose = headM .
 filter valid 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Section
State space and performance analysis
\end_layout

\begin_layout Subsection
Overview - does it work? 
\end_layout

\begin_layout Standard
This approach has the required structure to correctly parse and solve most
 cryptic crossword clues — with some caveats.
 
\end_layout

\begin_layout Standard
Firstly, although in most cases the correct parse was generated, often the
 number of other parses to be evaluated before reaching the correct one
 was so great that the computation would effectively not end.
 In this case, the heap size wasn't continually growing, as each evaluation
 branched and then diminished in turn, but the running time was sufficiently
 large (>48hrs) such that the computation would be useless in a practical
 situation.
 The data for this is considered in 
\series bold
6.2
\end_layout

\begin_layout Standard
In other cases the correct parse was created, however the semantic data
 wasn't available to evaluate the clue correctly.
 In other, very rare cases, there is a clue which does not fit the structure
 of the grammar defined in 
\series bold
Part I
\series default
.
 These do not generate the correct parse trees, and so are not soluble.
 These are discussed in 
\series bold
6.3
\series default
.
\end_layout

\begin_layout Subsection
Correctly parsed and evaluated clues
\end_layout

\begin_layout Standard
Most clues, if they yield any results at all, yield them within 30 seconds
 of being run.
 Many others yield them a very long time afterwards – multiple hours of
 runtime is required to reach them.
 Others seem to run indefinitely.
 
\end_layout

\begin_layout Standard
Of those that do not terminate within an acceptable timeframe, the generated
 parse trees can be inspected and it can be shown that the correct one has
 been generated, and that since no individual evaluation takes infinite
 time, and each evaluation uses a non-problematic amount of stack space
 (that is to say –
\begin_inset space ~
\end_inset

the stack does not increase with each subsequent evaluation), then we can
 say that the clue is solvable, even if not in a reasonable amount of time.
 
\end_layout

\begin_layout Standard
The clue 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
FRIEND FOUND IN OKLAHOMA TERMINAL (4)
\end_layout

\end_inset

 yields the correct parse:
\end_layout

\begin_layout LyX-Code
Def "friend" (HiddenWordNode (HWIndicator ["found","in"]) 
\end_layout

\begin_layout LyX-Code
                                    ["oklahoma","terminal"])
\end_layout

\begin_layout Standard
however it also generates 59 others, including:
\end_layout

\begin_layout LyX-Code
Def "friend" (InsertionNode (IIndicator ["in"]) (SynonymNode "found") 
\end_layout

\begin_layout LyX-Code
               (ConsNode (SynonymNode "oklahoma") (SynonymNode "terminal")))
\end_layout

\begin_layout LyX-Code
Def "terminal" (InsertionNode (IIndicator ["in"]) 
\end_layout

\begin_layout LyX-Code
            (SynonymNode "friend found") (SynonymNode "oklahoma"))
\end_layout

\begin_layout LyX-Code
Def "oklahoma terminal" (ConsNode (SynonymNode "friend") 
\end_layout

\begin_layout LyX-Code
                                  (SynonymNode "found"))
\end_layout

\begin_layout LyX-Code
Def "terminal" (ConsNode (SynonymNode "friend") (ConsNode (SynonymNode "found")
 
\end_layout

\begin_layout LyX-Code
               (ConsNode (SynonymNode "in") (SynonymNode "oklahoma"))))
 
\end_layout

\begin_layout LyX-Code
Def "terminal" (ConsNode (ConsNode (SynonymNode "friend") 
\end_layout

\begin_layout LyX-Code
                         (SynonymNode "found")) (SynonymNode "in oklahoma"))
\end_layout

\begin_layout LyX-Code
Def "friend found" (SynonymNode "in oklahoma terminal") 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
Def "in oklahoma terminal" (ConsNode (SynonymNode "friend") 
\end_layout

\begin_layout LyX-Code
                                     (SynonymNode "found")) 
\end_layout

\begin_layout LyX-Code
Def "in oklahoma terminal" (SynonymNode "friend found") 
\end_layout

\begin_layout Standard
While evaluation of the correct parse takes 0.05 seconds, the evaluation
 of the first of the other examples takes over 10 seconds - it is the cumulative
 effect of the evaluation of the others, as well as the order in which they
 appear in the list which determines how long the total solving time takes.
 
\end_layout

\begin_layout Paragraph
Selected results
\end_layout

\begin_layout Standard
The variation in solving time for some selected clues can be seen in 
\series bold
Figure 1.

\series default
 Collecting more large-scale data on the solvability of clues is difficult
 at this stage: 96% of clues do not yield an answer (positive or negative)
 during 48hr evaluation.
 This is largely because of the sheer number of solutions that can be produced
 by one clue.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways true
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="6">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Clue
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Solution
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Clue Length
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
# Parses
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
# Solutions
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Solve Time
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
COMPANION SHREDDED CORSET (6)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ESCORT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
148,500
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.2s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HOPE FOR HIGH PRAISE (6)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ASPIRE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
105,718,343
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.39s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MARIA NOT A FICKLE LOVER (9)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
INAMORATA
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
60
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
84,855,252
\begin_inset script superscript

\begin_layout Plain Layout
2
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

—
\begin_inset script superscript

\begin_layout Plain Layout
1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FRIEND FOUND IN OKLAHOMA TERMINAL (4)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MATE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
59
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
92,995,844
\begin_inset script superscript

\begin_layout Plain Layout
2
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

—
\begin_inset script superscript

\begin_layout Plain Layout
1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PAUSE AT THESE I FANCY (8)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HESITATE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
54
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5,358,615
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.59s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ANKLE WAS TWISTED IN BALLET (8)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SWAN LAKE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
84
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
203,991,525
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12.13s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
NOTICE SUPERVISOR IS GOING NUTS AT FIRST (4)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SIGN
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
853
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

—
\begin_inset script superscript

\begin_layout Plain Layout
3
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

—
\begin_inset script superscript

\begin_layout Plain Layout
1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ATTEMPT TO SECURE ONE POUND FOR A HAT (6)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TRILBY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2930
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

—
\begin_inset script superscript

\begin_layout Plain Layout
3
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

—
\begin_inset script superscript

\begin_layout Plain Layout
1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Solving statistics for selected clues on a 2014 MacBook Pro
\end_layout

\end_inset


\end_layout

\begin_layout Verse
\begin_inset VSpace bigskip
\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Verse
\begin_inset VSpace bigskip
\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset script superscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

 Although the correct parse was generated, and selective evaluation of that
 parse yielded the correct results (i.e.
 a solution would be available eventually), the normal solving procedure
 did not compute the correct answer within 48hrs of running time
\end_layout

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset script superscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

 Due to Haskell's lazy evaluation, this can sometimes be calculated without
 actually computing the solution
\end_layout

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset script superscript

\begin_layout Plain Layout
3
\end_layout

\end_inset

 Could not yield answer within 48hrs 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
The effect of clue length on the number of parses
\end_layout

\begin_layout Standard
The length of the clue has an exponential effect on the number of parses
 produced.
 This is due partly to the increasing number of ways in which binary trees
 can be constructed from N elements, as in:
\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "25col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.
 [.
 A B ] [.
 C D ]]
\end_layout

\end_inset

 
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "25col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.
 [.A ] [.
 [ B C ] D ]]
\end_layout

\end_inset

 
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "25col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.
 [.
 A [.
 B C ]] [.D ]]
\end_layout

\end_inset

 
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "25col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.
 [.A ] [.
 B [.
 C D ] ]]
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "25col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.
 [.
 [.
 A B ] [.C ]] [.D ]]
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It also increases the availability for function words to interact with each
 other - when any A, B, C, or D in the examples above also have multiple
 parses, this is when we see the strongly trended exponential growth seen
 in 
\series bold
Figure 2 
\series default
(displayed on a logarithmic scale).
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename results/clue-length-to-parses.pdf
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Number of parses generated for varying clue lengths over 600 sample clues
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
The effect of clue length on the number of 
\series bold
solutions
\end_layout

\begin_layout Standard
We see a similar but even greater effect on the number of solutions produced,
 with the effect of the exponential growth per parse compounded by the fact
 that each parse can evaluate out to to thousands of options.
 This is due to two effects, Firstly, clues types like anagrams can have
 many thousand solutions per parse (there are 120 anagrams of a 5-letter
 word, rising to 40,320 anagrams of an eight letter word – an 
\begin_inset Formula $n!$
\end_inset

 relationship).
 Secondly, compound clues like insertions, which can take the result of
 one wordplay and insert into the second, can magnify the effect of branching
 in its sub-clues.
 
\end_layout

\begin_layout Standard
There are 4 ways that a word `A' can be inserted into a 5-letter word `B'.
 There are 480 ways that it can be inserted into each of the 120 anagrams
 of word `B', and if there are also 120 different anagrams of word `A',
 then there are 57600 different solutions for that parsed arrangement.
 We can see from 
\series bold
Figure 3 
\series default
that increasing the clue length increases the number of solutions rapidly.
 The effect is so pronounced that the data becomes sparse and unattainable
 around 4 letters long, as it takes unfeasibly long to generate any solutions.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename results/clue-length-to-evaluations evaluations.pdf
	width 100col%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Number of solutions evaluated for varying clue lengths over 75 sample clues
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The size of the thesaurus has a large impact on the number of solutions
 produced, as all clue types (other than Anagram, Hidden Word and Initials,
 which use String) use Synonym as the lowest level node in their sub-trees.
\end_layout

\begin_layout Standard

\series bold
Figure 4
\series default
 (also displayed on a logarithmic scale) shows how limiting the number of
 synonyms returned by the thesaurus affects the number of solutions.
 The graph plateaus as the restriction exceeds the actual number of synonyms
 per entry for each word in the thesaurus.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename results/evals_vs_dictionary.pdf
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Number of solutions evaluated by restricting the maximum thesaurus length
 for the clue 
\begin_inset Quotes eld
\end_inset

Good opportunity in school
\begin_inset Quotes erd
\end_inset

 (5)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Analysis of selected clues which are not correctly solved
\end_layout

\begin_layout Standard
It is difficult to perform a large-scale analysis of the numbers of clues
 for which the data does not exist, or where the correct parse is not generated,
 as often these will present themselves in the same way as the correct clues
 with too large a search space, that is by not terminating within an acceptable
 time.
 
\end_layout

\begin_layout Standard
These clues are therefore presented as an illustrative sample of the sorts
 of errors that prevent correct parse (
\series bold
6.3.4
\series default
) or correct evaluation (
\series bold
6.3.1 –
\begin_inset space ~
\end_inset

6.3.3) 
\series default
being generated.
\end_layout

\begin_layout Subsubsection*
SHINY SILVER PAPER IN THE STREET (8)  (= 
\begin_inset Quotes eld
\end_inset

AGLITTER
\begin_inset Quotes erd
\end_inset

) [Guardian]
\end_layout

\begin_layout Standard
Although the correct parse is generated ([SILVER] + [PAPER IN THE STREET]),
 some natural language analysis would be required to derive the fact that
 
\begin_inset Quotes eld
\end_inset

PAPER IN THE STREET
\begin_inset Quotes erd
\end_inset

 = 
\begin_inset Quotes eld
\end_inset

litter
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection*
PLAYWRIGHT AT HOME HAVING CAUGHT DISEASE (5) (="IBSEN
\begin_inset Quotes erd
\end_inset

) [Everyman]
\end_layout

\begin_layout Standard
This clue requires two pieces of category knowledge, firstly that Ibsen
 is a member of the set of playwrights (and not a synonym for playwright),
 and that BSE is a member of the set of diseases 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection*
HE SCORED HARLEM WINDS (6)   (= 
\begin_inset Quotes eld
\end_inset

MAHLER
\begin_inset Quotes erd
\end_inset

) [Guardian]
\end_layout

\begin_layout Standard
Not only is knowledge of composer Gustav Mahler required, but also a cryptic
 understanding that `HE SCORED' can refer to a member of the set of male
 composers.
 Note that this is structurally different from the examples above: while
 (1) was a more oblique version of a synonym (litter 
\series bold
is
\series default
 paper on the street), and (2) is membership of the set of of playwrights,
 we must now consider the set of people who fit the description 
\begin_inset Quotes eld
\end_inset

he scored
\begin_inset Quotes erd
\end_inset

, which may include composers, sportsmen, and maybe even engravers.
 
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection*
WHERE AND HOW A SUPERHERO MIGHT LABEL HIS FAUCET (4) (= 
\begin_inset Quotes eld
\end_inset

BATH
\begin_inset Quotes erd
\end_inset

) [Guardian]
\end_layout

\begin_layout Standard
This clue requires not just specialist knowledge, but also natural language
 parsing of the sentence of a whole.
 The answer can be derived from the concept that the superhero Batman would
 append bat- onto the names of objects (batmobile, etc.), and that a hot
 tap (or faucet) might be labeled H, so his faucet might be labelled BAT-H.
 
\end_layout

\begin_layout Standard
Along with that, the definition bears reference to the clue as a whole,
 and may be properly expanded as: 
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout --Separator--
\begin_inset Flex Code
status open

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

definition
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

wordplay
\end_layout

\end_inset


\end_layout

\begin_layout Address
\begin_inset Formula $\noindent\mathtt{\overbrace{where\, a\, superhero\, might\, label\, his\, faucet}\:\mathit{and}\,\overbrace{how\, a\, superhero\, might\, label\, his\, faucet}}$
\end_inset

   
\end_layout

\begin_layout Address
This clue represents the upper level of challenge for a computer based solver,
 being unique structure, self referential, using very specialist knowledge
 and oblique humour.
 
\end_layout

\begin_layout Chapter
Optimizations
\end_layout

\begin_layout Section
Algebraic + computational simplifications 
\end_layout

\begin_layout Subsection
Pruning out equivalent trees (Canonization) 
\end_layout

\begin_layout Subsubsection
Motivation
\end_layout

\begin_layout Standard
One large factor in the rapid proliferation of number of parses produced
 from a given clue is in the our binary tree representation of concatenation.
 While keeping them in a similar representation to the rest of the expression
 nodes in our naive solution kept their representation in a similar form
 to the rest of the nodes, the fact that no indicator is required to generate
 a concatenation node means that any expression of two ore more words can
 generate them.
 
\end_layout

\begin_layout Standard
The number of trees with 
\begin_inset Formula $n$
\end_inset

 leaves is given by the (
\begin_inset Formula $n-1$
\end_inset

)
\begin_inset script superscript

\begin_layout Plain Layout
th
\end_layout

\end_inset

 Catalan number
\begin_inset Foot
status open

\begin_layout Plain Layout
Catalan numbers are given by the formula 
\begin_inset Formula $C_{n}=\frac{1}{n+1}{2n \choose n}=\frac{(2n)!}{(n+1)!\, n!}=\prod\limits _{k=2}^{n}\frac{n+k}{k}\qquad\mbox{ for }n\ge0.$
\end_inset


\end_layout

\end_inset

, so ignoring any other type of expression (anagram, etc.), for a clue of
 length 
\begin_inset Formula $n$
\end_inset

 we have 
\begin_inset Formula $C_{n-1}$
\end_inset

 trees created with each of the clue words taken as a synonym node.
 This number grows rapidly as the clue length increases, and yields an increasin
gly large number of parses.
 
\end_layout

\begin_layout Standard
Due to the associativity of concatenation, each of these parses evaluates
 to an identical output:
\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.CONCAT [.CONCAT A B ] [.C ]]
\end_layout

\end_inset

 
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "8col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
and
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.CONCAT [.A ] [.CONCAT B C ] ]
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
both yield the output 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
ABC
\end_layout

\end_inset

.
 This means that much of our outputted parses are identical and therefore
 redundant.
\end_layout

\begin_layout Standard
One strategy to deal with this would be to perform canonization on the trees,
 and prune all concatenation trees which don't conform to our decided `ideal
 tree'.
 For example, we could choose to create a right-handed binary tree, wherein
 trees such as:
\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.CONCAT [.CONCAT A B ] [.CONCAT C D ]]
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
would become
\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.CONCAT [.A ] [.CONCAT [.B ] [.CONCAT C D ]]]
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The problem with this solution is that we need to look ahead while parsing:
 the above parse only is acceptable if the parse of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
A
\end_layout

\end_inset

 also doesn't produce a concatenation – this means we can't parse recursively
 as before.
 
\end_layout

\begin_layout Subsubsection
Implementation
\end_layout

\begin_layout Standard
Instead of representing our concatenated elements in a binary tree, we could
 instead represent them as a n-ary tree:
\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.CONCAT [ A B C D ] ]
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
however, Haskell's data constructors do not allow an arbitrary number of
 elements in a datatype.
 We can, however, represent the items in the concatenation as a single list
 of parse trees, known as a `forest'.
\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.CONCAT {[A B C D]} ]
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can instead define a new version of our Concatenation Nodes which, instead
 of describing a binary tree by storing the data as two parsetrees:
\end_layout

\begin_layout LyX-Code
data ParseTree = ConcatNode ParseTree ParseTree | [...]
\end_layout

\begin_layout Standard
structured as:
\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.CONCAT [.CONCAT A B ] [.CONCAT C D ]]
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code
 (as well as 4 other equivalent trees)
\end_layout

\end_deeper
\begin_layout Standard
where the data is stored as a list of trees –
\end_layout

\begin_layout LyX-Code
data ParseTree = ConcatNode ParseForest | [...]
\end_layout

\begin_layout LyX-Code
type ParseForest = [ParseTree]
\end_layout

\begin_layout Verse
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
We define a new version of parseConcatNodes to reflect the new structure.
 This time, instead of considering all the ways to partition the wordplay
 of the clue into two parse, and subsequently combining each of the different
 parses of both of them, this time we need to consider all the ways to partition
 the string (which  
\end_layout

\begin_layout LyX-Code
parseConcatNodes' :: String -> [ParseTree] 
\end_layout

\begin_layout LyX-Code
parseConcatNodes' xs n = let parts = partitions xs 
\end_layout

\begin_layout LyX-Code
       in [ConcatNode ys | part <- parts
\end_layout

\begin_layout LyX-Code
                 , (length part) > 1
\end_layout

\begin_layout LyX-Code
                 , ys <- [sequence .
 map parseClue $ part]  ] 
\end_layout

\begin_layout Standard
the Prelude function 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
sequence
\end_layout

\end_inset

, which has the type 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
sequence :: Monad m => [m a] -> m [a]
\end_layout

\end_inset

, which when applied to a list of lists will provide all lists comprising
 of an element from each sublist:
\end_layout

\begin_layout LyX-Code
sequence [ [1,2,3], [40,50], [666,777,888] ] =
\end_layout

\begin_layout LyX-Code
  [ [1,40,666],[1,40,777],[1,40,888],[1,50,666],[1,50,777] ...]
\end_layout

\begin_layout Subsubsection
Avoiding Nesting
\end_layout

\begin_layout Standard
Unfortunately, this solution alone will not prevent us from creating a forest
 of parse trees that itself contains a concatenation node:
\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.CONCAT [.{[A CONCATENATE D]} {B C} ]]
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Verse
leading to a even more parse trees than before!
\end_layout

\begin_layout Standard
In order to prevent our new concatenation nodes nesting like this, we need
 to define a version of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
parseClue
\end_layout

\end_inset

 which doesn't generate concatenation nodes:
\end_layout

\begin_layout LyX-Code
parseClueNoConcat :: String -> [ParseTree] 
\end_layout

\begin_layout LyX-Code
parseClueNoConcat ys = let len = length .
 words $ ys in
\end_layout

\begin_layout LyX-Code
  [SynonymNode ys]    
\end_layout

\begin_layout LyX-Code

\strikeout on
  ++ (if len > 1 then parseConcatNodes ys else [] )  
\end_layout

\begin_layout LyX-Code
  ++ (if len > 1 then parseAnagramNodes ys else [] )   
\end_layout

\begin_layout LyX-Code
  ++ (if len > 1 then parseHiddenWordNodes ys else [])   
\end_layout

\begin_layout LyX-Code
  ++ (if len > 2 then parseInsertionNodes ys else [])   
\end_layout

\begin_layout LyX-Code
  ++ (if len > 2 then parseSubtractionNodes ys else [])   
\end_layout

\begin_layout LyX-Code
  ++ (if len > 1 then parseReversalNodes ys else [])  
\end_layout

\begin_layout LyX-Code
  ++ (if len > 1 then parseFirstLetterNodes ys else [])   
\end_layout

\begin_layout LyX-Code
  ++ (if len > 1 then parseLastLetterNodes ys else [])   
\end_layout

\begin_layout LyX-Code
  ++ (if len > 1 then parsePartialNodes ys else [])
\end_layout

\begin_layout Standard
and re-define our original 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
parseClue
\end_layout

\end_inset

 as
\end_layout

\begin_layout LyX-Code
parseClue :: String -> [ParseTree] 
\end_layout

\begin_layout LyX-Code
parseClue (Def def ys n) = let len = length .
 words $ ys in
\end_layout

\begin_layout LyX-Code
  parseClueNoConcat ys  
\end_layout

\begin_layout LyX-Code
  ++ (if len > 1 then parseConcatNodes ys else [] ) 
\end_layout

\begin_layout Subsubsection
Improvement Analysis
\end_layout

\begin_layout Standard
By cleaning up the redundancy in our different parses, we can improve our
 parsing function from exponential growth against clue length, to a low
 quadratic growth, as can be seen in 
\series bold
Figure 5
\series default
.
 As each parse may have thousands of solutions, this should represent a
 significant improvement in the number of outputs, and so the solve time,
 of each clue.
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename results/parses-original-canonical logarithmic.pdf
	width 100col%

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.CONCAT [.{[A CONCATENATE D]} {B C} ]]
\end_layout

\end_inset

 
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Average number of parses before and after canonization by clue length, averaged
 over 710 clues, on a logarithmic scale
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Heuristics from Human Solvers
\end_layout

\begin_layout Standard
We can take cues for further improvements to our solving process by considering
 the heuristics that a human solver uses to navigate the huge state space
 and find the correct solution without having to enumerate all possible
 solutions.
\end_layout

\begin_layout Subsection
Filter parses by output length
\end_layout

\begin_layout Subsubsection
Motivation
\end_layout

\begin_layout Standard
Here we seek to mimic the following thought processes of a human solver:
\end_layout

\begin_layout Quotation

\shape italic
\begin_inset Quotes eld
\end_inset

This can't be an anagram of that word, as that'd only make 6 letters, and
 the clue is 9
\begin_inset Quotes erd
\end_inset


\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_deeper
\begin_layout Quotation

\shape italic
\begin_inset Quotes eld
\end_inset

We can't have an insertion here, as we've already got 5 letters, and so
 if we add another 5 then it's too long
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
These are constraints on the parses that we can generate based on an understandi
ng of the maximum and minimum number of letters than a given reading of
 a clue could produce.
 In the first example, a clue such as
\end_layout

\begin_layout LyX-Code
Report coarse players (9)
\end_layout

\begin_layout Standard
could identify `coarse' as a possible anagram indicator, and yield a parse
 such as
\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.{ANAGRAM (=coarse)} "report" ]
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This, however, can never yield a solution that is 9 letters long, so a human
 solver, and so our improved computer solver, will not consider it for further
 evaluation.
\end_layout

\begin_layout Standard
In the second example, we see that we may also need to consider the parse
 recursively to calculate the total length parameters: 
\end_layout

\begin_layout LyX-Code
Punch’s dog in play about bishop (4) 
\end_layout

\begin_layout Standard
can be parsed to
\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.{INSERTION (=in)} [.SYNONYMN {"punch's dog"} ] [.{REVERSAL (=about)}
 "play" ] ]
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since the reversal of play (`yalp') is already 4 letters long, we can see
 that which ever word we choose to signify 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
punch's dog
\end_layout

\end_inset

 will increase the length of the evaluated solution over the prescribed
 solution length of 4.
\end_layout

\begin_layout Subsubsection

\series bold
Implementation
\end_layout

\begin_layout Standard
We can recursively evaluate a parse to determine its maximum and minimum
 lengths, to check that the maximum is at least as big as the desired output
 length, and the minimum is at least as small.
\end_layout

\begin_layout Standard
We define the functions 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
minLength
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
maxLength
\end_layout

\end_inset

 :
\end_layout

\begin_layout LyX-Code
minLength :: ParseTree -> Int 
\end_layout

\begin_layout LyX-Code
minLength (ConcatNode trees) = (sum .
 map minLength) trees 
\end_layout

\begin_layout LyX-Code
minLength (SynonymNode string) = let x = 
\end_layout

\begin_layout LyX-Code
             minimum ( map length (string : syn string)) in x
\end_layout

\begin_layout LyX-Code
minLength (AnagramNode ind strings) = (length .
 concat) strings 
\end_layout

\begin_layout LyX-Code
minLength (HiddenWordNode ind strings) = 2 
\end_layout

\begin_layout LyX-Code
minLength (InsertionNode ind tree1 tree2) = (minLength tree1) 
\end_layout

\begin_layout LyX-Code
                                           + (minLength tree2) 
\end_layout

\begin_layout LyX-Code
minLength (SubtractionNode ind tree1 tree2) = min (
\end_layout

\begin_layout LyX-Code
                          (minLength tree2) -          (maxLength tree1))
 1
\end_layout

\begin_layout LyX-Code
-- and definitions for other clue types
\end_layout

\begin_layout Standard
Some clue types can be defined directly from their inputs – both the maxium
 and minium length of an anagram node is the length of the input string
 – while an insertion node needs to be defined based on the maxium and minimum
 of the two subtrees.
\end_layout

\begin_layout Standard
Notable is that here we see some `contextual bleed' from evaluation across
 into the parsing, as we consider the semantics of what the thesaurus could
 yield for a synonym node in determining its minimum length.
\end_layout

\begin_layout Standard
It's also worth noting that sometimes we need to make a judgement: what
 is the minimum that a Hidden Word could yield? 
\end_layout

\begin_layout Standard
From these definitions, and similar ones for maxLength, we can check a parse
 for validity.
 
\end_layout

\begin_layout LyX-Code
validParseLength :: Parse -> Bool 
\end_layout

\begin_layout LyX-Code
validParseLength (Def d clue n) = (minLength clue <= n) 
\end_layout

\begin_layout LyX-Code
                                 && (maxLength clue >= n) 
\end_layout

\begin_layout Standard
and so redefine parse as 
\end_layout

\begin_layout LyX-Code
parse = filter validParseLength .
 concatMap parseClue 
\end_layout

\begin_layout Subsubsection
Analysis
\end_layout

\begin_layout Standard

\series bold
Figure 6
\series default
 shows the effect on number of parses generated following the addition of
 the parse length constraints.
 
\end_layout

\begin_layout Standard
This filtering constraint now means that many clues now yield 0 parses.
 Some of these are clues that could never be correctly parsed, while some
 are clues which we can generate correct parses, but do not have the thesaurus
 and synonym data to solve the clue.
 
\end_layout

\begin_layout Standard
This transformation is, though, safe – any parse that previously would have
 generated the correct answer will not be filtered out.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename results/length-constraints.pdf
	width 95text%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Average number of parses before and after canonization by clue length, averaged
 over 710 clues, on a logarithmic scale
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Taking Advantage of Lazy Evaluation
\end_layout

\begin_layout Subsubsection
Motivation
\end_layout

\begin_layout Standard
Although we are now generating far fewer parses, we still have some solveable
 clues generating hundreds of parses.
 This means that for these clues we will have to perform on average 
\begin_inset Formula $n/2$
\end_inset

 evaluations to find the right clue, assuming it will be randomly distributed
 down the list – lazy evaluation means that our use of the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
head
\end_layout

\end_inset

 with 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
filter
\end_layout

\end_inset

 will yield the first result computed from the head of the list toward the
 tail.
 
\end_layout

\begin_layout Standard
We could take further advantage of the intuition that some parses are more
 likely, given the input words.
 For instance in the clue 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Lowest point in ruptured drain (5)
\end_layout

\end_inset

, we see the angram indicator `ruptured' next to a 5 letter word:
\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.{ANAGRAM (=RUPTURED)} drain ]
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
with the definition 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
lowest point
\end_layout

\end_inset

, intuitively feels more likely than 
\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.CONCATENATION [.CONCATENATION [.SYN lowest ] [.SYN point ] ] [.CONCATENATION
 [.SYN in ] [.SYN ruptured ]  ] ]
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
cluing the definition 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
drain
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
More formally, we're looking for a heuristic which weights toward consuming
 words into indicators for more `interesting' clue types: in that clues
 using expressions more varied than synonym and concatenation are considered
 better clues, and so are more likely than not if they are an available
 parse.
 
\end_layout

\begin_layout Standard
Furthermore, these expressions consume more of the string in indicators
 than other types (reversal nodes consume one word from the clue as its
 indicator, while synonyms and concatenation both don't consume any indicators)
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
Diagram to show this
\end_layout

\end_inset

 and are less likely to produce nested parse trees (both anagrams and hidden
 word nodes treat their input as a pure string to be transformed, and so
 do not generate any nested parse trees).
 This means that clues featuring these types tend to be less complex.
 
\end_layout

\begin_layout Standard
Both of these factors make them good candidates to evaluate sooner than
 other options.
\end_layout

\begin_layout Subsubsection
Implementation
\end_layout

\begin_layout Standard
We define a method 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
cost
\end_layout

\end_inset

 which gives a weighting to a given ParseTree
\end_layout

\begin_layout LyX-Code
cost :: ParseTree -> Int 
\end_layout

\begin_layout LyX-Code
cost (ConcatNode trees) = CONCAT_CONST * (length trees) + sum (map cost
 trees) 
\end_layout

\begin_layout LyX-Code
cost (AnagramNode ind strings) = ANAGRAM_CONST 
\end_layout

\begin_layout LyX-Code
cost (HiddenWordNode ind strings) = HIDDEN_WORD_CONST
\end_layout

\begin_layout LyX-Code
cost (InsertionNode ind tree1 tree2) = INSERTION_CONST + cost tree1 + cost
 tree2 
\end_layout

\begin_layout LyX-Code
cost (SubtractionNode ind tree1 tree2) = SUBTRACTION_CONST + cost tree1
 + cost tree2 
\end_layout

\begin_layout LyX-Code
cost (ReversalNode ind tree) = REVERSAL_CONST + cost tree 
\end_layout

\begin_layout LyX-Code
cost (SynonymNode string) = SYNONYM_CONST * length (words string) 
\end_layout

\begin_layout LyX-Code
cost (FirstLetterNode ind strings) = FIRST_LETTER__CONST 
\end_layout

\begin_layout LyX-Code
cost (LastLetterNode ind strings) = LAST_LETTER_CONST
\end_layout

\begin_layout LyX-Code
cost (PartialNode ind tree) = PARTIAL_CONST + cost tree
\end_layout

\begin_layout Standard
we can then define
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
costParse :: Parse -> Int
\end_layout

\begin_layout LyX-Code
costParse (DefNode s tree n) = cost tree * (lengthPenalty s) 
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

lengthPenalty :: String -> Int
\end_layout

\begin_layout LyX-Code
lengthPenalty ws = (length (words ws)) + LENGTH_CONST 
\end_layout

\begin_layout Standard
which can then be integrated into our definition of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
parse
\end_layout

\end_inset

:
\end_layout

\begin_layout LyX-Code
parse = sortBy costParse .
 filter validParseLength .
 concatMap parseClue
\end_layout

\begin_layout Standard
The optimal values for each constant could be determined by taking a large
 set of clues with known parses, and then performing argument optimisation
 through hill climbing, or similar technique.
\end_layout

\begin_layout Standard
Experimentally, I determined that the following constants provided a satisfactor
y improvement to the parse order.
\end_layout

\begin_layout LyX-Code
CONCAT_CONST = 2
\end_layout

\begin_layout LyX-Code
ANAGRAM_CONST = 1
\end_layout

\begin_layout LyX-Code
HIDDEN_WORD_CONST = 4
\end_layout

\begin_layout LyX-Code
INSERTION_CONST = 4
\end_layout

\begin_layout LyX-Code
SUBTRACTION_CONST = 3
\end_layout

\begin_layout LyX-Code
REVERSAL_CONST = 2
\end_layout

\begin_layout LyX-Code
SYNONYM_CONST = 7
\end_layout

\begin_layout LyX-Code
FIRST_LETTER_CONST = 2
\end_layout

\begin_layout LyX-Code
LAST_LETTER_CONST = 2
\end_layout

\begin_layout LyX-Code
PARTIAL_CONST = 2
\end_layout

\begin_layout Standard
In my weighting, Synonym Nodes have a high weighting against consuming long
 lists of words – this is to prevent them from being low scoring (as they
 consume large portions the clue) while being unlikely to yield the correct
 answer.
 
\end_layout

\begin_layout Subsubsection
Analysis
\end_layout

\begin_layout Standard
The weighting above means that the correct parse had the highest score in
 70% of the clues that the system can solve, as opposed to approximately
 10% when not sorted by weight.
 In cases where the clue can not be solved, the order of the parses is irrelevan
t.
 
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
Generate much more data for this and display in a nice way.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Placeholder
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Determining a correct weighting 
\end_layout

\begin_layout Standard
While the current weighting given has been developed though trial and error
 to be reasonably successful, a more structured approach to detemining the
 correct weighting could generate even better results.
 Using a large dataset of clues and the correct parses, hill climbing or
 statistical analysis of clue types could produce optimal numbers.
\end_layout

\begin_layout Subsection
Constrain length while evaluating 
\end_layout

\begin_layout Subsubsection
Motivation
\end_layout

\begin_layout Standard
While evaluating a parse tree of a given clue, we expect the overall length
 of the generated solution to be equal to the length specified in the clue.
 Furthermore, while evaluating different sub-trees of a given parse tree
 – either different branches of a concatenation list, or the two constituent
 parts of an insertion or subtraction experession – the solutions generated
 from one influence and limit what can be generated from the others.
 
\end_layout

\begin_layout Standard
For example, in the clue 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Story about bishop and food (5)
\end_layout

\end_inset

, if we are evaluating the parse 
\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.{INSERTION (=about)} [.SYN "story" ] [.SYN "bishop" ] ]
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
then the partial evaluation of the left hand branch to one of its possible
 solutions
\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.{INSERTION (=about)} [."TALE" ] [.SYN "bishop" ] ]
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
means that as the subsequent evalaution of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
SYN 
\begin_inset Quotes eld
\end_inset

bishop
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 should only yield solutions that are one-letter one, in order to stay within
 the constraint of a five-letter solution.
 If we can successfully apply this constraint, then we can limit the subsequent
 evaluations of this partial parse tree to one or two, rather than the order
 of 100.
\end_layout

\begin_layout Subsubsection

\series bold
Implementation
\end_layout

\begin_layout Standard
In the example above, we see the length constraints preventing overflow
 - that is, a maximum length which the generated solution should not exceed.
 We also need to constrain against `underflow', wherein the evaluation fails
 to yield enough letters to fit the solution.
 Constraining both maximum and minimum length will have the effect of forcing
 the generated solution length to be equal to the prescribed length.
\end_layout

\begin_layout Standard
We can therefore define a datatype to carry both of these constraints.
 
\end_layout

\begin_layout LyX-Code
newtype Constraints = Constraints MaxLength MinLength
\end_layout

\begin_layout Standard
In some cases, we will not be able to prescribe a definite maximum length
 for a clue: in the case of a subtraction expression of parse trees A and
 B, where the evaluation of tree A will have the evaluation of B removed
 from it to yield the final solution, the length of clue A will exceed the
 overall solution length by an amount only limited by the length of B.
 
\end_layout

\begin_layout Standard
We also, then define 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
MaxLength
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
MinLength
\end_layout

\end_inset

 as new datatypes.
 
\end_layout

\begin_layout LyX-Code
data MaxLength = Max Int | NoMax 
\end_layout

\begin_layout LyX-Code
data MinLength = Min Int | NoMin
\end_layout

\begin_layout Standard
Although we could use the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Maybe
\end_layout

\end_inset

 monad here, by defining our own datatype we can subsequently take advantage
 of Haskell's type class system later on to allow us to treat these, and
 other constraints, in a similar way.
 
\end_layout

\begin_layout Standard
We define 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
is_lte_max
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
is_gte_min
\end_layout

\end_inset

 to account for both the case when we have a defined constraint (e.g.
 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Max 3
\end_layout

\end_inset

), as well as when we have no constraint (e.g.
 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
NoMax
\end_layout

\end_inset

):
\end_layout

\begin_layout LyX-Code
is_lte_max :: MaxLength -> Int -> Bool
\end_layout

\begin_layout LyX-Code
is_lte_max (Max mx) n = n <= mx 
\end_layout

\begin_layout LyX-Code
is_lte_max NoMax n = True
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
is_gte_min :: MinLength -> Int -> Bool
\end_layout

\begin_layout LyX-Code
is_gte_min (Min mn) n = n >= mn 
\end_layout

\begin_layout LyX-Code
is_gte_min NoMin n = True
\end_layout

\begin_layout Standard
We can define a typeclass 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Constraint
\end_layout

\end_inset

 which gives us the ability to define the method for checking if a given
 string fits a constraint of either type.
\end_layout

\begin_layout LyX-Code
class Constraint c where 
\end_layout

\begin_layout LyX-Code
    fits :: c -> String -> Bool 
\end_layout

\begin_layout LyX-Code
instance Constraint MaxLength where 
\end_layout

\begin_layout LyX-Code
    fits mx s = is_lte_max mx (length s) 
\end_layout

\begin_layout LyX-Code
instance Constraint MinLength where 
\end_layout

\begin_layout LyX-Code
    fits mn s = is_gte_min mn (length s) 
\end_layout

\begin_layout Standard
which subsequently allows us to write a function to check if a given output
 string fits the each of the constraints:
\end_layout

\begin_layout LyX-Code
fits_max (Constraints mx mn) x = fits mx x
\end_layout

\begin_layout LyX-Code
fits_min (Constraints mx mn) x = fits mn x
\end_layout

\begin_layout Standard
and so can define an overall function for checking a string against all
 our constraints:
\end_layout

\begin_layout LyX-Code
fits_constraints c x = (fits_max c x) && (fits_min c x)
\end_layout

\begin_layout Standard
This allows us to start to redefine our definitions of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
eval_tree
\end_layout

\end_inset

, with the new type signature
\end_layout

\begin_layout LyX-Code
eval_tree :: ParseTree -> Constraints -> [String]
\end_layout

\begin_layout Standard
For simple synonym nodes, we can apply the check in a straightforward manner,
 as there are no subtrees to evaluate.
\end_layout

\begin_layout LyX-Code
eval_tree (SynonymNode xs) c = filter (fits_constraints c) (synonyms xs)
\end_layout

\begin_layout Standard
For anagram nodes, redefining in the same way, as 
\end_layout

\begin_layout LyX-Code
eval_tree (AnagramNode xs) c = filter (fits_constraints c) (anagrams xs)
\end_layout

\begin_layout Standard
would still require the costly computation of all our anagrams.
 Instead, we can use our min and max criteria on the input string to check
 if it's worth evaluating at all: 
\end_layout

\begin_layout LyX-Code
eval_tree (AnagramNode xs) c = if ((fits_max c xs) && (fits_min c xs))
\end_layout

\begin_layout LyX-Code
                               then filter (fits_constraints c) (anagrams
 xs)
\end_layout

\begin_layout LyX-Code
                               else []
\end_layout

\begin_layout Standard
While here the first line could be replaced with if 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
fits_constraints c xs
\end_layout

\end_inset

, we avoid this, as it's only due to the fact that angrams preserve length
 that the max and min constraints are applicable to the initial string as
 a filter for its output.
 Once we add other constraints later which aren't preserved over the anagram
 operation (anything involving letter order!) then we would violate this
 condition.
\end_layout

\begin_layout Standard
Often, we will want to change the constraints on the evaluation of the subtrees
 in a parse tree.
 For example in the clue 
\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.{PARTIAL} [.SYN "word" ] ]
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
we can't easily define a maximim length for our evaluation of synonym, as
 an unspecified amount of letters will be removed when we apply the Partial
 expression.
 We need to define function which modifies our constraints to remove the
 maximum length constraint, as well as a similar one for the minimum:
\end_layout

\begin_layout LyX-Code
noMax :: EvalConstraints -> EvalConstraints 
\end_layout

\begin_layout LyX-Code
noMax (Constraints p mx mn) = (Constraints p NoMax mn)
\end_layout

\begin_layout Standard
and
\end_layout

\begin_layout LyX-Code
noMin :: EvalConstraints -> EvalConstraints 
\end_layout

\begin_layout LyX-Code
noMin (Constraints p mx mn) = (Constraints p mx NoMin)
\end_layout

\begin_layout Standard
we can then define the eval_tree function for partial nodes as
\end_layout

\begin_layout LyX-Code
eval_tree (PartialNode ind y) c =  
\end_layout

\begin_layout LyX-Code
      filter (fits_constraints c) .
 concatMap partials $ eval_tree y (noMax c) 
\end_layout

\begin_layout Standard
For our concatentation nodes, the requirement is slightly more complex,
 as the constraints imposed on the parse of any one tree depend on the each
 possible evaluation of all the other possible trees in the forest.
 In a simple example: From a clue such as 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Outspoken shocking court (6)
\end_layout

\end_inset

, we take a parse such as
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setbox
\backslash
partbox=
\backslash
hbox{
\backslash
Tree [.SYN shocking ] } 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setbox
\backslash
partboxx=
\backslash
hbox{
\backslash
Tree [.SYN court ] } 
\end_layout

\end_inset


\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
qroof{
\backslash
usebox{
\backslash
partbox}  
\backslash
usebox{
\backslash
partboxx} }.CONCAT  
\end_layout

\end_inset

 
\end_layout

\end_inset


\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
and look at the evaluation criteria at each stage.
 The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
ConcatNode
\end_layout

\end_inset

 will be given the constraints 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Max 6 Min 6
\end_layout

\end_inset

.
 We will the start to parse the subtrees in the forest of the concatenation.
 Parsing left-to-right, we parse the left 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
SynonymNode
\end_layout

\end_inset

 subtree with the constraints 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Max 6 NoMin
\end_layout

\end_inset

.
 Two of the partial evalautions we might come to are:
\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\align center
1.
 
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
qroof{ "dire"  
\backslash
usebox{
\backslash
partboxx} }.CONCAT  
\end_layout

\end_inset

 
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "5col%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Plain Layout
and
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\align center
2.
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
qroof{ "lousy"  
\backslash
usebox{
\backslash
partboxx} }.CONCAT  
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can see here that in partial evalaution 1, the constraints that we need
 to apply to the right 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
SynonymNode
\end_layout

\end_inset

 will be 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Max 2 NoMin
\end_layout

\end_inset

, whereas in 2, it will be 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Max 1 NoMin
\end_layout

\end_inset

.
 This means we will need to evaluate each subtree in the forest of a concatenati
on expression with different constraints depending on the outcomes of the
 evaluation of previous evaluations.
 
\end_layout

\begin_layout Standard
We define a function to allow us to decrease the maximum length constraint
 as we go further down the list (and also similar for increasing, and for
 changing the min constraint).
\end_layout

\begin_layout LyX-Code
decreaseMax :: Int -> EvalConstraints -> EvalConstraints 
\end_layout

\begin_layout LyX-Code
decreaseMax n (Constraints (Max mx) mn) = Constraints  (Max (mx - n)) mn
 
\end_layout

\begin_layout LyX-Code
decreaseMax n (Constraints NoMax mn) = Constraints NoMax mn 
\end_layout

\begin_layout Standard
and a function which updates the constraints given a string we've just generated
:
\end_layout

\begin_layout LyX-Code
add_partial :: String -> EvalConstraints -> EvalConstraints 
\end_layout

\begin_layout LyX-Code
add_partial x c = decreaseMax (length x) c 
\end_layout

\begin_layout Standard
So in this example, applying the function 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
add_partial 
\begin_inset Quotes eld
\end_inset

dire
\begin_inset Quotes erd
\end_inset

 (Constraints Max 6 NoMin)
\end_layout

\end_inset

 will give the correct constraints for the second tree's evaluation: 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Max 2 NoMin
\end_layout

\end_inset

.
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
We can then define a function 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
eval_trees
\end_layout

\end_inset

 that will handle passing the right constraints down the list of 
\end_layout

\begin_layout LyX-Code
eval_trees :: [ParseTree] -> EvalConstraints -> [String] 
\end_layout

\begin_layout LyX-Code
eval_trees (x:[]) c = eval_tree x  c 
\end_layout

\begin_layout LyX-Code
eval_trees (x:xs) c = 
\end_layout

\begin_layout LyX-Code
       let starts = [start | start <- eval_tree x (noMin c)]  
\end_layout

\begin_layout LyX-Code
         -- Generate options for the first in our list
\end_layout

\begin_layout LyX-Code
       in concatMap f $ starts 
\end_layout

\begin_layout LyX-Code
         -- For each option, evaluate the rest with updated constraints
\end_layout

\begin_layout LyX-Code
       where f start = map (
\backslash
x -> start ++ x) (eval_trees xs (apply_partial start c))
\end_layout

\begin_layout LyX-Code
         -- Append from each possible evaluation, after updating constraints
 
\end_layout

\begin_layout Standard
overall 
\end_layout

\begin_layout Standard
Now we can re-define 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
eval_tree
\end_layout

\end_inset

 for the concatenation expression
\end_layout

\begin_layout LyX-Code
eval_tree (ConcatNode xs) c = eval_trees xs c
\end_layout

\begin_layout Standard
Finall, we can re-define our definition of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
eval
\end_layout

\end_inset

 to set the initial top-level maximum and the minimum constraints to the
 length of the required answer
\end_layout

\begin_layout LyX-Code
eval (Def d pt len) = [Answer x (Def d pt len) |
\end_layout

\begin_layout LyX-Code
                           x <- evalTree pt (Constraints Max len Min len)]
\end_layout

\begin_layout Subsubsection
Analysis
\end_layout

\begin_layout Standard
This optimisation radically improves the number of solutions evaluated for
 a given parse.
 
\series bold
Figure 8
\series default
 shows how the exponential growth before constraints is brought under control,
 and the overall number of parses greatly reduced with the average number
 of solutions for a 5-word clue being reduced from 4.6 million to just 16
 thousand.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename results/length-constraints.pdf
	width 95col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Number of solutions evaluated before and after implementing length-based
 constraints 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Constrain against known letters 
\end_layout

\begin_layout Subsubsection
Motivation
\end_layout

\begin_layout Standard
Here again we turn to behaviour of a human solver:
\end_layout

\begin_layout Quotation

\shape italic
\begin_inset Quotes eld
\end_inset

It can't be that, as there are no words that start with 
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Quotation
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
Insert a good example here, that we can use later on too
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Currently, we are performing a large amount of wasteful evaluations on subtrees
 that will never be ouputted as a valid answer, as we already know that
 given the the preceding letters that we've already evaluated, there are
 no possible words in our wordlist that we can make.
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
Add some illustrated examples
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Implementation
\end_layout

\begin_layout Standard
We want to add another contraint while solving, which is a check that what
 we are evaluating can be a prefix of a valid word.
 We add a function to calculate all proper prefixes of a given word:
\end_layout

\begin_layout LyX-Code
prefixes :: String -> [String]
\end_layout

\begin_layout LyX-Code
prefixes = rprefixes .
 reverse 
\end_layout

\begin_layout LyX-Code
rprefixes (x:xs) = [reverse xs++[x]] ++ rprefixes xs 
\end_layout

\begin_layout LyX-Code
rprefixes [] = []
\end_layout

\begin_layout Standard
and some functions to precomputer a set of prefixes
\begin_inset Foot
status open

\begin_layout Plain Layout
For a very large wordlist it may be preferable to create a prefix tree.
 For my dataset, however, I found the extra memory footprint to be an acceptable
 tradeoff for constant-time lookups
\end_layout

\end_inset

 for our dataset and check if a given word is a prefix
\end_layout

\begin_layout LyX-Code
is_prefix x = member x wl_prefixes 
\end_layout

\begin_layout LyX-Code
wl_prefixes = fold add_prefixes empty wordlist
\end_layout

\begin_layout LyX-Code
add_prefixes word set = union (fromList (prefixes word)) set 
\end_layout

\begin_layout Standard
We want to add prefix constraints alongside the current maximum and minimum
 length constraints, to take advantage of the current mechanisms we have
 set up to propegate the prefixes down the nested parse trees.
 We update the type definitions and create similar functions for our new
 constraint:
\end_layout

\begin_layout LyX-Code
data EvalConstraints = Constraints PrefixConstraint MaxLength MinLength
\end_layout

\begin_layout LyX-Code
data PrefixConstraint = Prefix String | NoPref 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
is_prefix_with (Prefix p) x = is_prefix (p ++ x) 
\end_layout

\begin_layout LyX-Code
is_prefix_with NoPrefix x = True
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
class Constraint c where     
\end_layout

\begin_layout LyX-Code
[...]
\end_layout

\begin_layout LyX-Code
instance Constraint PrefixConstraint where 	
\end_layout

\begin_layout LyX-Code
fits p s = is_prefix_with p s
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
extend_prefix_by x (Constraints (Prefix p) mx mn) = (Constraints (Prefix
 (p++x)) mx mn) 
\end_layout

\begin_layout LyX-Code
extend_prefix_by x c = c
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
add_partial x  = decreaseMax (length x) .
 extend_prefix_by x 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
noPrefix (Constraints p mx mn) = (Conare straints NoPrefix mx mn)
\end_layout

\begin_layout Standard
It is worth noting that 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
NoPref
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Prefix 
\begin_inset Quotes eld
\end_inset


\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 are not equivalent: the former means that there are no prefix-based constraints
 on the evaluation, while the second means that the evaluation is taking
 place a the start of a solution, and so all sets of letters generated by
 that parse will need to be valid prefixes of a word in the wordlist.
\end_layout

\begin_layout Standard
Some clue types will not require any changes for this to work:
\end_layout

\begin_layout LyX-Code
eval_tree (SynonymNode x) c = filter (fits_constraints c) (syn x ++ [x])
\end_layout

\begin_layout Standard
while others which have subparts which generate letters which are subtracted
 from or used out of sequence will need to ignore the prefix constraint
 for the evaluation of their subtrees.
\end_layout

\begin_layout Standard
For example, in the following illustrated partial evaluation of a clue:
\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.CONCAT "pre" [.{INSERTION} SUBTREE-A SUBTREE-B ] ]
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can see that the prefix constraint on the insertion node is that anything
 it generates must be able to be added to the prefix 
\begin_inset Quotes eld
\end_inset

pre
\begin_inset Quotes erd
\end_inset

.
 It's not, however, possible to pass that constraint down to its sub trees.
 We do not yet know where subtree B, which is going to be inserted into
 subtree A, is going to go, so we know nothing about the letters immediately
 preceding it.
 Furthermore, as we don't know where into A it is going to be inserted,
 we can't apply the prefix constraints to A either, as the only letter of
 A we know for sure will be sequentially following 
\begin_inset Quotes eld
\end_inset

pre
\begin_inset Quotes erd
\end_inset

 will be its first one.
\end_layout

\begin_layout Standard
In this case, we need to use the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
noPrefix
\end_layout

\end_inset

 function to allow any prefix for these parts
\end_layout

\begin_layout LyX-Code
eval_tree (InsertionNode ind x y) c = 
\end_layout

\begin_layout LyX-Code
           filter (fits c) $
\end_layout

\begin_layout LyX-Code
           concat[insertInto x' y' | 
\end_layout

\begin_layout LyX-Code
                    y' <- eval_tree y (noMin .
 noPrefix $ c), 
\end_layout

\begin_layout LyX-Code
                    x' <- eval_tree x (add_partial y' .
 noPrefix $ c)] 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Subsubsection
Analysis
\end_layout

\begin_layout Standard

\series bold
Figure 9
\series default
 shows that in terms of number of solutions evaluated, this represents a
 modest improvement, although less dramatic than previous optimisations.
\end_layout

\begin_layout Standard
The real improvements can instead be seen in 
\series bold
Figure 10
\series default
, where we see that while the optimisation has minimal or even negative
 effect for the quicker clues, it shows a significant decrease in the toal
 solving time of the long-running clues.
 As these long-running clues account for approximately 90% of total evaluation
 time
\begin_inset Foot
status open

\begin_layout Plain Layout
Estimated based on a sample of long running clues allowed to run until terminati
on
\end_layout

\end_inset

 if uncapped, this represents an improvement of around 68% on average running
 times.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename results/prefix-constraints.pdf
	width 95col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Number of solutions evaluated after implementing prefix-based constraints
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Original Solve Time
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Average Change in Solve Time
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0–1 seconds
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+33%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1–5 seconds
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-32%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5–10 seconds
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-22%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10–20 seconds
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-48%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20-60 seconds
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-43%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
60-120 seconds
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-67%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
120 seconds+
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-76%
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Effect of parse constraints on solve time 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Chapter
Analysis
\end_layout

\begin_layout Section
Analysis of Single clue solving against test suite 
\end_layout

\begin_layout Subsection
Test Suite
\end_layout

\begin_layout Standard
The test suit comprises of 7,000 clues extracted from the Observer's Everyman
 series.
 These were chosen for being published in a major British newspaper, and
 for being both scrapable from publically open websites (as The Times' and
 Telegraph's are not) and for being Ximenean
\begin_inset Foot
status open

\begin_layout Plain Layout
Macnutt, as Ximenes, was the first setter for the Everyman in the 1940s.
\end_layout

\end_inset

 (as the Guardian's are not).
 
\end_layout

\begin_layout Standard
The clues selected have been limited to those with single-word answers,
 as few of the multi-word answers appear in wordlists.
 Clues with numbers are not included, as they are often the self-referential
 type (see the section on 
\series bold
Meta-reference
\series default
), and thus cannot be solved in isolation.
\end_layout

\begin_layout Subsection
Wordlist and Knowledgebase data
\end_layout

\begin_layout Standard
The data from the solver comes in two parts: a wordlist and a knowledgebase.
 The wordlist comes from the Moby Project
\begin_inset Foot
status open

\begin_layout Plain Layout
http://icon.shef.ac.uk/Moby/
\end_layout

\end_inset

, and comprises of 610,000 different words and phrases.
 The wordlist determines which words can be generated by the solver.
 The knowedge-base consists of the thesaurus from the Moby project which
 provides synonyms, along with limited data on hyponyms and hypernyms
\begin_inset Foot
status open

\begin_layout Plain Layout
Where hyponyms of 
\begin_inset Quotes eld
\end_inset

bird
\begin_inset Quotes erd
\end_inset

 include 
\begin_inset Quotes eld
\end_inset

crow
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

eagle
\begin_inset Quotes erd
\end_inset

, and hypernyms are 
\begin_inset Quotes eld
\end_inset

animal
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

organism
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

.
 These entries have all been collectively augmented by including verb conjugatio
ns and plurals, as performed by NodeBox's linguistics library for Python
\begin_inset Foot
status open

\begin_layout Plain Layout
http://nodebox.net/code/index.php/Linguistics#verb_conjugation
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The resulting dictionaries are compiled into Haskell Data maps, and compiled
 into binary files to be loaded into RAM at runtime.
\end_layout

\begin_layout Subsection
Solvable Clues
\end_layout

\begin_layout Standard
An analysis on the accuracy of the program's solving capabilities can be
 found in 
\series bold
Figure 11
\series default
.
 The details of each individual status are discussed here.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename results/clue-solve-split.pdf
	width 99col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Breakdown of solvability of clues from the testing suite
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Solveable and verifiable
\end_layout

\begin_layout Standard
If a clue is solvable and verifiable it means that the program succesfully
 generated the correct split of definition and wordplay, generated a correct
 parse tree, correctly evaluated the parse tree to the correct answer, and
 verified the answer using the definition.
 One example of a clue solved this way is
\end_layout

\begin_layout LyX-Code
Rule amended to include married primate (5)
\end_layout

\begin_layout Standard
for which the program generates the parse tree
\end_layout

\begin_layout LyX-Code
(Def "primate" (InsertionNode (IIndicator ["to","include"]) 
\end_layout

\begin_layout LyX-Code
                       (SynonymNode "married") 
\end_layout

\begin_layout LyX-Code
                       (AnagramNode (AIndicator ["amended"]) ["rule"]))
\end_layout

\begin_layout Standard
along with the correct answer
\end_layout

\begin_layout LyX-Code
Answer "lemur" 
\end_layout

\begin_layout Standard
which it can successfully match to the definition of primate based on our
 thesaurus/knowledgebase.
\end_layout

\begin_layout Standard
Fifteen percent of previously unseen clues from the test suite could be
 solved in this way – this figure was derived by running the program over
 the entire testing suite and filtering for where the generated answer could
 be verified against the definition, and where it matched the correct answer
 from the test suite.
\end_layout

\begin_layout Standard
Along with clues which could not be accurately verified, there were also
 some `false positive' answers, that is, clues where there was a solution
 which could be verified but did not match the correct answer as expected
 by the test suite.
 One example 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Teases Spurs (4)
\end_layout

\end_inset

, for which the correct answer is 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
RIBS
\end_layout

\end_inset

.
 My knowledgebase did not contain the equivalence between `ribs' and `spurs',
 but the program generated the answer 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
SETS
\end_layout

\end_inset

, drawing off the senses `sets' = `besets' = `teases' and `spurs' = `starts'
 = `sets'.
 
\end_layout

\begin_layout Standard
While this, and others like it, are not the correct answers from the original
 context of the clue, and would likely not fit in the completed grid, in
 isolation they are valid answers for the clues themselves - although sometimes
 `low quality' answers based on more spurious semantic links, as in the
 example given.
 Around 2% of the clues in the Solveable and Verifiable category were false
 positives.
\end_layout

\begin_layout Subsubsection
Solveable but not verifiable
\end_layout

\begin_layout Standard
Clues in this category succesfully generated the correct split of definition
 and wordplay, generated a correct parse tree, correctly evaluated the parse
 tree to the correct answer, however didn't manage to match that answer
 to the definition.
 Sometimes, multiple answers could be produced, most of which would not
 be valid answers for this clue.
 
\end_layout

\begin_layout Standard
For example the clue
\end_layout

\begin_layout LyX-Code
A new member returned with a backer (5)
\end_layout

\begin_layout Standard
will correctly return the solution 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
ANGEL
\end_layout

\end_inset

, but cannot match it to 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
A BACKER
\end_layout

\end_inset

.
 It also generates other answers, such as
\end_layout

\begin_layout LyX-Code
Answer "inarm" 
\end_layout

\begin_layout LyX-Code
(Def "returned with a backer" 
\end_layout

\begin_layout LyX-Code
      (ConcatNode [SynonymNode "a",SynonymNode "new",SynonymNode "member"])
\end_layout

\begin_layout Standard
which, to the system, are equally valid readings as the correct one, as
 there is no semantic link available for either.
\end_layout

\begin_layout Standard
Clues in this category will often take orders of magnitude more time to
 solve, as all solutions need to be generated.
 Because of the extensive time taken to solve, the figure of 13% was generated
 by sampling over 700 clues from the testing suite.
\end_layout

\begin_layout Subsection
Unsolvable
\end_layout

\begin_layout Standard
Continuing to refer to 
\series bold
Figure 10
\series default
, categories from here onwards were not solvable by the program.
 In order to analyse these clues, a random sample of 100 clues that were
 not correctly solved and verified were drawn from the testing suite, and
 examined by hand to:
\end_layout

\begin_layout Enumerate
determine the correct parse 
\end_layout

\begin_layout Enumerate
categorize factors missing from the data/program in order to solve them.
 
\end_layout

\begin_layout Standard
These were then assigned one or more of the following labels: 
\end_layout

\begin_layout Itemize
Answer not in wordlist
\end_layout

\begin_layout Itemize
Expression indicator not found
\end_layout

\begin_layout Itemize
Unparsable structure
\end_layout

\begin_layout Itemize
New/unknown clue type
\end_layout

\begin_layout Itemize
Knowledge not in dataset
\end_layout

\begin_layout Itemize
Synonym required in clue not in dataset
\end_layout

\begin_layout Itemize
No dictionary match between Answer and Definition
\end_layout

\begin_layout Standard
The frequency of these labels in this group can be seen in 
\series bold
Figure 12.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename results/most common clue issues.pdf
	width 95col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Reasons for unsolvable clues
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Solvable with easily collectable data
\end_layout

\begin_layout Standard
Clues in this category are those which recieved only the labels `No dictionary
 match between Answer and Definition', `Answer not in wordlist', `Synonym
 required in clue not in dataset', `Expression Indicator Not Found'.
 I have deemed these to fall into the category of `easily collectable data'
 – that is, data that is finite or has a clear scope and could be consumed
 by the system in the same way as other data.
\end_layout

\begin_layout Paragraph
Answer not in wordlist
\end_layout

\begin_layout Standard
In order only to output useful words and to limit useless evaluations, a
 wordlist is used in addition to the knowledgebase.
 If a word is not in the wordlist, then it cannot be given as a solution.
 Thus, in the clue
\end_layout

\begin_layout LyX-Code
Girl feeding pygmy rattlesnake (4)
\end_layout

\begin_layout Standard
the answer 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Myra
\end_layout

\end_inset

 is not given, even though the program can generate the right parse tree.
 
\end_layout

\begin_layout Standard
These issues could be resolved by collecting a larger wordlist including,
 for example, proper names, places.
 One possible source for this information would be Wikipedia article subjects,
 along with commerically available listings.
 
\end_layout

\begin_layout Paragraph
Synonym required in clue not in dataset 
\end_layout

\begin_layout Standard
These are clues that generate a valid parse but cannot be solved as the
 equivalence information is not there to perform the correct evaluation.
 For example 
\end_layout

\begin_layout LyX-Code
Exaggerate concerning party (6)
\end_layout

\begin_layout Standard
should yield 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
OVERDO
\end_layout

\end_inset

, but the current thesaurus data lacks the link `over' = `concerning'.
 Clues in this category lack only the sort of synonym-based information
 one might find in a very thorough thesaurus.
 Any more complex data such as membership (Handel is a composer, etc.) is
 covered under the category of 
\series bold
Knowledge not in database
\series default
.
\end_layout

\begin_layout Standard
Clues in this category could be remedied by providing a more thorough and
 permissive thesaurus than the one integrated into the knowledgebase currently.
\end_layout

\begin_layout Paragraph
No dictionary match between Answer and Definition
\end_layout

\begin_layout Standard
This has the same properties as the examples above.
\end_layout

\begin_layout Paragraph
Expression Indicator Not Found
\end_layout

\begin_layout Standard
In this case, the clue contains an expression type that we can generate
 parse trees for with an indicator word that we haven't defined.
 For example in
\end_layout

\begin_layout LyX-Code
Last in science failing to pass (6)    (= ELAPSE)
\end_layout

\begin_layout Standard
the system fails to parse 
\begin_inset Quotes eld
\end_inset

last in science
\begin_inset Quotes erd
\end_inset

 as a final letter expression with the indicator 
\begin_inset Quotes eld
\end_inset

last in
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Most of these are common indicators which occur frequently by convention
 in crosswords, and could be collected manually, and extracted from crossword
 solving guides to give a much greater coverage than the system currently
 offers.
 
\end_layout

\begin_layout Subsubsection
Require more complex data
\end_layout

\begin_layout Standard
These clues require data outside of the `thesaurus' level equivalence, or
 may require specialist techniques to parse and retieve the data.
 For example in the clue
\end_layout

\begin_layout LyX-Code
More than one spoke with one on wireless endlessly (5)
\end_layout

\begin_layout Standard
we are required to parse the phrase 
\begin_inset Quotes eld
\end_inset

more than one spoke
\begin_inset Quotes erd
\end_inset

 into the plural of radius, being RADII.
 
\end_layout

\begin_layout Standard
In the clue
\end_layout

\begin_layout LyX-Code
Noah's son rose heading off in a muddle (9) (= SHEMOZZLE)
\end_layout

\begin_layout Standard
we are required to know that Shem is one of the three sons of Noah, and
 to be able to accurately parse `Noah's son' to refer to one member of the
 set of sons of Noah.
\end_layout

\begin_layout Standard
These sorts of questions would require more than simply providing extra
 thesaurus definitions.
 To return the name `Shem', the setter could easily have clued 
\begin_inset Quotes eld
\end_inset

Son of Noah
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

Noah's offspring
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

Noah begat him
\begin_inset Quotes erd
\end_inset

, or many other variants which would be unfeasible to have pre-computed
 in a thesaurus.
 To solve these clues, we are required to have extensive information, and
 to be able to query that information in a loose format.
 The 
\series bold
Future Work
\series default
 section details how this might be achieved using logical programming.
\end_layout

\begin_layout Subsubsection
Program modifications needed
\end_layout

\begin_layout Standard
Some clues contain operators that are not part of the current program.
 For example the clue
\end_layout

\begin_layout LyX-Code
Emphasised editor is under pressure (8) (= STRESSED)
\end_layout

\begin_layout Standard
features an operator which concatenates one part of a clue after another
 (the indicator being `is under', as this clue was originally a `down' clue).
 An `append after' operator is not programmed into the current system.
 Again, the 
\series bold
Future Work
\series default
 section details how the program could be extended to include new clue types
\end_layout

\begin_layout Subsubsection
Not solvable with current approach
\end_layout

\begin_layout Standard
Some clues are simply not within the bounds of what currently could be solved
 with our current approach to parsing and solving.
 The clue 
\end_layout

\begin_layout LyX-Code
Bloodhound in film (6)
\end_layout

\begin_layout Standard
is a cryptic definition for the word SLEUTH, asking us to think laterally
 to conjure an word fitting the description in some oblique manner.
 The challenges posed by clues such as these are significantly different
 to the general problem this project is solving, and would require significant
 innovation in computer intelligence to solve.
 
\end_layout

\begin_layout Subsection
Performance 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename results/solving-time.pdf
	width 99col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Percentage of clues solvable before cutoff
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Conclusion
\end_layout

\begin_layout Standard
While functional programming 
\end_layout

\begin_layout Standard

\series bold
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout

\series bold
Write this:
\end_layout

\begin_layout Plain Layout
It's good to think about these.
 The takeaway messages.
\end_layout

\begin_layout Plain Layout
Naive solvers are essentially intractable.
 Clue length constraints are key to making the problem tractable.
 Around 70% of the clues considered could be solved simply by having the
 right data.
 The last n% are much harder and likely to be left for the human to solve.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Chapter
Future Work
\end_layout

\begin_layout Section
Adding new clue types
\end_layout

\begin_layout Standard
Analysis of unsolvable clues has highlighted types of clues expressions
 not found in the literature.
 These include:
\end_layout

\begin_layout Paragraph
Language Clues
\end_layout

\begin_layout Standard
Phrases like 
\begin_inset Quotes eld
\end_inset

man in Paris
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

Spanish article
\begin_inset Quotes erd
\end_inset

 indicate a translation (in these examples, to 
\begin_inset Quotes eld
\end_inset

homme
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

el
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

un
\begin_inset Quotes erd
\end_inset

 etc.), phrases like 
\begin_inset Quotes eld
\end_inset

after
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

placed behind
\begin_inset Quotes erd
\end_inset

 indicate a change in the order of a concatenation.
 
\end_layout

\begin_layout Standard
In order to simplify the process of adding additional clue types, we can
 observe that each clue type is characterized by a specific pattern in just
 a few key functions: 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
eval_tree, parseClue, cost, maxLength, minLength
\end_layout

\end_inset

.
 We could modularise our system and make it more easily extensible for new
 clue types by encoding this information in a 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
NodeType
\end_layout

\end_inset

 record:
\end_layout

\begin_layout LyX-Code
data NodeType = NodeType { 
\end_layout

\begin_layout LyX-Code
    eval_tree  :: ParseTree -> [String], 
\end_layout

\begin_layout LyX-Code
    parseClue  :: String -> [ParseTree],
\end_layout

\begin_layout LyX-Code
    maxLength  :: ParseTree -> Int,   
\end_layout

\begin_layout LyX-Code
    minLength  :: ParseTree -> Int, 
\end_layout

\begin_layout LyX-Code
    cost       :: ParseTree -> Int, 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
 }
\end_layout

\begin_layout Standard
We could then store a list of pre-defined NodeTypes as 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
nodetypes
\end_layout

\end_inset

 and parse by mapping over the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
parseTree
\end_layout

\end_inset

 function of each for our target string.
 Our definition of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
evaluate
\end_layout

\end_inset

would also then change to call the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
eval_tree
\end_layout

\end_inset

 function of the node directly.
 
\end_layout

\begin_layout Section
Improving current solving capabilities
\end_layout

\begin_layout Subsection
Improving the knowledgebase
\end_layout

\begin_layout Standard
Currently, large numbers of clues are unsolvable due to missing information.
 Most of the current information comes from thesaurus definitions, and is
 stored in a directed graph structure, in a similar way to a thesaurus:
 each word is connected to all the words it is in some way equivalent to.
 This is a clumsy representation of the real world: we lose the information
 that `dog' related to `poodle' in a different way from the way it relates
 to `mammal' (hyponymically, and hypernymically, respectively).
 Furthermore, if we want to augment the knowledgebase with further information
 about dogs (dogs = man's best friend), then we'd also have to add that
 fact to all hyponyms (`poodle', `labrador', and so on).
 If we wanted to add a propagatable fact to something much higher level,
 such as `mammal' or `solid object', then the number of new `facts' or graph
 connections we'd have to add would grow quickly indeed! Very quickly, our
 database would become very difficult to manipulate, or hold in RAM for
 quick access.
 
\end_layout

\begin_layout Subsubsection
Using Propositional Logic
\end_layout

\begin_layout Standard
We would like to be able to infer a fact, such as the fact that Mahler was,
 as a composer, someone who scored
\begin_inset Foot
status open

\begin_layout Plain Layout
In order to solve the sorts of clues we ruled out in Chapter II: HE SCORED
 HARLEM WINDS (6) (= 
\begin_inset Quotes eld
\end_inset

MAHLER
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Instead of doing this through direct entry into the database, we could use
 a prepositional logic language like 
\noun on
prolog
\noun default
 to represent this as a minimal sets of facts.
\end_layout

\begin_layout LyX-Code
composer(malher).
\end_layout

\begin_layout LyX-Code
composer(brahms).
\end_layout

\begin_layout LyX-Code
[...]
\end_layout

\begin_layout LyX-Code
scored(X) :- conductor(X).
\end_layout

\begin_layout LyX-Code
scored(pele).
\end_layout

\begin_layout LyX-Code
[...]
\end_layout

\begin_layout Standard
Thus, we could take `HE SCORED', and generate a query to our logical database
 asking 
\begin_inset Quotes eld
\end_inset

for which X did X score
\begin_inset Quotes erd
\end_inset

 (or as an SWI prompt: 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
?- scored(X).
\end_layout

\end_inset

), which would return the set of everyone that can be infered by the knowledgeba
se to match the criteria.
\end_layout

\begin_layout Standard
With the use of knowledgebases come many additional avenues for complexity:
 How can we transform a natural-language phrase into an answerable question
 in an appropriate logic language? How can we represent sufficient amount
 of inference rules for the database to be useful while still dealing with
 exceptions (e.g.
 penguins are birds, birds can fly, but penguins can't fly).
 The field is, itself, a large and complex one, but may warrant further
 investigation.
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Subsection
Generating solutions with missing data 
\end_layout

\begin_layout Standard
In cases in which we don't have suitable data to generate any solutions
 at all, it would be useful to generate tentative solutions with assumptions
 stated around the missing data.
 So in the clue 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Ban Lear: Mad! (7)
\end_layout

\end_inset

, with correct solution 
\begin_inset Quotes eld
\end_inset

barking
\begin_inset Quotes erd
\end_inset

, the program could return
\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.{CONCAT} [.SYN "ban" ] [.{"lear" = KING???} ] ]
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Verse
The issue is that the number of words we could generate with the ability
 to generate any combination of letters from any subpart is infaesibly large,
 especially for longer and more complex clues.
\end_layout

\begin_layout Subsubsection
Solving Forwards and Backwards 
\end_layout

\begin_layout Standard
One solution to this is in re-working the entire method by which we solve
 the clues.
 Our solver is currently works `forwards': based on the available clue text,
 we attempt to parse into a tree which, when evaluated, generates all possible
 outputs.
 Another option would be to work in reverse: from the selected definition,
 evaluate all words that are synonyms, and parse to match the letters in
 the solution with parts of the clue text.
 In some ways, this could be though of generating possible clues for a given
 solution, and matching them to the given clue.
\end_layout

\begin_layout Standard
This method could reasonably work for a simple subset of expressions, such
 as limiting to, for example: synonyms and concatenation.
 
\series bold

\begin_inset Note Greyedout
status open

\begin_layout Plain Layout

\series bold
Update ref
\end_layout

\end_inset

Figure 13
\series default
 shows a possible output, illustrating how such a search could take place.
\end_layout

\begin_layout LyX-Code
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout LyX-Code
Select definition: Mad
\end_layout

\begin_layout LyX-Code
Select synonym of definition: BARKING
\end_layout

\begin_layout LyX-Code
Split definition into parts: BAR  KING
\end_layout

\begin_layout LyX-Code
Match clue text to first part: BAR = ban - confirmed in thesaurus
\end_layout

\begin_layout LyX-Code
Match clue text to second part: KING = lear - not confirmed
\end_layout

\begin_layout LyX-Code
Possible solution found.
 Searching for more...
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
Split definition into parts: BARK ING
\end_layout

\begin_layout LyX-Code
[...]
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Example output from a possible `reverse' solver
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Parallelization 
\end_layout

\begin_layout Standard
The nature of how we form multiple abstract syntax trees and then parse
 them individually means that there is potentially considerable computational
 gain to be had through parallelization.
 Any evaluation of a ParseTree which subsequently evaluated sub-parse trees
 resembles a Master/Worker arrangement.
 In the cases were we do not need to wait for the results of one tree to
 evaluate the second, we can parallelize immediately.
 In cases where we impose constraints on the second based on the first,
 it may still be worthwhile to evaluate at worker level without the constraints,
 and then have the master filter based on the constraints.
\end_layout

\begin_layout Standard
This process could be futher improved with memoization: storing the results
 of previous sub-tree calculations could eliminate wasted parsing where
 two different parses of a clue share sub-parts.
\end_layout

\begin_layout Section
Whole Grid Solving
\end_layout

\begin_layout Subsection
Intersections and known letters 
\end_layout

\begin_layout Standard
An obvious extension of this system is to allow it to solve whole grids
 instead of just individual clues.
 While more computation is needed to solve a whole grid of around 30 clues,
 this is evened out by the fact that we have more information about the
 clues in the form of their intersections.
 
\end_layout

\begin_layout Standard
This extra information would form another filterint criteria: this would
 need to be applied to the `weak' solve: the list of all possible solutions
 that could be produced by the clue, including those that our thesaurus
 is unable to match as a synonym of the definition.
 For the `strong' solve, this extra data is redundant – if we haven't been
 able to generate any answers, then further filtering is useless.
 
\end_layout

\begin_layout Standard
A solution to filter answers that fit a known pattern of intersected letters
 (in the form 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
CRO??W???D
\end_layout

\end_inset

) is implemented below
\end_layout

\begin_layout LyX-Code
known_letter_fits :: String -> String -> Bool
\end_layout

\begin_layout LyX-Code
known_letter_fits [] [] = True
\end_layout

\begin_layout LyX-Code
known_letter_fits [] (y:ys) = False
\end_layout

\begin_layout LyX-Code
known_letter_fits (x:xs) [] = False
\end_layout

\begin_layout LyX-Code
known_letter_fits (x:xs) (y:ys) = if x=='?' then (known_letter_fits xs ys)
 else 
\end_layout

\begin_layout LyX-Code
                        if x==y then (known_letter_fits xs ys) else
\end_layout

\begin_layout LyX-Code
                          False
\end_layout

\begin_layout LyX-Code
answerFits ::  String -> Answer -> Bool
\end_layout

\begin_layout LyX-Code
answerFits fitstring (Answer x y)  = known_letter_fits fitstring x
\end_layout

\begin_layout LyX-Code
stripFits :: String -> [Answer] -> [Answer]
\end_layout

\begin_layout LyX-Code
stripFits s = filter (answerFits s) 
\end_layout

\begin_layout Subsection
Solving strategy
\end_layout

\begin_layout Standard
The prolem we have now is one of recursion.
 As crossword grids are usually heavily intersected, we will have to deal
 with cycles in our intersection graph: for example in 
\series bold
Figure 8
\series default
, we can see many such cycles.
 One example: 1-across intersects 2-down, which intersects 10-across, which
 intersects 3-down, which intersects 1-across again! We therefore have to
 find a strategy to deal with this.
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
Write about the current work on this
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "65col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename crossword-grid.pdf
	width 100col%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
A crossword grid
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
All permutations
\end_layout

\begin_layout Standard
We can take the combination of all the possible words generated by each
 clue, and 
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
once I know more about the number of possible words generated, finish this
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If we had a list of possible answers generated for each clue, and a function
 to check an arrangement of answers against a grid of intersections, then
 we could form a solution like so:
\end_layout

\begin_layout LyX-Code
check_valid_intersections grid .
 sequence $ answerList 
\end_layout

\begin_layout Standard
This, however, means we cannot take advantage of lazy evaluation, and that
 we need to compute all possible solutions of every clue.
 This means our remaining clues for which solving time is still very high
 (>10 minutes) could potentially mean that no answers at all are yielded,
 as the system waits for all possible answers to be generated before matching.
 
\end_layout

\begin_layout Subsubsection
Lazy evaluation and backtracking
\end_layout

\begin_layout Standard
In a similar way to the how we evaluated the items in the parse forest left-to-r
ight checking combinations and culling where no available solution fitted
 the constraints, so we could decide upon an arbitrary order to evaluate
 the clues, and then backtrack where necessary – for example, 
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
Show a partial grid with possible solutions
\end_layout

\end_inset

lock-in the answer to clue 1, and try to solve clue 4 given those constraints.
 If one or more fit, then try each of them recursively in turn; if none
 fit, then backtrack and try a new solution to clue 1.
 
\end_layout

\begin_layout Standard
This method could work well, as it only requires us to compute the solutions
 necessary when we need them.
 Although we may end up with re-computation of answers, we could avoid this
 through memoization of the solution to each clue given a set of constraints.
 This could be futher improved by observing that the solutions to a clue
 constrained by a set of known letters (?????A) are a superset of those
 given tighter constraints (????MA), so further computation may be required.
 
\end_layout

\begin_layout Standard
Issues with this approach are that the stack may grow very large, as with
 around 30 clues, even a small branching factor can lead to a long parse
 path.
 This solution would also need extra work to deal with unsolvable clues:
 one for which no possible answers can be generated, or where only an incorrect
 answer is generated for a given clue.
\end_layout

\begin_layout Subsubsection
Functional iteration
\end_layout

\begin_layout Standard
Another solution which may solve some of the issues of the others is by
 generating a finite set of solutions for each of the clues, generating
 a likelihood for each of the generated solutions, and then using the intersecti
on letters of those solutions to help weight future iterations of the solve.
 
\series bold
Table 1
\series default
 illustrates how this may occur.
\end_layout

\begin_layout Standard
This solution could work correctly in the case that no solutions can be
 found for one clue: those missing would simply bear no weight on their
 intersections.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\series bold
Iteration 1: 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="9">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
U
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
G
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
M
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
R
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset script superscript

\begin_layout Plain Layout
1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset script superscript

\begin_layout Plain Layout
2
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
G
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
U
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
U
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{black}
\end_layout

\end_inset


\begin_inset script superscript

\begin_layout Plain Layout
2
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
U
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset script superscript

\begin_layout Plain Layout
3
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
H
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
O
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
U
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
J
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
O
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
G
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset space \qquad{}
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1a.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1d.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2d.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3a.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CAT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RUB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
T
\series default
IE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HOP
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PUP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MEW
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GUN
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RUN
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PIG
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PUR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AXE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
JOG
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
This is the initial solution, taking no information from other clues - solutions
 pictured closer to the grid represent more probable solutions.
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Plain Layout

\series bold
Iteration 2:
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="9">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
U
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
G
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
M
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset script superscript

\begin_layout Plain Layout
1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset script superscript

\begin_layout Plain Layout
2
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
G
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
U
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
U
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{black}
\end_layout

\end_inset


\begin_inset script superscript

\begin_layout Plain Layout
2
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
U
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
R
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset script superscript

\begin_layout Plain Layout
3
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
R
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
U
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
N
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
H
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
O
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
J
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
O
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
G
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset space \qquad{}
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1a.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1d.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2d.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3a.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CA
\series bold
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
P
\series default
UR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
T
\series default
IE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
R
\series default
UN
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PUP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RUB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GUN
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
JOG
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PIG
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MEW
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AXE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HOP
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
Based on the available solution in 1a., PUR has become more likely than RUB,
 as 1a.
 has no solutions begining with `R.' HOP has changed to RUN for similar reasons.
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace bigskip
\end_inset


\series bold
Iteration 3:
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="9">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
U
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
G
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
M
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset script superscript

\begin_layout Plain Layout
1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset script superscript

\begin_layout Plain Layout
2
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
G
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
U
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
U
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{black}
\end_layout

\end_inset


\begin_inset script superscript

\begin_layout Plain Layout
2
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
U
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
R
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset script superscript

\begin_layout Plain Layout
3
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
R
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
U
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
N
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
H
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
O
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
J
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
O
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
G
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset space \qquad{}
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1a.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1d.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2d.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3a.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
P
\series default
IG
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
P
\series default
UR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
T
\series default
IE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
R
\series default
UN
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PUP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RUB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GUN
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
JOG
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CAT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MEW
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AXE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HOP
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
Based on the change to 1d., 1a.'s probabilities also change – the influence
 on its intial letter as P is now greater than the influence from its final
 letter.
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Plain Layout

\series bold
Iteration 4:
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="9">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
U
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
G
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
M
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset script superscript

\begin_layout Plain Layout
1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset script superscript

\begin_layout Plain Layout
2
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
G
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
U
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
U
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{black}
\end_layout

\end_inset


\begin_inset script superscript

\begin_layout Plain Layout
2
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
U
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
R
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset script superscript

\begin_layout Plain Layout
3
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
N
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
R
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
U
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
N
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
H
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
O
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
J
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
O
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
G
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset space \qquad{}
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1a.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1d.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2d.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3a.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
P
\series default
I
\series bold
G
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
P
\series default
U
\series bold
R
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
G
\series default
U
\series bold
N
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
R
\series default
U
\series bold
N
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PUP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RUB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TIE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
JOG
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CAT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MEW
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AXE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HOP
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset

l
\end_layout

\begin_layout Plain Layout
Now, 2d.
 updates based on the changes to the other cells to reach a stable solution.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Example of how iterative function application might converge to solution
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Chapter
Appendix 
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
Put here the categorisation of the bad clues table, and maybe some sample
 program outputs
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
References
\end_layout

\begin_layout Standard
Visser, E.
 (August 1997).
 Scannerless Generalized-LR Parsing (in English).
 The Netherlands: University of Amsterdam.
 Retrieved 22 November 2012.
\end_layout

\begin_layout Paragraph
R.G.G.
 Cattel
\end_layout

\begin_layout Standard
Maximal Munch
\end_layout

\begin_layout Paragraph
Lewis, Forbes D.
 
\end_layout

\begin_layout Standard
Recursive Descent Parsing
\end_layout

\begin_layout Standard
http://www.cs.engr.uky.edu/~lewis/essays/compilers/rec-des.html
\end_layout

\begin_layout Paragraph
Frost, Richard; Launchbury, John (1989).
 "Constructing natural language interpreters in a lazy functional language".
 The Computer Journal.
 Special edition on Lazy Functional Programming 32 (2): 108–121.
 doi:10.1093/comjnl/32.2.108.
\end_layout

\begin_layout Paragraph
Cryptic crossword clues: generating text with a hidden meaning
\end_layout

\begin_layout Standard
David Hardcastle - 2007 
\end_layout

\begin_layout Paragraph
The Generation of Cryptic Crossword Clues
\end_layout

\begin_layout Standard
G.
 W.
 Smith, and J.
 B.
 H.
 du Boulay - 1986 
\end_layout

\begin_layout Paragraph
Crossword Compiler-Compilation 
\end_layout

\begin_layout Standard
H.
 Berghel and C.
 Yi.
 - 1989 
\end_layout

\begin_layout Paragraph
PROVERB: The Probabilistic Cruciverbalist 
\end_layout

\begin_layout Standard
Greg A.
 Keim, Noam M.
 Shazeer, Michael L.
 Littman - 1999 
\end_layout

\begin_layout Paragraph
Computer Assisted Analysis of Cryptic Crosswords 
\end_layout

\begin_layout Standard
P.W.Williams and D.
 Woodhead - 1977 
\end_layout

\begin_layout Paragraph
LACROSS language, formal definitions - good building material
\end_layout

\begin_layout Standard
Cryptic crossword clue interpreter M Hart, RH Davis - 1992
\end_layout

\begin_layout Paragraph
Microcomputer compilation and solution of crosswords 
\end_layout

\begin_layout Standard
RH Davis and E J Juvshol - 1985 
\end_layout

\begin_layout Paragraph
Give Us A Clue
\end_layout

\begin_layout Standard
Jon G.
 Hall and Lucia Rapanotti - 2010 
\end_layout

\begin_layout Paragraph
A Statistical Study of Failures In Solving Crossword Puzzles
\end_layout

\begin_layout Standard
Naranana, 2010 
\end_layout

\begin_layout Paragraph
Expertise in cryptic crossword performance
\end_layout

\begin_layout Standard
Kathryn Friedlander, Philip Fine, 2009 
\end_layout

\begin_layout Standard
Cattell, R.
 G.
 G.
 “Formalization and Automatic Derivation of Code Generators”.
 PhD thesis, 1978.
 Carnegie Mellon University, Pittsburgh, Pennsylvania, USA 
\end_layout

\end_body
\end_document
