#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{qtree}
\newsavebox{\partbox} % Declare this only once, in your preamble!
\newsavebox{\partboxx} % Declare this only once, in your preamble!
\usepackage{pdflscape}
\AtBeginDocument{%
\let\ref\autoref
}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\begin_local_layout
InsetLayout Flex:Code
    LyxType               charstyle
    LabelString           code
    LatexType             command
    LatexName             code
    Font
      Family              Typewriter
    EndFont
    Preamble
    \newcommand{\code}[1]{\texttt{#1}}
    EndPreamble
    InToc                 true
    HTMLTag               code
End
\end_local_layout
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing other 1.2
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 3cm
\topmargin 3cm
\rightmargin 3cm
\bottommargin 3cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Date
Imperial College London
\begin_inset Newline newline
\end_inset

Department of Computing
\end_layout

\begin_layout Title

\series bold
\size huge
Solving Cryptic Crosswords through Functional Programming
\end_layout

\begin_layout Author
by
\end_layout

\begin_layout Author
Michael Skelly
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Date
April 25
\begin_inset script superscript

\begin_layout Plain Layout
th
\end_layout

\end_inset

 2014
\end_layout

\begin_layout Date
Submitted in partial fulfilment of the requirements for the MSc Degree in
 Advanced Computing of Imperial College London 
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Abstract
This is the abstract
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset

Acknowledgements
\begin_inset Newpage pagebreak
\end_inset


\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Part
Introduction to the Problem / Field
\end_layout

\begin_layout Standard
Cryptic crosswords are widely thought to be at the crossroads of various
 fields of human endevour considered to be right at the limit of current
 AI and Machine Learning – featuring wit, slang, allusion, linguistic ambiguity
 and generally deliberate trickery.
 Along with this, they possess other characteristics that make brute force
 solutions difficult, if not impossible: the state space of all possible
 crossword grids is of the order 10
\begin_inset script superscript

\begin_layout Plain Layout
90
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
citation needed
\end_layout

\end_inset

(compare, for example, an upper bound on all the possible chess positions
 is merely 10
\begin_inset script superscript

\begin_layout Plain Layout
50
\end_layout

\end_inset

), and worse still, a solution to a grid is non-trivial to verify (as the
 verification process is the nearly same as solving the clue!)
\end_layout

\begin_layout Standard
Nevertheless, techniques from combinatorics, compiler design and NLP and
 AI all have applications that can help elucidate and simplify the problem,
 along with heuristics adapted from both human solvers and analytical optimisati
ons that can help improve the time taken to arrive at at the correct solution.
\end_layout

\begin_layout Standard
I have developed a system which can solve a significat percentage of cryptic
 crossword clues 
\begin_inset Note Note
status open

\begin_layout Plain Layout
More here, obvs
\end_layout

\end_inset


\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

A provost at Eton once boasted that he could do The Times crossword in the
 time it took his morning egg to boil, prompting one wag to suggest that
 the school may have been Eton but the egg almost certainly wasn't.
\begin_inset Quotes erd
\end_inset

 
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

 –
\begin_inset space ~
\end_inset

Citation Needed
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Part
Literature Review
\end_layout

\begin_layout Section
Summary of Cryptic Crosswords 
\end_layout

\begin_layout Subsection
Definition of Cryptic Crosswords 
\end_layout

\begin_layout Standard
To start, let us provide some basic definitions around crosswords and their
 taxonomies.
 
\end_layout

\begin_layout Standard
A crossword is a puzzle, usually published in newspapers or magazines.
 They consist of a grid of squares, often 15 x 15.
 Some of the squares are white (i.e.
 blank) and some are blacked out.
 Any contiguous run of more than one white square, either down (vertically)
 or across (horizontally, left to right) is a space for a word, to be written.
 These are marked by numbers in the initial square (the top-leftmost one),
 and referred to by those numbers, and the direction (e.g.
 '5 down', '8 across').
 Horizontal runs can overlap vertical runs, and at the points at which they
 do, each of the two words, when written in, must have the same letter in
 that square.
 Along with the grid are a set of clues, which the solver can use to determine
 which word to write in each space (the 'answer' or 'solution').
 The aim of the puzzle is to find the set of solution words such that each
 clue's solution is correct for that clue, and fits in the grid correctly,
 with respect to the overlapping words.
\end_layout

\begin_layout Standard
Grids can be very densely white, with few black squares and most squares
 shared by two words (usually called 
\noun on
American Style
\noun default
) or more sparse, with fewer overlapped clues (called 
\emph on
\noun on
British Style
\emph default
\noun default
).
 Clues can also be in two styles.
 
\noun on
Straight
\noun default
 or 
\noun on
Quick
\noun default
 crossword clues usually provide a single straightforward indicator as to
 what the correct word might be - often a synonym for the clue ('Joyful'
 = 'Happy') or a missing word (
\begin_inset Quotes eld
\end_inset

Stitch in ____ saves nine
\begin_inset Quotes erd
\end_inset

 = 
\begin_inset Quotes eld
\end_inset

Time
\begin_inset Quotes erd
\end_inset

).
 
\noun on
Cryptic
\series bold
\noun default
 
\series default
clues are less straight-forward, appearing on the surface to be a valid
 syntactic utterance in English, but actually consisting of a definition
 (as in the Straight clue) and some wordplay which the solver can use to
 arrive at the same answer as with the definition by apply a series of transform
ations and operations.
 The challenge is that the definition and the wordplay are not clearly separated
, and that there are multiple ways to apply to the transformations, but
 with only on yielding the correct answer.
 
\end_layout

\begin_layout Standard
It is the task of determining the correct answer for this type of clue that
 this report will address.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Definitely do some more examples dotted throughout here
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Cryptic Crosswords in the Literature 
\end_layout

\begin_layout Standard
While not a topic well covered in scientific literature in general, what
 few analytical studies around cryptic crosswords there are tend to be classifia
ble into three main groups
\end_layout

\begin_layout Subsubsection
Generation of Cryptic Clues
\end_layout

\begin_layout Standard
The largest body of work that exists is centered around the generation of
 cryptic clues, focused largely around analysis of how string literals from
 a pre-determined answer can be transformed by set clueing patterns, as
 well as some work around measures of the quality of generated clues.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
More here
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Interpreting Clues
\end_layout

\begin_layout Standard
The next set are the select few who have done prior, similar investigations
 into interpreting cryptic clues, with some work put into formalizing definition
s and notation for the sorts of clue types that appear in the majority of
 cryptic crosswords, and some attempts at solving based on these interpretations.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
More here
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Other Work
\end_layout

\begin_layout Standard
There has also been some work done towards solving non-cryptic crosswords
 probabilistically, working on whole-grid solutions rather than individual
 clues.
 There are also some more left-of-field studies done: statistical studies
 into errors made during manual solving, and psychological studies into
 solving.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
More here
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Complexity
\end_layout

\begin_layout Standard
A variety of factors make solving cryptic crosswords a difficult problem:
 
\end_layout

\begin_layout Paragraph*
Ambiguity 
\end_layout

\begin_layout Standard
Cryptic crosswords are deliberately ambiguous.
 Instruction indicators are indistinguishable from string literals, which
 are identical to words’ semantic meanings.
 Often, the setter will deliberately chose words to give rise to further
 ambiguities.
 For example, the 
\emph on
Telegraph
\emph default
 printed
\end_layout

\begin_layout LyX-Code
Bug starts to move in dark, glowing endlessly (5)
\end_layout

\begin_layout Standard
cluing for 'MIDGE'.
 Usually "endlessly" and similar mean "remove the last letter", but here
 it is one of five consecutive words to form an acronym from, with the word
 "starts" as an indicator.
\end_layout

\begin_layout Paragraph
State Space 
\end_layout

\begin_layout Standard
Even with only a few different clue types, the number of different readings
 of one clue based on those grows exponentially with the length of the clue.
 This means that unless heuristics are applied, the evaluation time for
 a whole grid longer clues may be unfeasibly long.
 Even longer than it takes me to do the Times Crossword.
 
\end_layout

\begin_layout Paragraph
Lack of Standardization 
\end_layout

\begin_layout Standard
Although all cryptic crossword share some common conventions, there are
 no fixed rules shared between publications for what can and can’t be a
 clue, indicator etc..
 Although most publications have internal guidelines or style-guides, these
 are not accessible to the solver, and some publications (such as the 
\emph on
Guardian
\emph default
) have named setters whose styles and self-imposed rulesets differ, even
 between one publication.
 Alistair Ferguson Ricthie, who set for 
\emph on
Listener
\emph default
 for many years, referenced the concept of fairness in his book 
\emph on
Armchair Crosswords 
\emph default
in 1946.
 He defers the judgement of fairness to a notional rulebook:
\end_layout

\begin_layout Quote
We must expect the composer to play tricks, but we shall insist that he
 play fair.
 
\emph on
The Book of the Crossword
\emph default
 lays this injunction upon him: "You need not mean what you say, but you
 must say what you mean." This is a superior way of saying that he can't
 have it both ways.
 He may attempt to mislead by employing a form of words which can be taken
 in more than one way, and it is your fault if you take it the wrong way,
 but it is his fault if you can't logically take it the right way.
\end_layout

\begin_layout Standard
Although 
\emph on
The Book of the Crossword
\emph default
 there have been many books written on the subject of what should and should
 not constitute a valid cryptic crossword clue.
 One of the most notable and influential was written by 
\emph on
Observer
\emph default
 setter Derrick Somerset Macnutt, both cluing and writing under the name
 Ximenes, in his book 
\emph on
Ximenes on the Art of the Crossword Puzzle
\emph default
.
 The book contains many in-depth guidelines about what a fair clue entails,
 summed up by his successor Azed (Jonathan Crowther, born 1942):
\end_layout

\begin_layout Quote
A good cryptic clue contains three elements: 
\end_layout

\begin_deeper
\begin_layout Quote
1.
 a precise definition
\end_layout

\begin_layout Quote
2.
 a fair subsidiary indication 
\end_layout

\begin_layout Quote
3.
 nothing else
\end_layout

\end_deeper
\begin_layout Standard
A crossword setter following these rules is said to adhere to 'Ximenean
 principles' and their produced work to be Ximenean.
 Most mainstream crosswords exist on a continuum between being more closely
 Ximenean (examples include 
\emph on
The Times
\emph default
, the 
\emph on
Independent
\emph default
) to being very libertarian (e.g.
 
\emph on
Guardian
\emph default
).
 No crossword in a major UK newspaper is 'strictly Ximenean'.
 
\end_layout

\begin_layout Paragraph*
Knowledge Base
\end_layout

\begin_layout Standard
As well as being made up of encrypted and hidden meanings, cryptic crosswords
 also draws on a diverse knowledge base of synonyms, abbreviations, facts
 etc.
 These can include information as diverse as names of capital cities, common
 sayings, and the fact that one may carry a wallet in ones pocket.
 
\end_layout

\begin_layout Standard
In order to run a fully working cryptic crossword solver against any arbitrary
 clue, all of these pieces of information must be encoded, stored and accessible
 to the solver in a machine readable form.
 Understandably, this is subject to an entire field of study itself.
 
\end_layout

\begin_layout Subsection
Programming Language Analogues
\end_layout

\begin_layout Standard
Much of the current work on interpreting crosswords draws on work by Backus,
 Naur and Chomsky in creating a specification for the grammar of crosswords.
 While these frameworks are useful for describing many different languages,
 interpretations of the grammar of cryptic crosswords seem to be perversely
 somewhat closer to mathematical and programming languages than to natural
 language.
 In some ways, the cryptic clue as a whole can be thought of as a program
 that generates the output string as its answer.
 The wordplay section is analogous to a program, and the definition section
 of a clue could be thought of as a checksum to verify the final answer.
\end_layout

\begin_layout Subsubsection
Lexing, Parsing, Evaluating 
\end_layout

\begin_layout Standard
The steps for compiling and running a computer program apply also to solving
 (or 'running') a crossword as a program.
 Each word in the input string needs to be tokenized, parsed into a relevant
 structure and then that structure evaluated to produce the final answer.
 Unusually for a programming language, however, the grammar of a cryptic
 crossword is highly ambiguous, and requires complex parsing.
 Firstly, programming language are only usually required to output the one
 valid abstract syntax tree, however here we may need to output many thousands
 in order to evaluate them to see which yields the correct answer.
 Furthermore, the grammar cannot be expressed without using complex context-sens
itive features such as lookbacks, lookaheads and backtracking.
 Most major programming languages are parsed without these features, allowing
 information to flow in one direction from the lexer to the parser.
 To parse a cryptic crossword, lexing and parsing need to take place simultaneou
sly in a process referred to as called 
\begin_inset Quotes eld
\end_inset

Scannerless Parsing
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsection
There's No Accounting for Wit
\end_layout

\begin_layout Standard
Along with clearly defined and program-like cryptic crossword clues, there
 exist other clues that rely on humour, imagery and wit, rather than following
 the regimented classical structure, as set out by Ximenes.
 Some examples include:
\end_layout

\begin_layout LyX-Code
Flower of London? (6)    
\end_layout

\begin_layout LyX-Code
    (= THAMES, flower = that which flows)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
In which you can get three couples together and have sex (5) 
\end_layout

\begin_layout LyX-Code
    (= LATIN, 'sex' is 6 in Latin)
\end_layout

\begin_layout Standard
Clues such as these, and the question of computerised wit and humour, unfortunat
ely exist out of the scope of this project.
\end_layout

\begin_layout Section
Parsing Frameworks and Notation
\end_layout

\begin_layout Standard
Some different notations for denoting parsing of cryptic clues have come
 out of previous work – in order to properly provide a rigorous analysis
 of the structures and conventions of cryptic crosswords, it is necessary
 to analyze and choose a framework in which to do it.
 
\end_layout

\begin_layout Subsection
LACROSS
\end_layout

\begin_layout Standard
William and Woodhead produced language called LACROSS, which forms a sort
 of calculus for describing crossword clues.
 They also provide a BNF definition of this grammar.
 Their clues are of the general form 
\end_layout

\begin_layout LyX-Code
Clue := Δ = G | G = Δ 
\end_layout

\begin_layout Standard
the orientation of which corresponds to the order in which we find the definitio
n (Δ) and the wordplay (G) in the clue.
 The wordplay may be further expanded out – the wordplay section of the
 clue is expressed as a sequential annotation for the constituent parts,
 either as ‘text’ (t), ‘shortening’ (S) (etc.) or as placeholders for the
 operators (*), which are detailed afterwards, including a reference to
 the substituted indicator.
 So for instance: 
\end_layout

\begin_layout LyX-Code
Get in odd bit of colour (5) [= tinge] 
\end_layout

\begin_layout LyX-Code
t* = Δ, a (odd, a) 
\end_layout

\begin_layout Standard
There are several issues with this grammar.
 Firstly, all unitary operators are treated the same, as are all binary
 operators, and there is some issue with binding and precedence which they
 address with an underlining notation, in addition to brackets.
 Secondly, the grammar attempts to include both the structure of the parsed
 cluing and how that structure relates to the original sequence of words
 at the same time.
 As a result, we end up with complex grammar that does not aid human parsing
 of the solution well, nor does it lend itself easily to computer or mathematica
l manipulation
\end_layout

\begin_layout Standard
Still, they have provided the basis for future work, and begun a basic enumerati
on of clue types.
 
\end_layout

\begin_layout Subsection
Simple Clue Markup Language 
\end_layout

\begin_layout Standard
Proposed by Hall and Rapanotti, Simple Clue Markup Language (SCML) attempts
 to notate the structure of the solution directly onto the clue.
 
\end_layout

\begin_layout Standard
Double underlining is used to denote the definition, underlining denotes
 an operator, with its class as an optional subscript, with scope provided
 by brackets and concatenation (and definition/wordplay separation) given
 by a semi-colon.
 Thus in their given example: 
\end_layout

\begin_layout LyX-Code
Note the shuddering appliance Bill regularly installed, noisy thing (6,7)
 
\end_layout

\begin_layout LyX-Code

\bar under
Note
\bar default
;(the)
\bar under
shuddering
\bar default

\begin_inset script subscript

\begin_layout Plain Layout
a
\end_layout

\end_inset

;(appliance,(Bill)
\bar under
regularly
\bar default

\begin_inset script subscript

\begin_layout Plain Layout
t
\end_layout

\end_inset

)
\bar under
installed
\bar default

\begin_inset script subscript

\begin_layout Plain Layout
e
\end_layout

\end_inset

;
\uuline on
noisy thing
\uuline default
 
\end_layout

\begin_layout Quote
Note’ often indicates a musical note, resolving to one of ‘a’ to ‘g’, ‘do’,
 ‘re’, ‘mi’, etc; 
\end_layout

\begin_layout Quote
‘the shuddering’ may be an anagram indicator applied to ‘the’; 
\end_layout

\begin_layout Quote
the ‘regularly’ of ‘Bill regularly’ may indicate alternate letters (‘t’);
 i.e., ‘bl’ or ‘il’; and 
\end_layout

\begin_layout Quote
‘installed’ suggests the embedding (‘e’) of those letters within something
 meaning ‘ appliance’.
\end_layout

\begin_layout Standard
In this, we have no markup differentiation for literal strings (‘Bill’)
 against words with their semantic context (‘appliance’), and we also take
 certain words that reduce to abbreviations (‘Note’) to be non-deterministic
 nullary operators.
 With some changes and additions (tagging of string vs.
 semantic word, for example), this markup serves as a good way to represent
 a parsing of a clue in a human readable way.
 It even has the advantage that a printed clue could be annotated (carefully)
 by hand, as a teaching aid, for example.
 Unfortunately, the language as it stands is not expressible as a BNF grammar,
 nor is it a particularly good format for representing the clue and its
 parsings internally in a program (as it would need to be re-parsed to use!)
 
\end_layout

\begin_layout Subsection
Clue-answer notation 
\end_layout

\begin_layout Standard
There are several emergent solutions within online cryptic crossword communities
 for notation to explain solutions derived from clues.
 From http://cryptics.wikia.com: 
\end_layout

\begin_layout Quote
Consider the down clue A message from the setter, hauled up with broken
 arm after heroin withdrawal (8) yielding the answer TELEGRAM.
 The corresponding wordplay, having the prolix and possibly ambiguous explanatio
n THE next to LEG reversed next to an anagram of ARM, all with H (heroin)
 removed could be concisely represented in clue-answer notation simply as
 T[h]E,GEL<=,(ARM)*.
 
\end_layout

\begin_layout Standard
These meanings are not fixed, but some definitions are given here: 
\end_layout

\begin_layout Paragraph
ABC<= or ABC (rev.) ABC reversed.	
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
The (rev.) notation is most commonly used when the wordplay consists of a
 single reversal.					
\end_layout

\begin_layout Paragraph
[abc] or -abc or (abc) 
\end_layout

\begin_layout Standard
Letters abc removed, as in[c]OUNT to represent 'count' with c removed; the
 convention is to use lower case for the removed letters.
 
\end_layout

\begin_layout Paragraph
(ABC) 
\end_layout

\begin_layout Standard
Letters placed inside others, as inC(AND)ID to mean 'and' inside 'cid'.
 
\end_layout

\begin_layout Paragraph
"ABC" 
\end_layout

\begin_layout Standard
Homophone of ABC.
 
\end_layout

\begin_layout Paragraph
(ABC)* 
\end_layout

\begin_layout Standard
Anagram of ABC.
\end_layout

\begin_layout Paragraph
A+B or A,B 
\end_layout

\begin_layout Standard
A concatenated with B.
 Sometimes both notations are used together where ambiguities may arise.
 
\end_layout

\begin_layout Paragraph
aBcDeF 
\end_layout

\begin_layout Standard
Alternate letters of ABCDEF (shorthand for[ a]B[c]D[e]F).
 
\end_layout

\begin_layout Subsection
PICCUP
\end_layout

\begin_layout Standard
Hart and Davies define what is currently the most satisfying proposal for
 a formal syntactical definition of cryptic crossword syntax, in a loosely
 BNF grammar.
 Theirs is the only current definition that closely resembles a usable formally
 defined language.
\end_layout

\begin_layout Standard
Their interpretation only specifies the grammar in terms of building an
 abstract syntax tree, rather than attempting to include a notation for
 clue or answer.
\end_layout

\begin_layout LyX-Code
Anagram → Synonym(.Equ Indicator).AnagramSentence
\end_layout

\begin_layout LyX-Code
/AnagramSentence(.Equ Indicator).Synonym 
\end_layout

\begin_layout LyX-Code
AnagramSentence → AnagramPointer.AnagramMaterial
\end_layout

\begin_layout LyX-Code
/ Anagram Material.Anagram Pointer AnagramPointer~ Word(.Word)* 
\end_layout

\begin_layout LyX-Code
AnagramMaterial → Word(.Word)* 
\end_layout

\begin_layout LyX-Code
Synonym → Word(.Word)* 
\end_layout

\begin_layout LyX-Code
Equ Indicator → Word (.Word)*
\end_layout

\begin_layout Subsection
Syntactic and Metasyntactic Conventions
\end_layout

\begin_layout Standard
Here we apply a similar convention to Hart, in using a modified Backus Naur
 Form (BNF).
 We will later see that a context-free grammar may not be sufficient to
 model a cryptic crossword, and may have further deficiencies as a basis
 for finding a solution.
 Nevertheless, we will adopt a similar notation: 
\end_layout

\begin_layout LyX-Code
→ = is composed of 
\end_layout

\begin_layout LyX-Code
, = followed by 
\end_layout

\begin_layout LyX-Code
| = or
\end_layout

\begin_layout LyX-Code
(x) = x is optional 
\end_layout

\begin_layout LyX-Code
x* = 1 or more occurrences of x 
\end_layout

\begin_layout LyX-Code
(x)* = 0 or more occurrences of x 
\end_layout

\begin_layout Standard
We also take the BNF conventions 
\end_layout

\begin_layout LyX-Code
Word = non-terminal symbol 
\end_layout

\begin_layout LyX-Code
“word” = string literal 
\end_layout

\begin_layout LyX-Code
[x, y, z] = list containing x y and z 
\end_layout

\begin_layout LyX-Code
(x, y) = pair x and y 
\end_layout

\begin_layout Standard
For clarity, we additionally define: 
\end_layout

\begin_layout LyX-Code
String = [any string literal]
\end_layout

\begin_layout Subsection
Context Free?
\end_layout

\begin_layout Standard
The grammar described in this paper not a regular grammar (for example:
 any of the binary operators generate two non-terminals), but it can be
 formulated as a context-free grammar.
 
\end_layout

\begin_layout Standard
We define a 
\noun on
context-free grammar
\noun default
 (CFG) as one in which the expansion of a non-terminal is not affected by
 the symbols before and after it.
\end_layout

\begin_layout Standard
While we can certainly define a working grammar for cryptic crossword clues
 in terms of a CFG, it may be useful to consider other options as a means
 of reducing the number of trees generated during the parsing phase to speed
 up the evaluation phase.
 We could take, for example, the clue length as a contextual variable: in
 that case, a 6 letter clue whose parse tree contains an anagram of a 4-letter
 string cannot yield another anagram of 5 letters.
\end_layout

\begin_layout LyX-Code
        Cons Node
\end_layout

\begin_layout LyX-Code
   
\bar under
         |       
\end_layout

\begin_layout LyX-Code
Anagram        Wordplay
\end_layout

\begin_layout LyX-Code
  |               
\end_layout

\begin_layout LyX-Code
String
\end_layout

\begin_layout LyX-Code
  |
\end_layout

\begin_layout LyX-Code
\begin_inset Quotes eld
\end_inset

apples
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
In this example, the wordplay on the right should not be expanded out to
 an anagram node featuring a string of 5 characters (to consume, say, the
 string 
\begin_inset Quotes eld
\end_inset

mixed pears
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Subsection
Syntax vs Semantics
\end_layout

\begin_layout Standard
Due to the ambiguous and duplicitous nature of the structure of cryptic
 crosswords, especially the deliberate challenges in the lexing phase, unclarity
 between the boundaries between parsing the syntax and evaluating the semantics
 emerge.
 
\end_layout

\begin_layout Standard
Strings consisting of one or more words can be at once tokens representing
 different operators, they can be strings, and can be split in multiple
 ways into combinations.
 This is especially true when we have token that, in the original text,
 represent their semantic meaning in English, and evaluate out to a finite
 number of equivalent words (roughly, synonyms: see later for discussion
 about this equivalence relation).
 
\end_layout

\begin_layout Standard
Hall and Rapanotti treated these roughly as their own operators: so the
 string 
\begin_inset Quotes eld
\end_inset

rough
\begin_inset Quotes erd
\end_inset

 would parse to the token Rough, which later evaluates to a finite number
 of definitions.
 This may, indeed, be tempting if we had a limited number of candidate words.
 And, indeed, we do need to differentiate these from raw string literals
 that are subject to Hidden Word or Initial Letter operators, or occasionally
 concatenated in their raw form (for example the string 
\begin_inset Quotes eld
\end_inset

it
\begin_inset Quotes erd
\end_inset

 is sometimes taken as given where necessary) .
\end_layout

\begin_layout Standard
I think a more manageable way and satisfying way to consider these options
 is to consider them subject to an invisible 'word' operator.
 This keeps the semantics and syntax more separate, but certainly poses
 some challenges for a parser / lexer.
\end_layout

\begin_layout Section
The Cryptic Crossword Clue 
\end_layout

\begin_layout Subsection
Structure of a cryptic clue
\end_layout

\begin_layout Standard
A cryptic crossword differs from a normal crossword in that the clue for
 each answer consists of two parts.
 The first is the definition, which performs the same function as a clue
 in a 'regular' crossword.
 The answer to the clue is usually a synonym for the definition ('circular'
 and 'round') or may be an example of the definition ('farm animal' and
 'pig').
 Other forms that the definition may take will be discussed later on.
 The second part of the clue is the wordplay.
 This is an encoded and often ambiguous second method of deriving the answer,
 using techniques such as anagram, substitution and concatenation.
 The clue as a whole is presented as a concatenation of the two parts, sometimes
 with a subsidiary word indicating that one can be derived from the other
 (for example, 'from' or 'is').
 We can present this breakdown as: 
\end_layout

\begin_layout LyX-Code
Clue → Definition, (Indicator), Wordplay 
\end_layout

\begin_layout LyX-Code
       | Wordplay, (Indicator), Definition 
\end_layout

\begin_layout Standard
The final clue will often resemble a valid English utterance, although this
 'surface reading' (i.e.
 {clue} ) very rarely has any relation to the answer.
 Later on we will consider other information and context within the definition
 of a clue.
\end_layout

\begin_layout Subsection
Definition 
\end_layout

\begin_layout Standard
The definition of the clue consists of one or more English words.
 The answer to the clue will be a word or phrase that fits an appropriate
 equivalence function (that we will define later).
\end_layout

\begin_layout Standard
The definition carries a variety of linguistic features with it that the
 overall answer, and so the answer as derived by the wordplay, must match.
 These include aspect (noun, verb, adjective), plurality (tree, trees),
 tense (go, going, gone).
 These features may also be considered as 'context' to the clue itself.
 
\end_layout

\begin_layout Subsubsection
Formally 
\end_layout

\begin_layout Standard
We can define the definition as 
\end_layout

\begin_layout LyX-Code
Definition → Words
\end_layout

\begin_layout Subsection
Wordplay 
\end_layout

\begin_layout Standard
The wordplay section of a clue is a set of deliberately ambiguous instructions
 that allows the solver to arrive at the eventual answer.
 As the instructions are ambiguous, multiple possible parsings of the instructio
ns are possible.
 Some of these parsing will not lead to a valid English word: 
\end_layout

\begin_layout LyX-Code
Imbecile, bonkers, in a cult (7) 
\end_layout

\begin_layout LyX-Code
==> Wordplay ‘Imbecile, bonkers = definition ‘in a cult’
\end_layout

\begin_layout LyX-Code
==> Anagram ‘imbecile’ [indicator = bonkers] = definition ‘in a cult’ 
\end_layout

\begin_layout LyX-Code
==> ??? (no anagrams of imbecile in english language) 
\end_layout

\begin_layout LyX-Code
(correct reading was anagram of in a cult = lunatic)
\end_layout

\begin_layout Standard
Others will lead to a valid English word, but one that is not equivalent
 to the definition: 
\end_layout

\begin_layout LyX-Code
Minder shredded corset (6) 
\end_layout

\begin_layout LyX-Code
==> Wordplay ‘minder shredded’ = definition ‘corset’ 
\end_layout

\begin_layout LyX-Code
==> Anagram ‘minder’ [indicator = shredded] = definition ‘corset’ 
\end_layout

\begin_layout LyX-Code
==> ‘remind’ = definition ‘corset?’ X 
\begin_inset Newline newline
\end_inset

(correct reading was anagram ‘corset’ = escort = minder)
\end_layout

\begin_layout Standard
The solver must find the correct parsing of the wordplay that yields the
 correct definition: even though they may not know which part is wordplay
 and which is definition.
\end_layout

\begin_layout Subsection
Special Operators 
\end_layout

\begin_layout Standard
I include these two operators first, as they really form the backbone or
 basis of other clues.
 They are also unique in being implicitly clued, rather than requiring an
 indicator word to signify their presence.
 
\end_layout

\begin_layout Paragraph
Word Equivalence
\end_layout

\begin_layout Standard
In the most simple of clues, we have the definition, along with a word or
 phrase that is somehow semantically equivalent to that definition.
 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
In this case, it becomes a difficult task to be precise about exactly which
 of these is the definition and which is the wordplay! Sometimes there is
 a defined answer: From 'Oinking tendency? (8)' we get both 'pen chant'
 and 'penchant', and we can see from the letters required (no space) that
 the second half is the solution.
 In other cases, this may not be defined at all! 
\end_layout

\end_inset

 A clue that contains just this structure is said to be 'double definition'
\end_layout

\begin_layout LyX-Code
Metal guide (4) [= LEAD]
\end_layout

\begin_layout Standard
However, even in this simple example we see that this equivalence relationship
 is not at all straightforward.
 While 'guide' and 'lead' are synonyms (as verbs in the present tense),
 it's not true that 'lead' is a synonym for 'metal'.
 We must also include 'for example' in this relationship too, which causes
 us to have to discard reflexivity.
 Although 'metal' can be a clue for 'lead', it's not the case that 'lead'
 can be a clue for 'metal' (in that case, we signify 'an example of' by
 writing 'lead, say' or 'bronze, for instance').
 
\end_layout

\begin_layout Standard
We also include abbreviations, which are perhaps more closely related to
 synonyms, although not usually found in thesauruses, along with some useful
 'setters favourites', where an abbreviation of a synonym or of an example
 is particularly useful for cluing a difficult letter combination used in
 a wordplay ('Books' becomes 'NT', for 'New Testament').
\end_layout

\begin_layout LyX-Code
Words → Synonym | Abbreviation | Example 
\end_layout

\begin_layout LyX-Code
Synonym → String
\end_layout

\begin_layout LyX-Code
Abbreviation → String
\end_layout

\begin_layout LyX-Code
Example → String
\end_layout

\begin_layout Standard
The semantic task of evaluating this will be discussed later.
\end_layout

\begin_layout Paragraph
Concatenation
\end_layout

\begin_layout Standard
While not strictly necessary for this grammar (as we have included a concatenati
on in our metasemantics, we could define multiple definitions of each operator
 in the form Operator → Indicator, Wordplay, (Wordplay)*), it makes sense
 to add this explicitly as it mirrors the structure of an explanation of
 a computer solution (i.e.
 the parse tree).
\end_layout

\begin_layout LyX-Code
Concatenation → Wordplay (ConcatIndicator) Wordplay
\end_layout

\begin_layout Standard
This represents a key tool for cluers to create more complex wordplay clues
 in the form of a charade, where two or more parts can be split out (sometimes
 syllabically as in 'bath', 'tub', or sometimes otherwise 'bat','htub')
 and clued separately, and then later joined to form the overall solution.
\end_layout

\begin_layout Subsection
Other Wordplay Operators
\end_layout

\begin_layout Standard
For the other wordplay operators, we define them in terms of our grammar,
 as well as discussing their semantic meaning.
\end_layout

\begin_layout LyX-Code
Wordplay → Words | Concatenation | Anagram | Reversion | Contraction 
\end_layout

\begin_layout LyX-Code
          | Selection | Hidden Word | Containment | Subtraction 
\end_layout

\begin_layout LyX-Code
          | Homophone
\end_layout

\begin_layout Standard
These operators all include an indicator word to show they are being applied
 (as is far more common with operators in programming language parsing!)
 Each operator will usually have many different indicators (lists of anagram
 indicators on the web span multiple hundreds).
 Only select ones are included in the specification here.
\end_layout

\begin_layout Subsubsection
Unitary Operators 
\end_layout

\begin_layout Paragraph
Anagram 
\end_layout

\begin_layout Standard
A very commonly used operator in crossword clues is an anagram.
 These take the form of an indicator word that denotes that the anagram
 function is being used (called an ‘anagrind’ within cruciverbalist circles),
 along with the candidate letters to be anagrammed.
 The simplest form of this gets the candidate letters verbatim from the
 clue: 
\end_layout

\begin_layout LyX-Code
Anagram → Anagrind, String | String, Anagrind 
\end_layout

\begin_layout Standard
Sometimes, however sometimes there is some sort of operation applied to
 the letters before the anagram is applied.
 For example: 
\end_layout

\begin_layout LyX-Code
Comic bare for short comedy play (7,5) 
\end_layout

\begin_layout LyX-Code
==> Wordplay ‘Comic bare for short comedy’ = Definition ‘play’ 
\end_layout

\begin_layout LyX-Code
==> Anagram ‘bare for short comedy’ [anagrind = ‘comic’] 
\end_layout

\begin_layout LyX-Code
==> Anagram (“bare for” + Shorten ‘comedy’) 
\end_layout

\begin_layout LyX-Code
==> Anagram (“bare fore” + “comed”) 
\end_layout

\begin_layout LyX-Code
==> Anagram (“bare fore” + “comed”) 
\end_layout

\begin_layout LyX-Code
==> Anagram (“bareforecomed”) 
\end_layout

\begin_layout LyX-Code
==> “Bedroom Farce” 
\end_layout

\begin_layout Standard
In which case we find the more general case one proposed structure: 
\end_layout

\begin_layout LyX-Code
Anagram → Anagrind, Wordplay | Wordplay, Anagrind 
\end_layout

\begin_layout Standard
Wherein we know that the repeated evaluation of the Wordplay will eventually
 result in a string literal that can be anagrammed.
 In 
\emph on
Art of the Crossword Puzzle, 
\emph default
Ximenes argued against this form of indirect anagram: 
\end_layout

\begin_layout Quote
Secondly – and here, for once, I differ from Afrit – I hate what I call
 an indirect anagram.
 By that I mean "Tough form of monster" for HARDY (anagram of HYDRA).
 There may not be many monsters in five letters; but all the same I think
 the clue-writer is being mean and withholding information which the solver
 can reasonably demand.
 Why should he have to solve something before he can begin to use part of
 a clue? He has first to find "hydra" – and why shouldn't it be "giant"?
 – and then use the anagrammatic information to help him think of "hardy".
 ...
 My real point is that the secondary part of the clue – other than the definitio
n – is meant to help the solver.
 The indirect anagram, unless there are virtually no alternatives, hardly
 ever does.
 He only sees it after he has got his answer by other means.
 
\end_layout

\begin_layout Standard
Even so, most setters that claim to be Ximenean will allow small abbreviations
 and contractions (to be defined later) to be included in their clues.
 We therefore must define a new class which includes String Literals as
 well as the abbreviation where appropriate.
 
\end_layout

\begin_layout LyX-Code
Anagram → Anagrind, StringWordplay* | StringWordplay*, Anagrind
\end_layout

\begin_layout LyX-Code
Anagrind → “free” | “novel” | “comic” [...]
\end_layout

\begin_layout LyX-Code
StringWordPlay → String | Abbreviation | Contraction
\end_layout

\begin_layout Paragraph
Reversion 
\end_layout

\begin_layout Standard
Clues can also be reversed.
 While this is functionally a subset of anagrams, there are some crucial
 differences.
 Firstly the ‘directionality’ of the clue (i.e.
 whether it is a ‘down’ or an ‘across’) comes into effect, in determining
 the sorts of indicators that can form it: “turned back” may only apply
 to ‘across’ clues, where “taken up” may only apply to ‘down’ clues.
 Further, these clues are usually taken to be ‘fairer’ game for subsequent
 operations to be applied to the target of the reversion.
 Therefore, a clue with nested wordplay such as ("Stressed, made upside-down
 pudding (7)" = DESSERT) would be acceptable, where an equivalent clue as
 an anagram ("Stressed, cooked up pudding") would often not be seen as Ximenean.
 
\end_layout

\begin_layout LyX-Code
Anagram → ReversionIndictator, Wordplay | Wordplay, ReversionIndictator
\end_layout

\begin_layout LyX-Code
ReversionIndicator → 
\begin_inset Quotes eld
\end_inset

around
\begin_inset Quotes erd
\end_inset

 | 
\begin_inset Quotes eld
\end_inset

turned back
\begin_inset Quotes erd
\end_inset

 | 
\begin_inset Quotes eld
\end_inset

taken up
\begin_inset Quotes erd
\end_inset

 [...]
\end_layout

\begin_layout Paragraph
Contraction 
\end_layout

\begin_layout Standard
Clues of this form range from specific, such of first/last letters ('first
 in line' = 'l', 'last of the Mohicans' = 'm') to more general operators
 ('mostly harmless' can yield 'armless', 'harmles', 'harmle'...) whose definitions
 are more flexible.
\end_layout

\begin_layout LyX-Code
Contraction → FirstLetterContraction | LastLetterContraction | GeneralContractio
n 
\end_layout

\begin_layout LyX-Code
FirstLetterContraction → PreFLCIndicator, Wordplay | Wordplay, PostFLCIndicator
\end_layout

\begin_layout LyX-Code
LastLetterContraction → PreLLCIndicator, Wordplay | Wordplay, PostLLCIndicator
\end_layout

\begin_layout LyX-Code
GeneralContraction → PreGCIndicator, Wordplay | Wordplay, PostGCIndicator
\end_layout

\begin_layout Paragraph
Selection 
\end_layout

\begin_layout Standard
There are three similar operators here: A pair which select even or odd
 letters respectively, and one which takes initial letters across multiple
 words.
 These are rarely, if ever, applied to anything other than pure strings.
 The initials indicator needs to be applied to an argument consisting of
 multiple words.
\end_layout

\begin_layout LyX-Code
Selection → Evens | Odds | Initials
\end_layout

\begin_layout LyX-Code
Evens → EvensIndicator, String | String, EvensIndicator
\end_layout

\begin_layout LyX-Code
Odds → OddsIndicator, String | String, OddsIndicator
\end_layout

\begin_layout LyX-Code
Initials → InitialsIndicator, String, 
\begin_inset Quotes eld
\end_inset

 
\begin_inset Quotes eld
\end_inset

, String* | 
\begin_inset Newline newline
\end_inset

           String, 
\begin_inset Quotes eld
\end_inset

 
\begin_inset Quotes eld
\end_inset

, String*, InitialsIndicator
\end_layout

\begin_layout Paragraph
Hidden word 
\end_layout

\begin_layout Standard
The hidden word clue finds a word which appears as a substring (ignoring
 spaces) inside its operand.
 These typically only occur once per puzzle, and are always accompanied
 by a clear indicator.
 In this example clue:
\end_layout

\begin_layout LyX-Code
'Smack which appears in East Anglian ports.(4)' 
\end_layout

\begin_layout Standard
the solution to this example is 'TANG', (meaning 'smack' in the sense of
 'taste'), and which is concealed (indicated by 'which appears') in 'easT
 ANGlian ports'.
 
\end_layout

\begin_layout LyX-Code
HiddenWord → HWIndictator String | String HWIndicator
\end_layout

\begin_layout Standard

\series bold
Homophone
\end_layout

\begin_layout Standard
Also called 'sounds like', this operator produces homophones of a given
 word.
 They may be spelled differently ('right' and 'rite') or the same but said
 differently ('Polish' and 'polish').
 This operator is not applied to words that are both spelled and said the
 same, but with different meanings ('must' as an imperative and 'must' as
 a noun).
 
\end_layout

\begin_layout Standard
Often, if clues are straightforward, placement of this operator can determine
 the spelling of the answer.
 
\end_layout

\begin_layout LyX-Code
We hear twins shave (4)
\end_layout

\begin_layout Standard
yields 'pare' whereas
\end_layout

\begin_layout LyX-Code
Twins shave, we hear (4)
\end_layout

\begin_layout Standard
yields 'pair'.
 A formulation with the indicator in the middle, in this case, would result
 in a strong ambiguity.
 The homophone indicator is only applied to equivalence words, not to clued
 wordplay.
\end_layout

\begin_layout LyX-Code
Homophone → HomophoneIndicator Words | Words HomophoneIndicator
\end_layout

\begin_layout Subsubsection
Binary Operators 
\end_layout

\begin_layout Standard
As with the unitary operator, each of the arguments of binary operators
 can be one or more words.
\end_layout

\begin_layout Paragraph
Containment 
\end_layout

\begin_layout Standard
Here are two styles of wordplay which are clued very differently, but are
 actually the same operator, which places one set of letter inside another.
 This is either presented as a insertion ('end inside ls') or as a containment
 ('ls around end').
 This operation always preserves letter order, unless some nested indicator
 allows otherwise.
 
\end_layout

\begin_layout LyX-Code
Containment → Wordplay ContainmentIndicator Wordplay  
\end_layout

\begin_layout LyX-Code
ContainmentIndicator → 
\begin_inset Quotes eld
\end_inset

inside
\begin_inset Quotes erd
\end_inset

 | 
\begin_inset Quotes eld
\end_inset

around
\begin_inset Quotes erd
\end_inset

 [...]
\end_layout

\begin_layout Paragraph
Subtraction 
\end_layout

\begin_layout Standard
In a subtraction clue, a number of letters are removed from the target.
 Usually, the target is some wordplay itself, although sometimes just a
 string literal.
 The letters to be subtracted are also often the product of some sort of
 cluing, although this is usually fairly limited in scope (abbreviations,
 contractions, first letters of string literals).
 There are two constraints on this: all the letters from the subtraction
 set must be in the target, and the length of the subtraction set must be
 less than the length of the target.
 
\end_layout

\begin_layout LyX-Code
Subtraction → SubPreIndictator1 Wordplay (SubPreIndictator2) Wordplay 
\begin_inset Newline newline
\end_inset

   | Wordplay SubM
\noun on
function 
\noun default
idIndictator Wordplay 
\begin_inset Newline newline
\end_inset

   | Wordplay (SubPostIndictator1) Wordplay SubPostIndictator2 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
SubPreIndictator1 → 
\begin_inset Quotes eld
\end_inset

took
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

without
\begin_inset Quotes erd
\end_inset

 [...]
\end_layout

\begin_layout LyX-Code
SubPreIndictator2 → 
\begin_inset Quotes eld
\end_inset

from
\begin_inset Quotes erd
\end_inset

 [...]
\end_layout

\begin_layout LyX-Code
SubMidIndictator → 
\begin_inset Quotes eld
\end_inset

without
\begin_inset Quotes erd
\end_inset

 [...]
\end_layout

\begin_layout LyX-Code
SubPostIndictator1 → 
\begin_inset Quotes eld
\end_inset

with
\begin_inset Quotes erd
\end_inset

 [...]
\end_layout

\begin_layout LyX-Code
SubPostIndictator2 → 
\begin_inset Quotes eld
\end_inset

removed
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

deleted
\begin_inset Quotes erd
\end_inset

 [...]
\end_layout

\begin_layout Standard
Semantically here, we have the difference in pre- and post- as the difference
 between 
\begin_inset Quotes eld
\end_inset

wanted ant removed
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

removing ant wanted
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Standard
The letters in the set are thought to be removed in the order in which they’re
 found in order to be a properly clued wordplay.
 Thus “standing” with “tan” removed, gives “sanding”, whereas “ant” cannot
 be appropriately removed.
 Note though that the order in which nested clues are applied can change
 what the set is applied too.
 If we also had an anagram indicator, as in “Boy muddled standing missing
 trap” we can apply the muddled to standing to get “dansting” before removing
 “sting” to get the answer “Dan”.
\end_layout

\begin_layout Subsection
Meta-references 
\end_layout

\begin_layout Standard
Sometimes, clues contain references to that cannot be parsed in isolation,
 or contain a cluing structure that is incompatible with the main model
 of cluing.
\end_layout

\begin_layout Subsubsection
Self reference
\end_layout

\begin_layout Standard
A type of clue called an '&lit' clue allows the setter to not include a
 definition part if the text that makes up the wordplay also can also be
 read as the definition.
 Thus in 
\end_layout

\begin_layout LyX-Code
Spoil vote! (4)
\end_layout

\begin_layout Standard
we have the wordplay Anagram (=spoil) 
\begin_inset Quotes eld
\end_inset

vote
\begin_inset Quotes erd
\end_inset

 to give 'VETO', as well as the clue as a whole 'spoil vote' meaning 'veto'.
\end_layout

\begin_layout Subsubsection
Reference to other clues
\end_layout

\begin_layout Standard
Some publications will have clues that reference the answer to other clues
 ('8 across.
 Cake made badly by 7 down.').
 Sometimes these may also be cyclical (in this example, 7 down would reference
 8 across too).
 
\end_layout

\begin_layout Subsubsection
Contextual References
\end_layout

\begin_layout Standard
Sometimes references will refer outside of the crossword itself.
 For example, The 
\emph on
Sunday Telegraph
\emph default
 on Easter Sunday 2014 had an anagram clue whose answer was EASTER SUNDAY,
 and its definition part was "today".
 In a crossword by setter 
\emph on
Araucaria
\emph default
, "Araucaria is" coded for IAM (= "I am") as part of an answer.
\end_layout

\begin_layout Section
Convention 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Do some shit here, yeah?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Words
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Part
Naive Approach 
\end_layout

\begin_layout Section
Functional Solving
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Yah yah why do we do it functionally?
\end_layout

\end_inset


\end_layout

\begin_layout Section
Parsing and Evaluating everything 
\end_layout

\begin_layout Subsection
Solving a Clue
\end_layout

\begin_layout Standard
Our motivation here is to take a cryptic crossword clue, for example:
\end_layout

\begin_layout LyX-Code
[A]  Ship carrying right flag (8)
\end_layout

\begin_layout LyX-Code
[B]  Companion shredded corset (6)
\end_layout

\begin_layout Standard
and attempt to parse and solve it to provide the correct answer.
 We will define the datatype of Clue thus:
\end_layout

\begin_layout LyX-Code
data Clue = Clue String AnswerLength
\end_layout

\begin_layout LyX-Code
where
\end_layout

\begin_layout LyX-Code
type Length = Int
\end_layout

\begin_layout Standard
In order to solve this clue, we want to find a function that takes a clue,
 which consists of a string containing the text of the clue and an integer
 representing the length of the required answer, and returns us the answer.
\end_layout

\begin_layout LyX-Code
solve :: Clue → Answer 
\end_layout

\begin_layout Standard
The intuition behind how our naive solver will work is that it will generated
 all possible ways of parsing a clue, then generate all possible answers
 that could be derived from those parses, and then attempt to match those
 up with the definition and the length constraints.
 In order to evaluate, measure and optimize each of these steps independently,
 we split the structure of our program into four parts:
\end_layout

\begin_layout LyX-Code
solve = choose .
 evaluate .
 parse .
 split
\end_layout

\begin_layout Standard
where the types are given below:
\end_layout

\begin_layout LyX-Code
split    :: Clue → [Split]
\end_layout

\begin_layout LyX-Code
parse    :: [Split] → [Parse]
\end_layout

\begin_layout LyX-Code
evaluate :: [Parse] → [Answer]
\end_layout

\begin_layout LyX-Code
choose   :: [Answer] → Answer
\end_layout

\begin_layout Subsection
Splitting
\end_layout

\begin_layout Standard
While a clue has a surface reading involving the semantic natural language
 parsing of it as a sentence fragment (which would yield a phrase, with
 an subject, a past tense verb and an object), we are only interested in
 the crossword interpretation of this, which is of the form: 
\end_layout

\begin_layout LyX-Code
  Definition Indicator* Wordplay 
\end_layout

\begin_layout LyX-Code
| Wordplay Indicator* Definition
\end_layout

\begin_layout Standard
Let us forget about the optional indicators for now – we will deal with
 these properly later .
 We are looking to define a function 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
split
\end_layout

\end_inset

 which splits the clue into a wordplay portion and a definition portion.
 So for example, clue 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
A
\end_layout

\end_inset

 can be split 6 different ways:
\end_layout

\begin_layout LyX-Code
 wordplay  definition         definition  wordplay
\end_layout

\begin_layout LyX-Code
   
\begin_inset Formula $\mathtt{\overbrace{Ship}\:\overbrace{carrying\: right\: flag}}$
\end_inset

         
\begin_inset Formula $\mathtt{\overbrace{Ship}\:\overbrace{carrying\: right\: flag}}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \thinspace{}
\end_inset


\end_layout

\begin_layout LyX-Code
    wordplay  definition         definition  wordplay
\end_layout

\begin_layout LyX-Code
   
\begin_inset Formula $\mathtt{\overbrace{Ship\, carrying}\:\overbrace{right\: flag}}$
\end_inset

         
\begin_inset Formula $\mathtt{\overbrace{Ship\, carrying}\:\overbrace{right\: flag}}$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset space \thinspace{}
\end_inset


\end_layout

\begin_layout LyX-Code
       wordplay definition       definition   wordplay
\end_layout

\begin_layout LyX-Code
   
\begin_inset Formula $\mathtt{\overbrace{Ship\, carrying\, right}\:\overbrace{flag}}$
\end_inset

        
\begin_inset Formula $\mathtt{\overbrace{Ship\, carrying\, right}\:\overbrace{flag}}$
\end_inset

  
\end_layout

\begin_layout Standard
From the types of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Wordplay
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Definition
\end_layout

\end_inset

:
\end_layout

\begin_layout LyX-Code
type Definition = String
\end_layout

\begin_layout LyX-Code
type Wordplay = String
\end_layout

\begin_layout Standard
we can create a datatype
\end_layout

\begin_layout LyX-Code
data Split = Def Definition Wordplay AnswerLength
\end_layout

\begin_layout Standard
as well as the signature of a function 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
split
\end_layout

\end_inset

:
\end_layout

\begin_layout LyX-Code
split :: Clue → [Split]
\end_layout

\begin_layout LyX-Code
split (text length) = 
\end_layout

\begin_layout LyX-Code
    let parts = partitions .
 words $ text 
\end_layout

\begin_layout LyX-Code
    in [Def (unwords d) (unwords w) length | [d,w] <- parts]
\end_layout

\begin_layout Standard
where partitions finds all ways of partitioning a list, and is defined as
\end_layout

\begin_layout LyX-Code
partitions [] = [[]] 
\end_layout

\begin_layout LyX-Code
partitions (x:xs) = [[x]:p | p <- partitions xs] 
\end_layout

\begin_layout LyX-Code
                ++ [(x:ys):yss | (ys:yss) <- partitions xs]
\end_layout

\begin_layout Subsection
Parsing
\end_layout

\begin_layout Standard
Now we have consumed one portion of the string to form the definition in
 each of a list of splits.
 Now we need to parse the rest of the clue into a structure which we can
 evaluate to produce our answer.
 Let us take for an example the correct split (of the 6 available) of 
\end_layout

\begin_layout LyX-Code
       wordplay  definition       
\end_layout

\begin_layout LyX-Code
   
\begin_inset Formula $\mathtt{\overbrace{Ship\, carrying\, right}\:\overbrace{flag}}$
\end_inset

     
\end_layout

\begin_layout Standard
which would have the Haskell structure of 
\end_layout

\begin_layout LyX-Code
Def 
\begin_inset Quotes eld
\end_inset

flag
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

ship carrying right
\begin_inset Quotes erd
\end_inset

 8
\end_layout

\begin_layout Standard
The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
parse
\end_layout

\end_inset

 function must, for each split, consume the wordplay and return all possible
 parses for that wordplay.
 Since each split will return multiple parses, we will want to collect these
 afterwards.
 We define datatype 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Parse
\end_layout

\end_inset

:
\end_layout

\begin_layout LyX-Code
data Parse = Parse Definition ParseTree AnswerLength
\end_layout

\begin_layout Standard
where 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
ParseTree
\end_layout

\end_inset

 will be an Abstract Syntax Tree based on the structure of our clue.
\end_layout

\begin_layout LyX-Code
data ParseTree =  ConcatNode ParseTree ParseTree | SynonymNode String  
   
\end_layout

\begin_layout LyX-Code
   | AnagramNode Anagrind String 
\end_layout

\begin_layout LyX-Code
   | InsertionNode InsertionIndicator ParseTree ParseTree 
\end_layout

\begin_layout LyX-Code
   | SubtractionNode SubtractionIndicator ParseTree ParseTree 
\end_layout

\begin_layout LyX-Code
   | HiddenWordNode HWIndicator [String] 
\end_layout

\begin_layout LyX-Code
   | ReversalNode ReversalIndicator ParseTree 
\end_layout

\begin_layout LyX-Code
   | FirstLetterNode FLIndicator [String] 
\end_layout

\begin_layout LyX-Code
   | LastLetterNode LLIndicator [String] 
\end_layout

\begin_layout LyX-Code
   | PartialNode PartialIndicator ParseTree 
\end_layout

\begin_layout Standard
So we will define:
\end_layout

\begin_layout LyX-Code
parse :: [Split] → [Parse]
\end_layout

\begin_layout LyX-Code
parse = concatMap parseClue
\end_layout

\begin_layout Standard
where
\end_layout

\begin_layout LyX-Code
parseClue :: Split → [Parse]
\end_layout

\begin_layout Standard
In our example, we would require 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
parseClue
\end_layout

\end_inset

 to consume the string 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Ship carrying right flag 
\end_layout

\end_inset

 to generate the parse trees – including the correct one:
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.INSERTION
\backslash
 ("carrying") [.SYNONYM "ship" ] [.ABBREVIATION "right" ]]
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
as well as many others:
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.CONCATENATION [.SYNONYM "ship" ][.LAST
\backslash
 LETTER
\backslash
 ("right") [.SYNONYM "carrying" ]]]
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.CONCATENATION [.SYNONYM "ship" ][.CONCATENATION [.SYNONYM "carrying" ][.SYNONYM
 "flag" ]]]
\end_layout

\end_inset

 
\begin_inset VSpace defskip
\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
and so on.
\end_layout

\begin_layout Subsubsection
Traditional Scanner-Based Parsing
\end_layout

\begin_layout Standard
The first step in the lexical analysis phase of a parse usually consists
 of tokenisation.
 This is the process of grouping characters together into functional groups
 called 
\noun on
tokens
\noun default
, to later pass to the parser to perform the semantic analysis on.
 Tokens consist of a 
\noun on
lexeme
\noun default
 the string of characters known to be of a certain type, and the value they
 represent (for example 
\noun on
integer 3
\noun default
 or 
\noun on
variable name 
\noun default
available_credit).
 The process is often split into two stages.
 
\end_layout

\begin_layout Paragraph
The Scanner
\end_layout

\begin_layout Standard
The first is the 
\noun on
scanner: 
\noun default
this is often a finite state machine, which will consumer characters based
 on rules to produce potential lexemes.
 Some more simple scanners can operate under greedy assumptions (called
 the Maximal Munch principle by R.G.G.
 Cattel), and some require backtracking (for example, the language 
\noun on
C
\noun default
).
 Due to the complexity and ambiguity of the language of cryptic crossword
 clues, it is not possible to produce an accurate scanner that produces
 anything other than a trivial tagging of lexical elements
\begin_inset Foot
status open

\begin_layout Plain Layout
It would, of course, be possible to produce a trivial parser for most languages,
 in which we lex every character or group of letters to a function with
 the value of itself, so instead of the desired 
\noun on
variable 
\noun default
x 
\noun on
equals integer 3 
\noun default
we could instead simply parse to 
\noun on
function 
\noun default
x 
\noun on
function 
\noun default
= 
\noun on
function 3
\noun default
, and leave it to the rest of the pipeline to determine that 
\noun on
function 3
\noun default
 is a constant function which always yields the integer literal 3, but this
 misses the point of having a scanner separately.
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
The Evaluator
\end_layout

\begin_layout Standard
This stage of the tokeniser...
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Yeha, finish this.
 This point is probably less interesting Maybe the above sections should
 be merged together?
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Scannerless Parsing
\end_layout

\begin_layout Standard
Some parsers, traditionally often ones for simple languages such as...
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
Todo: need to finish off this section and explain why my parser is more
 like a scannerless parser.
 Also – this section is a bit incongruous here and kinda breaks the flow.
 Maybe it should be pushed elsewhere?
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Parsing different clue types
\end_layout

\begin_layout Standard
So we need to define a function 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
parseClue
\end_layout

\end_inset

 which will produce a parse tree from an unconsumed split.
 So we have
\end_layout

\begin_layout LyX-Code
parseClue :: Split → ParseTree
\end_layout

\begin_layout Standard
We will define parseString in terms of its parsing of various clue types,
 starting with one of the more simple unary ones.
 We will hold back from the details of unpacking a split into the string
 to be consumed until later.
\end_layout

\begin_layout LyX-Code
parseAnagram :: String → [ParseTree]
\end_layout

\begin_layout LyX-Code
parseAnagram xs = 
\end_layout

\begin_layout LyX-Code
 [AnagramNode (AIndicator x) y |
\end_layout

\begin_layout LyX-Code
              (x,y) <- includeReversals .
 twoPartitions $ xs
\end_layout

\begin_layout LyX-Code
                                     , isAnagramIndicator(x)]
\end_layout

\begin_layout Standard
where
\end_layout

\begin_layout LyX-Code
twoPartitions xs = [(x,y) | [x,y] <- partitions xs]
\end_layout

\begin_layout LyX-Code
includeReversals xs = xs ++ [(snd(x),fst(x)) | x <- xs]  
\end_layout

\begin_layout Standard
We allow both (x, y) and (y, x) through 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
includeReversals
\end_layout

\end_inset

 in order to allow 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
muddled word
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
word muddled
\end_layout

\end_inset

 both to indicate anagrams of 
\begin_inset Quotes eld
\end_inset

word
\begin_inset Quotes erd
\end_inset

.
 This means a that in example [B] we parse both 
\end_layout

\begin_layout Standard
.
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.DEFINITION
\backslash
 "companion" [.ANAGRAM
\backslash
 ("shredded") "corset" ]]
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "5col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Plain Layout
and
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.DEFINITION
\backslash
 "corset" [.ANAGRAM
\backslash
 ("shredded") "companion" ]]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
.
\end_layout

\begin_layout Standard
Anagram clues, along with Hidden Word clues only require a definition and
 a string, so their operands don't require any further parsing.
 Other clues, though, may require the operands to be parsed.
 For example, the parsing of the clue 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
SWEETHEART NEARLY FINISHED (5)
\end_layout

\end_inset

 as 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
(L)OVER
\end_layout

\end_inset

 requires 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
SWEETHEART
\end_layout

\end_inset

 to be parsed into a synonym node after we consumer nearly to be an indicator
 for a partial word node.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.DEFINITION
\backslash
 "finished" [.PARTIAL
\backslash
 ("nearly") [.
\backslash
emph{
\backslash
{unparsed: "sweetheart"
\backslash
}} ] ] ]
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "5col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

 ⇒ 
\end_layout

\begin_layout Plain Layout
parse
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.DEFINITION
\backslash
 "finished" [.PARTIAL
\backslash
 ("nearly") [.SYNONYM "sweetheart" ] ] ]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset

we therefore parse recursively, letting Haskell's list comprehension take
 care of matching the correct partition to the correct parse.
\end_layout

\begin_layout LyX-Code
parsePartialNode :: String → [ParseTree]
\end_layout

\begin_layout LyX-Code
parsePartialNode xs = [PartialNode (LLIndicator x) y' 
\end_layout

\begin_layout LyX-Code
         |(x,y) <- includeReversals .
 twoPartitions $ xs
\end_layout

\begin_layout LyX-Code
          , isPartialIndicator(x)
\end_layout

\begin_layout LyX-Code
          , y' <- parseClue y]
\end_layout

\begin_layout Standard
Still more complex clue types require splitting into three parts – two branches
 and an indicator – and often both of these branches require further parsing.
 For example, in the case of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
SHIP CARRYING RIGHT FLAG
\end_layout

\end_inset

, choosing 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
FLAG
\end_layout

\end_inset

 as the definition, we can generate
\end_layout

\begin_layout Verse
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.INSERTION
\backslash
 ("carrying") [.
\backslash
emph{
\backslash
{unparsed string:
\backslash
 "ship"
\backslash
}} ] [.
\backslash
emph{
\backslash
{unparsed string:
\backslash
 "right"
\backslash
}} ]]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and then consume each of the unparsed strings in turn to produce
\end_layout

\begin_layout Verse
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.INSERTION
\backslash
 ("carrying") [.SYNONYM "ship" ] [.ABBREVIATION "right" ]]
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
It is worth noting here that as well as the top-level parse generating multiple
 different options, each of these sub-parses may also generate several different
 parses, and these themselves may be complex with multiple sub-parses.
 In the clue 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
WORK HARD IN ATTEMPT TO GET CUP
\end_layout

\end_inset

, with definition (=
\begin_inset Flex Code
status open

\begin_layout Plain Layout
\begin_inset Quotes erd
\end_inset

to get
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

) of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
CUP
\end_layout

\end_inset

, we can parse the wordplay as
\end_layout

\begin_layout Verse
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.INSERTION
\backslash
 ("in") [.
\backslash
emph{
\backslash
{unparsed string:
\backslash
 "work hard"}
\backslash
} ] [.SYNONYM "attempt" ]]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
which may subsequently evaluate to the (correct, in this case) parse:
\end_layout

\begin_layout Verse
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.INSERTION
\backslash
 ("in") [.CONCATENATION [.SYNONYM "work" ]  [.ABBREVIATION "hard" ] ] [.SYNONYM
 "attempt" ]]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
as well as others, such as: 
\end_layout

\begin_layout Verse
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.INSERTION
\backslash
 ("in") [.ANAGRAM
\backslash
 ("work") "hard" ] [.SYNONYM "attempt" ]]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here, again, we allow Haskell's list comprehension take care of constructing
 the sub- parse-trees from our recursive calls and constructing them into
 our final list of trees, for example in
\end_layout

\begin_layout LyX-Code
parseConcatNodes :: String -> [ParseTree] 
\end_layout

\begin_layout LyX-Code
parseConcatNodes xs n = let parts = twoParts xs 
\end_layout

\begin_layout LyX-Code
      in [ConcatNode x' y' |( x,y,z) <- parts
\end_layout

\begin_layout LyX-Code
                                  , x' <- (parseClue x)
\end_layout

\begin_layout LyX-Code
                                  , y' <- (parseClue y)]
\end_layout

\begin_layout Standard
and in 
\end_layout

\begin_layout LyX-Code
 parseInsertionNodes :: String -> [ParseTree] 
\end_layout

\begin_layout LyX-Code
 parseInsertionNodes xs n = let parts = threeParts xs                  
 
\end_layout

\begin_layout LyX-Code
       in [InsertionNode (IIndicator y) x' z' 
\end_layout

\begin_layout LyX-Code
           | (x,y,z) <- parts, isInsertionWord(y)
\end_layout

\begin_layout LyX-Code
             , x' <- (parseClue x)
\end_layout

\begin_layout LyX-Code
             , z' <- (parseClue z)] 
\end_layout

\begin_layout Standard
We can then compose each expression type together to form our final definition
 of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
parseClue
\end_layout

\end_inset

, checking the number of words in the phrase to check that we will be able
 to split the string correctly into 2 or 3 parts.
\end_layout

\begin_layout LyX-Code
parseClue :: Split -> [ParseTree] 
\end_layout

\begin_layout LyX-Code
parseClue (Def def ys n) = let len = length .
 words $ ys in
\end_layout

\begin_layout LyX-Code
[SynonymNode ys]    
\end_layout

\begin_layout LyX-Code
++ (if len > 1 then parseConcatNodes ys else [] )  
\end_layout

\begin_layout LyX-Code
++ (if len > 1 then parseAnagramNodes ys else [] )   
\end_layout

\begin_layout LyX-Code
++ (if len > 1 then parseHiddenWordNodes ys else [])   
\end_layout

\begin_layout LyX-Code
++ (if len > 2 then parseInsertionNodes ys else [])   
\end_layout

\begin_layout LyX-Code
++ (if len > 2 then parseSubtractionNodes ys else [])   
\end_layout

\begin_layout LyX-Code
++ (if len > 1 then parseReversalNodes ys else [])  
\end_layout

\begin_layout LyX-Code
++ (if len > 1 then parseFirstLetterNodes ys else [])   
\end_layout

\begin_layout LyX-Code
++ (if len > 1 then parseLastLetterNodes ys else [])   
\end_layout

\begin_layout LyX-Code
++ (if len > 1 then parsePartialNodes ys else [])
\end_layout

\begin_layout Standard
We can then define 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
parse
\end_layout

\end_inset

as
\end_layout

\begin_layout LyX-Code
parse = concatMap parseClue
\end_layout

\begin_layout Subsubsection
Parse Multitudes 
\begin_inset Note Note
status open

\begin_layout Plain Layout
ok, call it something different
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These nested parses can cause the number of produced parses to grow exponentiall
y as the depth of the nesting increases.
 Longer strings with more indicators – especially indicators for binary
 expressions such as insertion indicators and subtraction indicators – are
 more likely to produce deeply nested parses, and therefore return a large
 number of parse trees.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Either give some numbers here, talk about the numbers from later on, or
 just push this whole thing later altogether
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Evaluation
\end_layout

\begin_layout Standard
In the evaluation stage we look to define a function 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
evaluate
\end_layout

\end_inset

with the type signature: 
\end_layout

\begin_layout LyX-Code
evaluate :: [Parse] → [Answer]
\end_layout

\begin_layout Standard
As the evaluation of each 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Parse
\end_layout

\end_inset

 will yield a list of multiple 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Answer
\end_layout

\end_inset

 (e.g.
 an anagram node of a five-letter word will evaluate to 120 different answers,
 although very few of them will be valid words), we can define 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
evaluate
\end_layout

\end_inset

as 
\end_layout

\begin_layout LyX-Code
evaluate = concatMap eval
\end_layout

\begin_layout Standard
where 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
evaluate
\end_layout

\end_inset

 will consume 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Parse
\end_layout

\end_inset

 data in the form 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Def Definition ParseTree AnswerLength
\end_layout

\end_inset

and produce 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
[Answer]
\end_layout

\end_inset

, where:
\end_layout

\begin_layout LyX-Code
data Answer = Answer String Parse
\end_layout

\begin_layout Standard
The parse is included along with the answer, as it contains the definition
 for that parse, which will later allow us to check that our generated answer
 has some relation to what we thought we were looking for in that parse,
 and also allows us to reconstruct the reasoning behind the clue by inspecting
 the parse tree.
\end_layout

\begin_layout Standard
We then define 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
eval
\end_layout

\end_inset

 as:
\end_layout

\begin_layout LyX-Code
eval (Def d pt l) = [Answer x (Def d pt l) |
\end_layout

\begin_layout LyX-Code
                                        x <- evalTree pt]
\end_layout

\begin_layout Standard
We can then define 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
evalTree
\end_layout

\end_inset

 in terms of the different types of node in our 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
ParseTree
\end_layout

\end_inset

 type.
 Those without subtrees will be defined simply with reference to a Haskell
 function that performs their action:
\end_layout

\begin_layout LyX-Code
eval_tree (AnagramNode ind xs) c = anagrams xs
\end_layout

\begin_layout LyX-Code
eval_tree (SynonymNode xs) = synonyms xs
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code
anagrams :: String -> [String] 
\end_layout

\begin_layout LyX-Code
anagrams [] = [[]] 
\end_layout

\begin_layout LyX-Code
anagrams xs = [x:ys | x<- nub xs, ys <- anagrams $ delete x xs]
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code
synonyms :: String -> [String] 
\end_layout

\begin_layout LyX-Code
synonyms xs = Map.lookup xs thesaurus
\end_layout

\begin_layout Standard
and so on.
 Clues with sub-trees are treated with a similar recursive call, with either
 a map, or a list comprehension applying the expressions function to each
 generated sub-answer
\end_layout

\begin_layout LyX-Code
eval_tree (ReversalNode ind ys) = map reverse (eval_tree ys)
\end_layout

\begin_layout LyX-Code
eval_tree (ConcatNode ind xs ys) = [x ++ y | x <- eval_tree xs
\end_layout

\begin_layout LyX-Code
                                           , y <- eval_tree ys]
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
Todo: there's probably space here to give each definition, since this really
 is the bread and butter of the whole affair
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Selection
\end_layout

\begin_layout Standard
Finally, given that we've produced our list of answers, most of which will
 be meaningless combinations of jumbled letters and synonyms pressed together,
 we need to filter down to the answer containing a string which in some
 way meets the criteria set for us in the clue, that is 1.
 finding an answer that is a synonym of the part of the clue we chose as
 the definition 2.
 being the right number of letters.
\end_layout

\begin_layout Standard
So we can define 
\end_layout

\begin_layout LyX-Code
choose :: [Answer] → Answer
\end_layout

\begin_layout LyX-Code
choose = head .
 filter valid 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code
valid (Answer ans (Def def pt len)) = (length ans == len) 
\end_layout

\begin_layout LyX-Code
                                      && (is_synonym ans def)
\end_layout

\begin_layout Standard
Of course, we may not have generated a valid solution, so we can redefine
 to include this uncertainty:
\end_layout

\begin_layout LyX-Code
choose :: [Answer] → Maybe Answer
\end_layout

\begin_layout LyX-Code
choose = headM .
 filter valid 
\end_layout

\begin_layout LyX-Code
\begin_inset Note Note
status open

\begin_layout LyX-Code

\end_layout

\begin_layout Plain Layout
6.
 Discussion of different clue types 
\end_layout

\begin_layout Plain Layout
6.1 Any interesting ones of note 
\end_layout

\begin_layout Plain Layout
Is there anything here?
\end_layout

\end_inset


\end_layout

\begin_layout Section
State space and performance analysis
\end_layout

\begin_layout Subsection
Overview - does it work? 
\end_layout

\begin_layout Standard
This approach has the required structure to correctly parse and solve most
 cryptic crossword clues — with some caveats.
 
\end_layout

\begin_layout Standard
Firstly, although in most cases the correct parse was generated, often the
 number of other parses to be evaluated before reaching the correct one
 was so great that the computation would effectively not end.
 In this case, the heap size wasn't continually growing, as each evaluation
 branched and then diminished in turn, but the running time was sufficiently
 large (>48hrs) such that the computation would be useless in a practical
 situation.
 The data for this is considered in 
\series bold
6.2
\end_layout

\begin_layout Standard
In other cases the correct parse was created, however the semantic data
 wasn't available to evaluate the clue correctly.
 In other, very rare cases, there is a clue which does not fit the structure
 of the grammar defined in 
\series bold
Part I
\series default
.
 These do not generate the correct parse trees, and so are not soluble.
 These are discussed in 
\series bold
6.3
\series default
.
\end_layout

\begin_layout Subsection
Correctly parsed and evaluated clues
\end_layout

\begin_layout Standard
Most clues, if they yield any results at all, yield them within 30 seconds
 of being run.
 Many others yield them a very long time afterwards – multiple hours of
 runtime is required to reach them.
 Others seem to run indefinitely.
 
\end_layout

\begin_layout Standard
Of those that do not terminate within an acceptable timeframe, the generated
 parse trees can be inspected and it can be shown that the correct one has
 been generated, and that since no individual evaluation takes infinite
 time, and each evaluation uses a non-problematic amount of stack space
 (that is to say –
\begin_inset space ~
\end_inset

the stack does not increase with each subsequent evaluation), then we can
 say that the clue is solvable, even if not in a reasonable amount of time.
 
\end_layout

\begin_layout Standard
The clue 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
FRIEND FOUND IN OKLAHOMA TERMINAL (4)
\end_layout

\end_inset

 yields the correct parse:
\end_layout

\begin_layout LyX-Code
Def "friend" (HiddenWordNode (HWIndicator ["found","in"]) 
\end_layout

\begin_layout LyX-Code
                                    ["oklahoma","terminal"])
\end_layout

\begin_layout Standard
however it also generates 59 others, including:
\end_layout

\begin_layout LyX-Code
Def "friend" (InsertionNode (IIndicator ["in"]) (SynonymNode "found") 
\end_layout

\begin_layout LyX-Code
               (ConsNode (SynonymNode "oklahoma") (SynonymNode "terminal")))
\end_layout

\begin_layout LyX-Code
Def "terminal" (InsertionNode (IIndicator ["in"]) 
\end_layout

\begin_layout LyX-Code
            (SynonymNode "friend found") (SynonymNode "oklahoma"))
\end_layout

\begin_layout LyX-Code
Def "oklahoma terminal" (ConsNode (SynonymNode "friend") 
\end_layout

\begin_layout LyX-Code
                                  (SynonymNode "found"))
\end_layout

\begin_layout LyX-Code
Def "terminal" (ConsNode (SynonymNode "friend") (ConsNode (SynonymNode "found")
 
\end_layout

\begin_layout LyX-Code
               (ConsNode (SynonymNode "in") (SynonymNode "oklahoma"))))
 
\end_layout

\begin_layout LyX-Code
Def "terminal" (ConsNode (ConsNode (SynonymNode "friend") 
\end_layout

\begin_layout LyX-Code
                         (SynonymNode "found")) (SynonymNode "in oklahoma"))
\end_layout

\begin_layout LyX-Code
Def "friend found" (SynonymNode "in oklahoma terminal") 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
Def "in oklahoma terminal" (ConsNode (SynonymNode "friend") 
\end_layout

\begin_layout LyX-Code
                                     (SynonymNode "found")) 
\end_layout

\begin_layout LyX-Code
Def "in oklahoma terminal" (SynonymNode "friend found") 
\end_layout

\begin_layout Standard
While evaluation of the correct parse takes 0.05 seconds, the evaluation
 of the first of the other examples takes over 10 seconds - it is the cumulative
 effect of the evaluation of the others, as well as the order in which they
 appear in the list which determines how long the total solving time takes.
 Some of these effects can been seen in 
\series bold
Figure 1.

\series default
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Leadup
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways true
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="6">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Clue
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Solution
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Clue Length
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
# Parses
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
# Evaluations
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Solve Time
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
COMPANION SHREDDED CORSET (6)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ESCORT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
148,500
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.2s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HOPE FOR HIGH PRAISE (6)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ASPIRE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
105,718,343
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.39s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MARIA NOT A FICKLE LOVER (9)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
INAMORATA
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
60
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
84,855,252
\begin_inset script superscript

\begin_layout Plain Layout
2
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

—
\begin_inset script superscript

\begin_layout Plain Layout
1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FRIEND FOUND IN OKLAHOMA TERMINAL (4)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MATE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
59
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
92,995,844
\begin_inset script superscript

\begin_layout Plain Layout
2
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

—
\begin_inset script superscript

\begin_layout Plain Layout
1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PAUSE AT THESE I FANCY (8)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HESITATE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
54
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5,358,615
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.59s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ANKLE WAS TWISTED IN BALLET (8)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SWAN LAKE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
84
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
203,991,525
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12.13s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
NOTICE SUPERVISOR IS GOING NUTS AT FIRST (4)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SIGN
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
853
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

—
\begin_inset script superscript

\begin_layout Plain Layout
3
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

—
\begin_inset script superscript

\begin_layout Plain Layout
1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ATTEMPT TO SECURE ONE POUND FOR A HAT (6)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TRILBY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2930
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

—
\begin_inset script superscript

\begin_layout Plain Layout
3
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

—
\begin_inset script superscript

\begin_layout Plain Layout
1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Solving statistics for selected clues on a 2014 MacBook Pro
\end_layout

\end_inset


\end_layout

\begin_layout Verse
\begin_inset VSpace bigskip
\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Verse
\begin_inset VSpace bigskip
\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset script superscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

 Although the correct parse was generated, and selective evaluation of that
 parse yielded the correct results (i.e.
 a solution would be available eventually), the normal solving procedure
 did not compute the correct answer within 48hrs of running time
\end_layout

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset script superscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

 Due to Haskell's lazy evaluation, this can sometimes be calculated without
 actually computing the solution
\end_layout

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset script superscript

\begin_layout Plain Layout
3
\end_layout

\end_inset

 Could not yield answer within 48hrs 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsubsection
The effect of clue length on the number of parses
\end_layout

\begin_layout Standard
The length of the clue has an exponential effect on the number of parses
 produced.
 This is due partly to the increasing number of ways in which binary trees
 can be constructed from N elements, as in:
\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "25col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.
 [.
 A B ] [.
 C D ]]
\end_layout

\end_inset

 
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "25col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.
 [.A ] [.
 [ B C ] D ]]
\end_layout

\end_inset

 
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "25col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.
 [.
 A [.
 B C ]] [.D ]]
\end_layout

\end_inset

 
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "25col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.
 [.A ] [.
 B [.
 C D ] ]]
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "25col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.
 [.
 [.
 A B ] [.C ]] [.D ]]
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It also increases the availability for function words to interact with each
 other - when any A, B, C, or D in the examples above also have multiple
 parses, this is when we see the strongly trended exponential growth seen
 in 
\series bold
Figure 2 
\series default
(displayed on a logarithmic scale).
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename results/clue-length-to-parses.pdf
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Number of parses generated for varying clue lengths over 600 sample clues
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
The effect of clue length on the number of evaluations
\end_layout

\begin_layout Standard
We see a similar but even greater effect on the number of evaluations, with
 the effect of the exponential growth per parse compounded by the fact that
 each parse can evaluate out to to thousands of options.
 This is due to two effects, Firstly, clues types like anagrams can have
 many thousand evaluations per parse (there are 120 anagrams of a 5-letter
 word, rising to 40,320 anagrams of an eight letter word).
 Secondly, compound clues like insertions, which can take the result of
 one wordplay and insert into the second, can magnify the effect of branching
 in its sub-clues.
 
\end_layout

\begin_layout Standard
There are 4 ways that a word 'A' can be inserted into a 5-letter word 'B'.
 There are 480 ways that it can be inserted into each of the 120 anagrams
 of word 'B', and if there are also 120 different anagrams of word 'A',
 then there are 57600 different evaluations for that parsed arrangement.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.CONCATENATE [.CONCATENATE A B ] [.C ]]
\end_layout

\end_inset

 
\begin_inset Graphics
	filename results/clue-length-to-evaluations evaluations.pdf
	width 100col%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Number of evaluations generated for varying clue lengths over 75 sample
 clues
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The size of the thesaurus has a large impact on the number of evaluations
 produced, as all clue types (other than Anagram, Hidden Word and Initials,
 which use String) use Synonym as the lowest level node in their sub-trees.
\end_layout

\begin_layout Standard

\series bold
Figure 4
\series default
 (also displayed on a logarithmic scale) shows how limiting the number of
 synonyms returned by the thesaurus affects the number of evaluations.
 The graph plateaus as the restriction exceeds the actual number of synonyms
 per entry for each word in the thesaurus.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename results/evals_vs_dictionary.pdf
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Number of evaluations generated by restricting the maximum thesaurus length
 for the clue 
\begin_inset Quotes eld
\end_inset

Good opportunity in school
\begin_inset Quotes erd
\end_inset

 (5)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Analysis of selected clues which are not correctly solved
\end_layout

\begin_layout Standard
It is difficult to perform a large-scale analysis of the numbers of clues
 for which the data does not exist, or where the correct parse is not generated,
 as often these will present themselves in the same way as the correct clues
 with too large a search space, that is by not terminating within an acceptable
 time.
 
\end_layout

\begin_layout Standard
These clues are therefore presented as an illustrative sample of the sorts
 of errors that prevent correct parse (
\series bold
6.3.4
\series default
) or correct evaluation (
\series bold
6.3.1 –
\begin_inset space ~
\end_inset

6.3.3) 
\series default
being generated.
\end_layout

\begin_layout Subsubsection
SHINY SILVER PAPER IN THE STREET (8)  (= 
\begin_inset Quotes eld
\end_inset

AGLITTER
\begin_inset Quotes erd
\end_inset

) [Guardian]
\end_layout

\begin_layout Standard
Although the correct parse is generated ([SILVER] + [PAPER IN THE STREET]),
 some natural language analysis would be required to derive the fact that
 
\begin_inset Quotes eld
\end_inset

PAPER IN THE STREET
\begin_inset Quotes erd
\end_inset

 = 
\begin_inset Quotes eld
\end_inset

litter
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
PLAYWRIGHT AT HOME HAVING CAUGHT DISEASE (5) (="IBSEN
\begin_inset Quotes erd
\end_inset

) [Everyman]
\end_layout

\begin_layout Standard
This clue requires two pieces of category knowledge, firstly that Ibsen
 is a member of the set of playwrights (and not a synonym for playwright),
 and that BSE is a member of the set of diseases 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
HE SCORED HARLEM WINDS (6)   (= 
\begin_inset Quotes eld
\end_inset

MAHLER
\begin_inset Quotes erd
\end_inset

) [Guardian]
\end_layout

\begin_layout Standard
Not only is knowledge of composer Gustav Mahler required, but also a cryptic
 understanding that 'HE SCORED' can refer to a member of the set of male
 composers.
 Note that this is structurally different from the examples above: while
 (1) was a more oblique version of a synonym (litter 
\series bold
is
\series default
 paper on the street), and (2) is membership of the set of of playwrights,
 we must now consider the set of people who fit the description 
\begin_inset Quotes eld
\end_inset

he scored
\begin_inset Quotes erd
\end_inset

, which may include composers, sportsmen, and maybe even engravers.
 
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
WHERE AND HOW A SUPERHERO MIGHT LABEL HIS FAUCET (4) (= 
\begin_inset Quotes eld
\end_inset

BATH
\begin_inset Quotes erd
\end_inset

) [Guardian]
\end_layout

\begin_layout Standard
This clue requires not just specialist knowledge, but also natural language
 parsing of the sentence of a whole.
 The answer can be derived from the concept that the superhero Batman would
 append bat- onto the names of objects (batmobile, etc.), and that a hot
 tap (or faucet) might be labeled H, so his faucet might be labelled BAT-H.
 
\end_layout

\begin_layout Standard
Along with that, the definition bears reference to the clue as a whole,
 and may be properly expanded as: 
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout --Separator--
\begin_inset Flex Code
status open

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

definition
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

wordplay
\end_layout

\end_inset


\end_layout

\begin_layout Address
\begin_inset Formula $\noindent\mathtt{\overbrace{where\, a\, superhero\, might\, label\, his\, faucet}\:\mathit{and}\,\overbrace{how\, a\, superhero\, might\, label\, his\, faucet}}$
\end_inset

   
\end_layout

\begin_layout Address
This clue represents the upper level of challenge for a computer based solver,
 being unique structure, self referential, using very specialist knowledge
 and oblique humour.
 
\end_layout

\begin_layout Part
Optimizations
\end_layout

\begin_layout Section
Algebraic + computational simplifications 
\end_layout

\begin_layout Subsection
Pruning out equivalent trees (Canonization) 
\end_layout

\begin_layout Subsubsection
Motivation
\end_layout

\begin_layout Standard
One large factor in the rapid proliferation is in the our binary tree representa
tion of concatenation.
 While keeping them in a similar representation to the rest of the expression
 nodes in our naive solution kept their representation in a similar form
 to the rest of the nodes, the fact that no indicator is required to generate
 a concatenation node means that any expression of two ore more words can
 generate them.
 
\end_layout

\begin_layout Standard
The number of trees with n leaves is given by the (n-1)
\begin_inset script superscript

\begin_layout Plain Layout
th
\end_layout

\end_inset

 Catalan number
\begin_inset Foot
status open

\begin_layout Plain Layout
Catalan numbers are given by the formula 
\begin_inset Formula $C_{n}=\frac{1}{n+1}{2n \choose n}=\frac{(2n)!}{(n+1)!\, n!}=\prod\limits _{k=2}^{n}\frac{n+k}{k}\qquad\mbox{ for }n\ge0.$
\end_inset


\end_layout

\end_inset

, so ignoring any other type of expression (anagram, etc.), for a clue of
 length n we have 
\begin_inset Formula $C_{n-1}$
\end_inset

 trees created with each of the clue words taken as a synonym node.
 This number grows rapidly as the clue length increases, and yields an increasin
gly large number of parses.
 
\end_layout

\begin_layout Standard
Due to the associativity of concatenation, each of these parses evaluates
 to an identical output:
\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.CONCATENATE [.CONCATENATE A B ] [.C ]]
\end_layout

\end_inset

 
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "8col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
and
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.CONCATENATE [.A ] [.CONCATENATE B C ] ]
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
both yield the output 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
ABC
\end_layout

\end_inset

.
 This means that much of our outputted parses are identical and therefore
 redundant.
\end_layout

\begin_layout Standard
One strategy to deal with this would be to perform canonization on the trees,
 and prune all concatenation trees which don't conform to our decided 'ideal
 tree'.
 For example, we could choose to create a right-handed binary tree, wherein
 trees such as:
\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.CONCATENATE [.CONCATENATE A B ] [.CONCATENATE C D ]]
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
would become
\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.CONCATENATE [.A ] [.CONCATENATE [.B ] [.CONCATENATE C D ]]]
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The problem with this solution is that we need to look ahead while parsing:
 the above parse only is acceptable if the parse of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
A
\end_layout

\end_inset

 also doesn't produce a concatenation – this means we can't parse recursively
 as before.
 
\end_layout

\begin_layout Subsubsection
Implementation
\end_layout

\begin_layout Standard
We can instead define a new version of our Concatenation Nodes which, instead
 of describing a binary tree by storing the data as two parsetrees:
\end_layout

\begin_layout LyX-Code
data ParseTree = ConcatNode ParseTree ParseTree | [...]
\end_layout

\begin_layout Standard
structured as:
\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.CONCATENATE [.CONCATENATE A B ] [.CONCATENATE C D ]]
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code
 (as well as 4 other equivalent trees)
\end_layout

\end_deeper
\begin_layout Standard
instead stores it as a forest, i.e.
 a list of trees –
\end_layout

\begin_layout LyX-Code
data ParseTree = ConcatNode ParseForest | [...]
\end_layout

\begin_layout LyX-Code
type ParseForest = [ParseTree]
\end_layout

\begin_layout Standard
structured as:
\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.CONCATENATE {[A B C D]} ]
\end_layout

\end_inset

 
\end_layout

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
We define a new version of parseConcatNodes to reflect the new structure.
 This time, instead of considering all the ways to partition the wordplay
 of the clue into two parse, and subsequently combining each of the different
 parses of both of them, this time we need to consider all the ways to partition
 the string (which  
\end_layout

\begin_layout LyX-Code
parseConcatNodes' :: String -> [ParseTree] 
\end_layout

\begin_layout LyX-Code
parseConcatNodes' xs n = let parts = partitions xs 
\end_layout

\begin_layout LyX-Code
       in [ConcatNode ys | part <- parts
\end_layout

\begin_layout LyX-Code
                 , (length part) > 1
\end_layout

\begin_layout LyX-Code
                 , ys <- [sequence .
 map parseClue $ part]  ] 
\end_layout

\begin_layout Standard
the Prelude function 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
sequence
\end_layout

\end_inset

, which has the type 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
sequence :: Monad m => [m a] -> m [a]
\end_layout

\end_inset

, which when applied to a list of lists will provide all lists comprising
 of an element from each sublist:
\end_layout

\begin_layout LyX-Code
sequence [ [1,2,3], [40,50], [666,777,888] ] =
\end_layout

\begin_layout LyX-Code
  [ [1,40,666],[1,40,777],[1,40,888],[1,50,666],[1,50,777],
\end_layout

\begin_layout LyX-Code
    [1,50,888],[2,40,666],[2,40,777],[2,40,888],[2,50,666],
\end_layout

\begin_layout LyX-Code
    [2,50,777],[2,50,888],[3,40,666],[3,40,777],[3,40,888],
\end_layout

\begin_layout LyX-Code
    [3,50,666],[3,50,777],[3,50,888] ]
\end_layout

\begin_layout Subsubsection
Avoiding Nesting
\end_layout

\begin_layout Standard
Unfortunately, this solution alone will not prevent us from creating a forest
 of parse trees that itself contains a concatenation node:
\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.CONCATENATE [.{[A CONCATENATE D]} {B C} ]]
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Verse
leading to a even more parse trees than before!
\end_layout

\begin_layout Standard
In order to prevent our new concatenation nodes nesting again we need to
 define a version of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
parseClue
\end_layout

\end_inset

 which doesn't generate concatenation nodes:
\end_layout

\begin_layout LyX-Code
parseClueNoConcat :: String -> [ParseTree] 
\end_layout

\begin_layout LyX-Code
parseClueNoConcat ys = let len = length .
 words $ ys in
\end_layout

\begin_layout LyX-Code
  [SynonymNode ys]    
\end_layout

\begin_layout LyX-Code

\strikeout on
  ++ (if len > 1 then parseConcatNodes ys else [] )  
\end_layout

\begin_layout LyX-Code
  ++ (if len > 1 then parseAnagramNodes ys else [] )   
\end_layout

\begin_layout LyX-Code
  ++ (if len > 1 then parseHiddenWordNodes ys else [])   
\end_layout

\begin_layout LyX-Code
  ++ (if len > 2 then parseInsertionNodes ys else [])   
\end_layout

\begin_layout LyX-Code
  ++ (if len > 2 then parseSubtractionNodes ys else [])   
\end_layout

\begin_layout LyX-Code
  ++ (if len > 1 then parseReversalNodes ys else [])  
\end_layout

\begin_layout LyX-Code
  ++ (if len > 1 then parseFirstLetterNodes ys else [])   
\end_layout

\begin_layout LyX-Code
  ++ (if len > 1 then parseLastLetterNodes ys else [])   
\end_layout

\begin_layout LyX-Code
  ++ (if len > 1 then parsePartialNodes ys else [])
\end_layout

\begin_layout Standard
and re-define our original 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
parseClue
\end_layout

\end_inset

 as
\end_layout

\begin_layout LyX-Code
parseClue :: String -> [ParseTree] 
\end_layout

\begin_layout LyX-Code
parseClue (Def def ys n) = let len = length .
 words $ ys in
\end_layout

\begin_layout LyX-Code
  parseClueNoConcat ys  
\end_layout

\begin_layout LyX-Code
  ++ (if len > 1 then parseConcatNodes ys else [] ) 
\end_layout

\begin_layout Subsubsection
Improvement Analysis
\end_layout

\begin_layout Standard
By cleaning up the redundancy in our different parses, we can improve our
 parsing function from exponential growth against clue length, to a low
 quadratic growth, as can be seen in 
\series bold
Figure 5
\series default
 and 
\series bold
Figure 6
\series default
.
 As each parse may have thousands of solutions, this should represent a
 significant improvement in the number of outputs, and so the solve time,
 of each clue.
\end_layout

\begin_layout Verse
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename results/parses-original-canonical large-scale.pdf
	width 100col%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Average number of parses before and after canonization by clue length, averaged
 over 710 clues
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename results/parses-original-canonical logarithmic.pdf
	width 100col%

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.CONCATENATE [.{[A CONCATENATE D]} {B C} ]]
\end_layout

\end_inset

 
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Average number of parses before and after canonization by clue length, averaged
 over 710 clues, on a logarithmic scale
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Heuristics from Human Solvers
\end_layout

\begin_layout Standard
We can take cues for further improvements to our solving process by considering
 the heuristics that a human solver uses to navigate the huge state space
 and find the correct solution without having to check hundreds and thousands
 of possible solutions.
\end_layout

\begin_layout Subsection
Filter parses by output length
\end_layout

\begin_layout Subsubsection
Motivation
\end_layout

\begin_layout Standard
Here we seek to mimic the following thought processes of a human solver:
\end_layout

\begin_layout Quotation

\shape italic
\begin_inset Quotes eld
\end_inset

This can't be an anagram of that word, as that'd only make 6 letters, and
 the clue is 9
\begin_inset Quotes erd
\end_inset


\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_deeper
\begin_layout Quotation

\shape italic
\begin_inset Quotes eld
\end_inset

We can't have an insertion here, as we've already got 5 letters, and so
 if we add another 5 then it's too long
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
These are constraints on the parses that we can generate based on an understandi
ng of the maximum and minimum number of letters than a given reading of
 a clue could produce.
 In the first example, a clue such as
\end_layout

\begin_layout LyX-Code
Report coarse players (9)
\end_layout

\begin_layout Standard
could identify 'coarse' as a possible anagram indicator, and yield a parse
 such as
\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.{ANAGRAM (=coarse)} "report" ]
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This, however, can never yield a solution that is 9 letters long, so a human
 solver, and so our improved computer solver, will not consider it for further
 evaluation.
\end_layout

\begin_layout Standard
In the second example, we see that we may also need to consider the parse
 recursively to calculate the total length parameters: 
\end_layout

\begin_layout LyX-Code
Punch’s dog in play about bishop (4) 
\end_layout

\begin_layout Standard
can be parsed to
\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.{INSERTION (=in)} [.SYNONYMN {"punch's dog"} ] [.{REVERSAL (=about)}
 "play" ] ]
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since the reversal of play ('yalp') is already 4 letters long, we can see
 that which ever word we choose to signify 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
punch's dog
\end_layout

\end_inset

 will increase the length of the evaluated solution over the prescribed
 solution length of 4.
\end_layout

\begin_layout Subsubsection

\series bold
Implementation
\end_layout

\begin_layout Standard
We can recursively evaluate a parse to determine its maximum and minimum
 lengths, to check that the maximum is at least as big as the desired output
 length, and the minimum is at least as small.
\end_layout

\begin_layout Standard
We define the functions 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
minLength
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
maxLength
\end_layout

\end_inset

 :
\end_layout

\begin_layout LyX-Code
minLength :: ParseTree -> Int 
\end_layout

\begin_layout LyX-Code
minLength (ConcatNode trees) = (sum .
 map minLength) trees 
\end_layout

\begin_layout LyX-Code
minLength (SynonymNode string) = let x = 
\end_layout

\begin_layout LyX-Code
             minimum ( map length (string : syn string)) in x
\end_layout

\begin_layout LyX-Code
minLength (AnagramNode ind strings) = (length .
 concat) strings 
\end_layout

\begin_layout LyX-Code
minLength (HiddenWordNode ind strings) = 2 
\end_layout

\begin_layout LyX-Code
minLength (InsertionNode ind tree1 tree2) = (minLength tree1) 
\end_layout

\begin_layout LyX-Code
                                           + (minLength tree2) 
\end_layout

\begin_layout LyX-Code
minLength (SubtractionNode ind tree1 tree2) = minimum[
\end_layout

\begin_layout LyX-Code
                          (minLength tree2) - (maxLength tree1),1]
\end_layout

\begin_layout LyX-Code
-- and definitions for other clue types
\end_layout

\begin_layout Standard
Some clue types are can be defined directly from their inputs – both the
 maxium and minium length of an anagram node is the lenght of the input
 string – while an insertion node need to be defined based on the maxium
 and minimum of the two subtrees.
\end_layout

\begin_layout Standard
Notable is that here we see some 'contextual bleed' from evaluation across
 into the parsing, as we consider the semantics of what the thesaurus could
 yield for a synonym node in determining its minimum length.
\end_layout

\begin_layout Standard
It's also worth noting that sometimes we need to make a judgement: what
 is the minimum that a Hidden Word could yield? 
\end_layout

\begin_layout Standard
From these definitions, and similar ones for maxLength, we can check a parse
 for validity.
 
\end_layout

\begin_layout LyX-Code
valid_parse_length :: Parse -> Bool 
\end_layout

\begin_layout LyX-Code
valid_parse_length (Def d clue n) = (minLength clue <= n) 
\end_layout

\begin_layout LyX-Code
                                 && (maxLength clue >= n) 
\end_layout

\begin_layout Standard
and so redefine parse as 
\end_layout

\begin_layout LyX-Code
parse = filter valid_parse_Length .
 concatMap parseClue 
\end_layout

\begin_layout Subsubsection
Analysis
\end_layout

\begin_layout Standard

\series bold
Figure 7
\series default
 shows the effect on number of parses generated following the addition of
 the parse length constraints.
 
\end_layout

\begin_layout Standard
This filtering constraint now means that many clues now yield 0 parses.
 Some of these are clues that could never be correctly parsed, while some
 are clues which we can generate correct parses, but do not have the thesaurus
 and synonym data to solve the clue.
 
\end_layout

\begin_layout Standard
This transformation is, though, safe – any parse that previously would have
 generated the correct answer will not be filtered out.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename results/parse-lengths-constrained ConstrainParse.pdf
	width 100col%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Average number of parses before and after canonization by clue length, averaged
 over 710 clues, on a logarithmic scale
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Taking Advantage of Lazy Evaluation
\end_layout

\begin_layout Subsubsection
Motivation
\end_layout

\begin_layout Standard
Although we are now generating far fewer parses, we still have some solveable
 clues generating 100+ parses.
 This means that for these clues we will have to perform on average 
\begin_inset Formula $n/2$
\end_inset

 evaluations – lazy evaluation means that our use of the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
head
\end_layout

\end_inset

 with 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
filter
\end_layout

\end_inset

will yield the first result computed from the head of the list toward the
 tail.
 
\end_layout

\begin_layout Standard
We could take further advantage of the intuition that some parses are more
 likely, given the input words.
 For instance in the clue 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Lowest point in ruptured drain (5)
\end_layout

\end_inset

, we see the angram indicator 'ruptured' next to a 5 letter word:
\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.{ANAGRAM (=RUPTURED)} drain ]
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
with the definition 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
lowest point
\end_layout

\end_inset

, intuitively feels more likely than 
\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.CONCATENATION [.CONCATENATION [.SYN lowest ] [.SYN point ] ] [.CONCATENATION
 [.SYN in ] [.SYN ruptured ]  ] ]
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
cluing the definition 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
drain
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
More formally, we're looking for a heuristic which weights toward consuming
 words into indicators for more 'interesting' clue types: in that clues
 using expressions more varied than synonym and concatenation are considered
 better clues, and so are more likely than not if they are an available
 parse.
 
\end_layout

\begin_layout Standard
Furthermore, these expressions consume more of the string in indicators
 than other types (reversal nodes consume one word from the clue as its
 indicator, while synonyms and concatenation both don't consume any indicators)
\begin_inset Note Note
status open

\begin_layout Plain Layout
Diagram to show this
\end_layout

\end_inset

 and are less likely to produce nested parse trees (both anagrams and hidden
 word nodes treat their input as a pure string to be transformed, and so
 do not generate any nested parse trees).
 This means that clues featuring these types tend to be less complex.
 
\end_layout

\begin_layout Standard
Both of these factors make them good candidates to evaluate sooner than
 other options.
\end_layout

\begin_layout Subsubsection
Implementation
\end_layout

\begin_layout Standard
We define a method 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
cost
\end_layout

\end_inset

 which gives a weighting to a given ParseTree
\end_layout

\begin_layout LyX-Code
cost :: ParseTree -> Int 
\end_layout

\begin_layout LyX-Code
cost (ConcatNode trees) = 2 * (length trees) + sum (map cost trees) 
\end_layout

\begin_layout LyX-Code
cost (AnagramNode ind strings) = 1 
\end_layout

\begin_layout LyX-Code
cost (HiddenWordNode ind strings) = 4 
\end_layout

\begin_layout LyX-Code
cost (InsertionNode ind tree1 tree2) = 4 + cost tree1 + cost tree2 
\end_layout

\begin_layout LyX-Code
cost (SubtractionNode ind tree1 tree2) = 3 + cost tree1 + cost tree2 
\end_layout

\begin_layout LyX-Code
cost (ReversalNode ind tree) = 2 + cost tree 
\end_layout

\begin_layout LyX-Code
cost (SynonymNode string) = 8 * length (words string) 
\end_layout

\begin_layout LyX-Code
cost (FirstLetterNode ind strings) = 2 
\end_layout

\begin_layout LyX-Code
cost (LastLetterNode ind strings) = 2 
\end_layout

\begin_layout LyX-Code
cost (PartialNode ind tree) = 6 + cost tree
\end_layout

\begin_layout Standard
we can then define
\end_layout

\begin_layout LyX-Code
cost_parse :: Parse -> Int
\end_layout

\begin_layout LyX-Code
cost_parse (DefNode s tree n) = cost tree * (length_penalty s) 
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

length_penalty :: String -> Int
\end_layout

\begin_layout LyX-Code
length_penalty ws = 60 + (length (words ws)) 
\end_layout

\begin_layout Standard
which can then be integrated into our definition of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
parse
\end_layout

\end_inset

:
\end_layout

\begin_layout LyX-Code
parse = sortBy cost_parse .
 filter valid_parse_length .
 concatMap parseClue
\end_layout

\begin_layout Standard
It should be noted that the weights here are intuitive only.
 
\end_layout

\begin_layout Standard
Synonym nodes have a high weighting against consuming long lists of words
 – this is to prevent them from being low scoring (as they consume large
 portions the clue) while being unlikely to yield the correct answer.
 
\end_layout

\begin_layout Subsubsection
Analysis
\end_layout

\begin_layout Standard
The weighting above mean that the correct parse had the highest score in
 70% of the clues that the system can solve, as opposed to approximately
 10% when not sorted by weight.
 In cases where the clue can not be solved, the order of the parses is irrelevan
t.
 
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
Generate much more data for this and display in a nice way.
 
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: generate much more data for this and display in a nice way
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Determining a correct weighting 
\end_layout

\begin_layout Standard
While the current weighting given has been developed though trial and error
 to be reasonably successful, a more structured approach to detemining the
 correct weighting could generate even better results.
 Using a large dataset of clues and the correct parses, hill climbing or
 statistical analysis of clue types could produce optimal numbers.
\end_layout

\begin_layout Subsection
Constrain length while evaluating 
\end_layout

\begin_layout Subsubsection
Motivation
\end_layout

\begin_layout Standard
While evaluating a parse tree of a given clue, we expect the overall length
 of the generated solution to be equal to the length specified in the clue.
 Furthermore, while evaluating different sub-trees of a given parse tree
 – either different branches of a concatenation list, or the two constituent
 parts of an insertion or subtraction experession – the solutions generated
 from one influence and limit what can be generated from the others.
 
\end_layout

\begin_layout Standard
For example, in the clue 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Story about bishop and food (5)
\end_layout

\end_inset

, if we are evaluating the parse 
\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.{INSERTION (=about)} [.SYN "story" ] [.SYN "bishop" ] ]
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
then the partial evaluation of the left hand branch to one of its possible
 evaluations
\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.{INSERTION (=about)} [."TALE" ] [.SYN "bishop" ] ]
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
means that as the subsequent evalaution of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
SYN 
\begin_inset Quotes eld
\end_inset

bishop
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 should only yield solutions that are one-letter one, in order to stay within
 the constraint of a five-letter solution.
 If we can successfully apply this constraint, then we can limit the subsequent
 evaluations of this partial parse tree to one or two, rather than the order
 of 100.
\end_layout

\begin_layout Subsubsection

\series bold
Implementation
\end_layout

\begin_layout Standard
In the example above, we see the length constraints preventing overflow
 - that is, a maximum length which the generated solution should not exceed.
 We also need to constrain against 'underflow', wherein the evaluation fails
 to yield enough letters to fit the solution.
 Constraining both maximum and minimum length will have the effect of forcing
 the generated solution length to be equal to the prescribed length.
\end_layout

\begin_layout Standard
We can therefore define a datatype to carry both of these constraints.
 
\end_layout

\begin_layout LyX-Code
newtype Constraints = Constraints MaxLength MinLength
\end_layout

\begin_layout Standard
In some cases, we will not be able to prescribe a definite maximum length
 for a clue: in the case of a subtraction expression of parse trees A and
 B, where the evaluation of tree A will have the evaluation of B removed
 from it to yield the final solution, the length of clue A will exceed the
 overall solution length by an amount only limited by the length of B.
 
\end_layout

\begin_layout Standard
We also, then define 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
MaxLength
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
MinLength
\end_layout

\end_inset

 as new datatypes.
 
\end_layout

\begin_layout LyX-Code
data MaxLength = Max Int | NoMax 
\end_layout

\begin_layout LyX-Code
data MinLength = Min Int | NoMin
\end_layout

\begin_layout Standard
Although we could use the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Maybe
\end_layout

\end_inset

 monad here, by defining our own datatype we can subsequently take advantage
 of Haskell's type class system later on to allow us to treat these, and
 other constraints, in a similar way.
 
\end_layout

\begin_layout Standard
We define 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
is_lte_max
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
is_gte_min
\end_layout

\end_inset

 to account for both the case when we have a defined constraint (e.g.
 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Max 3
\end_layout

\end_inset

), as well as when we have no constraint (e.g.
 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
NoMax
\end_layout

\end_inset

):
\end_layout

\begin_layout LyX-Code
is_lte_max :: MaxLength -> Int -> Bool
\end_layout

\begin_layout LyX-Code
is_lte_max (Max mx) n = n <= mx 
\end_layout

\begin_layout LyX-Code
is_lte_max NoMax n = True
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
is_gte_min :: MinLength -> Int -> Bool
\end_layout

\begin_layout LyX-Code
is_gte_min (Min mn) n = n >= mn 
\end_layout

\begin_layout LyX-Code
is_gte_min NoMin n = True
\end_layout

\begin_layout Standard
We can define a typeclass 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Constraint
\end_layout

\end_inset

 which gives us the ability to define the method for checking if a given
 string fits a constraint of either type.
\end_layout

\begin_layout LyX-Code
class Constraint c where 
\end_layout

\begin_layout LyX-Code
    fits :: c -> String -> Bool 
\end_layout

\begin_layout LyX-Code
instance Constraint MaxLength where 
\end_layout

\begin_layout LyX-Code
    fits mx s = is_lte_max mx (length s) 
\end_layout

\begin_layout LyX-Code
instance Constraint MinLength where 
\end_layout

\begin_layout LyX-Code
    fits mn s = is_gte_min mn (length s) 
\end_layout

\begin_layout Standard
which subsequently allows us to write a function to check if a given output
 string fits the each of the constraints:
\end_layout

\begin_layout LyX-Code
fits_max (Constraints mx mn) x = fits mx x
\end_layout

\begin_layout LyX-Code
fits_min (Constraints mx mn) x = fits mn x
\end_layout

\begin_layout Standard
and so can define an overall function for checking a string against all
 our constraints:
\end_layout

\begin_layout LyX-Code
fits_constraints c x = (fits_max c x) && (fits_min c x)
\end_layout

\begin_layout Standard
This allows us to start to redefine our definitions of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
eval_tree
\end_layout

\end_inset

, with the new type signature
\end_layout

\begin_layout LyX-Code
eval_tree :: ParseTree -> Constraints -> [String]
\end_layout

\begin_layout Standard
For simple synonym nodes, we can apply the check in a straightforward manner,
 as there are no subtrees to evaluate.
\end_layout

\begin_layout LyX-Code
eval_tree (SynonymNode xs) c = filter (fits_constraints c) (synonyms xs)
\end_layout

\begin_layout Standard
For anagram nodes, redefining in the same way, as 
\end_layout

\begin_layout LyX-Code
eval_tree (AnagramNode xs) c = filter (fits_constraints c) (anagrams xs)
\end_layout

\begin_layout Standard
would still require the costly computation of all our anagrams.
 Instead, we can use our min and max criteria on the input string to check
 if it's worth evaluating at all: 
\end_layout

\begin_layout LyX-Code
eval_tree (AnagramNode xs) c = if ((fits_max c xs) && (fits_min c xs))
\end_layout

\begin_layout LyX-Code
                               then filter (fits_constraints c) (anagrams
 xs)
\end_layout

\begin_layout LyX-Code
                               else []
\end_layout

\begin_layout Standard
While here the first line could be replaced with if 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
fits_constraints c xs
\end_layout

\end_inset

, we avoid this, as it's only due to the fact that angrams preserve length
 that the max and min constraints are applicable to the initial string as
 a filter for its output.
 Once we add other constraints later which aren't preserved over the anagram
 operation (anything involving letter order!) then we would violate this
 condition.
\end_layout

\begin_layout Standard
Often, we will want to change the constraints on the evaluation of the subtrees
 in a parse tree.
 For example in the clue 
\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.{PARTIAL} [.SYN "word" ] ]
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
we can't easily define a maximim length for our evaluation of synonym, as
 an unspecified amount of letters will be removed when we apply the Partial
 expression.
 We need to define function which modifies our constraints to remove the
 maximum length constraint, as well as a similar one for the minimum:
\end_layout

\begin_layout LyX-Code
noMax :: EvalConstraints -> EvalConstraints 
\end_layout

\begin_layout LyX-Code
noMax (Constraints p mx mn) = (Constraints p NoMax mn)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
noMin :: EvalConstraints -> EvalConstraints 
\end_layout

\begin_layout LyX-Code
noMin (Constraints p mx mn) = (Constraints p mx NoMin)
\end_layout

\begin_layout Standard
we can then define the eval_tree function for partial nodes as
\end_layout

\begin_layout LyX-Code
eval_tree (PartialNode ind y) c =  
\end_layout

\begin_layout LyX-Code
      filter (fits_constraints c) .
 concatMap partials $ eval_tree y (noMax c) 
\end_layout

\begin_layout Standard
For our concatentation nodes, the requirement is slightly more complex,
 as the constraints imposed on the parse of any one tree depend on the each
 possible evaluation of all the other possible trees in the forest.
 In a simple example: From a clue such as
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Outspoken shocking court (6)
\end_layout

\end_inset

, we take a parse such as
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setbox
\backslash
partbox=
\backslash
hbox{
\backslash
Tree [.SYN shocking ] } 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setbox
\backslash
partboxx=
\backslash
hbox{
\backslash
Tree [.SYN court ] } 
\end_layout

\end_inset


\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
qroof{
\backslash
usebox{
\backslash
partbox}  
\backslash
usebox{
\backslash
partboxx} }.CONCAT  
\end_layout

\end_inset

 
\end_layout

\end_inset


\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
and look at the evaluation criteria at each stage.
 The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
ConcatNode
\end_layout

\end_inset

 will be given the constraints 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Max 6 Min 6
\end_layout

\end_inset

.
 We will the start to parse the subtrees in the forest of the concatenation.
 Parsing left-to-right, we parse the left 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
SynonymNode
\end_layout

\end_inset

 subtree with the constraints 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Max 6 NoMin
\end_layout

\end_inset

.
 Two of the partial evalautions we might come to are:
\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\align center
1.
 
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
qroof{ "dire"  
\backslash
usebox{
\backslash
partboxx} }.CONCAT  
\end_layout

\end_inset

 
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "5col%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Plain Layout
and
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\align center
2.
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
qroof{ "lousy"  
\backslash
usebox{
\backslash
partboxx} }.CONCAT  
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can see here that in partial evalaution 1, the constraints that we need
 to apply to the right 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
SynonymNode
\end_layout

\end_inset

 will be 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Max 2 NoMin
\end_layout

\end_inset

, whereas in 2, it will be 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Max 1 NoMin
\end_layout

\end_inset

.
 This means we will need to evaluate each subtree in the forest of a concatenati
on expression with different constraints depending on the outcomes of the
 evaluation of previous evaluations.
 
\end_layout

\begin_layout Standard
We define a function to allow us to decrease the maximum length constraint
 as we go further down the list (and also similar for increasing, and for
 changing the min constraint).
\end_layout

\begin_layout LyX-Code
decreaseMax :: Int -> EvalConstraints -> EvalConstraints 
\end_layout

\begin_layout LyX-Code
decreaseMax n (Constraints (Max mx) mn) = Constraints  (Max (mx - n)) mn
 
\end_layout

\begin_layout LyX-Code
decreaseMax n (Constraints NoMax mn) = Constraints NoMax mn 
\end_layout

\begin_layout Standard
and a function which updates the constraints given a string we've just generated
:
\end_layout

\begin_layout LyX-Code
add_partial :: String -> EvalConstraints -> EvalConstraints 
\end_layout

\begin_layout LyX-Code
add_partial x c = decreaseMax (length x) c 
\end_layout

\begin_layout Standard
So in this example, applying the function 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
add_partial 
\begin_inset Quotes eld
\end_inset

dire
\begin_inset Quotes erd
\end_inset

 (Constraints Max 6 NoMin)
\end_layout

\end_inset

 will give the correct constraints for the second tree's evaluation: 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Max 2 NoMin
\end_layout

\end_inset

.
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
We can then define a function 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
eval_trees
\end_layout

\end_inset

 that will handle passing the right constraints down the list of 
\end_layout

\begin_layout LyX-Code
eval_trees :: [ParseTree] -> EvalConstraints -> [String] 
\end_layout

\begin_layout LyX-Code
eval_trees (x:[]) c = eval_tree x  c 
\end_layout

\begin_layout LyX-Code
eval_trees (x:xs) c = 
\end_layout

\begin_layout LyX-Code
       let starts = [start | start <- eval_tree x (noMin c)]  
\end_layout

\begin_layout LyX-Code
         -- Generate options for the first in our list
\end_layout

\begin_layout LyX-Code
       in concatMap f $ starts 
\end_layout

\begin_layout LyX-Code
         -- For each option, evaluate the rest with updated constraints
\end_layout

\begin_layout LyX-Code
       where f start = map (
\backslash
x -> start ++ x) (eval_trees xs (apply_partial start c))
\end_layout

\begin_layout LyX-Code
         -- Append from each possible evaluation, after updating constraints
 
\end_layout

\begin_layout Standard
overall 
\end_layout

\begin_layout Standard
Now we can re-define 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
eval_tree
\end_layout

\end_inset

 for the concatenation expression
\end_layout

\begin_layout LyX-Code
eval_tree (ConcatNode xs) c = eval_trees xs c
\end_layout

\begin_layout Standard
Finall, we can re-define our definition of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
eval
\end_layout

\end_inset

 to set the initial top-level maximum and the minimum constraints to the
 length of the required answer
\end_layout

\begin_layout LyX-Code
eval (Def d pt len) = [Answer x (Def d pt len) |
\end_layout

\begin_layout LyX-Code
                                        x <- evalTree pt (Constraints Max
 len Min len)]
\end_layout

\begin_layout Subsubsection
Analysis of how good that is
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Do this
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Constrain against known letters 
\end_layout

\begin_layout Subsubsection
Motivation
\end_layout

\begin_layout Standard
Here again we turn to behaviour of a human solver:
\end_layout

\begin_layout Quotation

\shape italic
\begin_inset Quotes eld
\end_inset

It can't be that, as there are no words that start with 
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Quotation
\begin_inset Note Note
status open

\begin_layout Plain Layout
Insert a good example here, that we can use later on too
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Currently, we are performing a large amount of wasteful evaluations on subtrees
 that will never be ouputted as a valid answer, as we already know that
 given the the preceding letters that we've already evaluated, there are
 no possible words in our wordlist that we can make.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Add some illustrated examples
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Implementation
\end_layout

\begin_layout Standard
We want to add another contraint while solving, which is a check that what
 we are evaluating can be a prefix of a valid word.
 We add a function to calculate all proper prefixes of a given word
\end_layout

\begin_layout LyX-Code
prefixes :: String -> [String]
\end_layout

\begin_layout LyX-Code
prefixes = rprefixes .
 reverse 
\end_layout

\begin_layout LyX-Code
rprefixes (x:xs) = [reverse xs++[x]] ++ rprefixes xs 
\end_layout

\begin_layout LyX-Code
rprefixes [] = []
\end_layout

\begin_layout Standard
and some functions to precomputer a set of prefixes
\begin_inset Foot
status open

\begin_layout Plain Layout
For a very large wordlist it may be preferable to create a prefix tree.
 For my dataset, however, I found the extra memory footprint to be an acceptable
 tradeoff for constant-time lookups
\end_layout

\end_inset

 for our dataset and check if a given word is a prefix
\end_layout

\begin_layout LyX-Code
is_prefix x = member x wl_prefixes 
\end_layout

\begin_layout LyX-Code
wl_prefixes = fold add_prefixes empty wordlist
\end_layout

\begin_layout LyX-Code
add_prefixes word set = union (fromList (prefixes word)) set 
\end_layout

\begin_layout Standard
We want to add prefix constraints alongside the current maximum and minimum
 length constraints, to take advantage of the current mechanisms we have
 set up to propegate the prefixes down the nested parse trees.
 We update the type definitions and create similar functions for our new
 constraint:
\end_layout

\begin_layout LyX-Code
data EvalConstraints = Constraints PrefixConstraint MaxLength MinLength
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
is_prefix_with (Prefix p) x = is_prefix (p ++ x) 
\end_layout

\begin_layout LyX-Code
is_prefix_with NoPrefix x = True
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
class Constraint c where     
\end_layout

\begin_layout LyX-Code
[...]
\end_layout

\begin_layout LyX-Code
instance Constraint PrefixConstraint where 	
\end_layout

\begin_layout LyX-Code
fits p s = is_prefix_with p s
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
extend_prefix_by x (Constraints (Prefix p) mx mn) = (Constraints (Prefix
 (p++x)) mx mn) 
\end_layout

\begin_layout LyX-Code
extend_prefix_by x c = c
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
add_partial x  = decreaseMax (length x) .
 extend_prefix_by x 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Section
Analysis of Single clue solving against benchmarks 
\end_layout

\begin_layout Subsection
Accuracy given data Accuracy 
\end_layout

\begin_layout Subsection
assuming reasonable data could be acquired 
\end_layout

\begin_layout Subsection
Computation required and feasibility in the real world 
\end_layout

\begin_layout Subsection
Discussion of parallelization 
\end_layout

\begin_layout Part
Future Work
\end_layout

\begin_layout Section
Adding new clue types
\end_layout

\begin_layout Subsection
Show how we could use data fields to represent all the functions of a particular
 clue type
\end_layout

\begin_layout Section
Whole Grid Solving
\end_layout

\begin_layout Subsection
By permutations of all possible parses (dull but effective?) 
\end_layout

\begin_layout Subsection
Lazy evaluation (massive branching issues?) 
\end_layout

\begin_layout Subsection
Repeated function application (probabilistic convergence) probabilistically
 constrain against likely evidence from other clue
\end_layout

\begin_layout Subsubsection
Convergence not guaranteed!
\end_layout

\begin_layout Section
Solving with missing information 
\end_layout

\begin_layout Subsection
Human as an oracle 
\end_layout

\begin_layout Subsection
Generating probable solutions with missing data 
\end_layout

\begin_layout Subsubsection
Generative vs Filtering
\end_layout

\begin_layout Subsubsection
“if Lear means/is a King...” 
\end_layout

\begin_layout Section
Deployment as a web app
\end_layout

\begin_layout Section
Tweaking the values on the weighting function
\end_layout

\begin_layout Part
Appendix 
\end_layout

\begin_layout Section
Data considerations 
\end_layout

\begin_layout Subsection
Corpus / wordlist 
\end_layout

\begin_layout Subsubsection
Loading in an unsafe IO manner can 
\end_layout

\begin_layout Subsubsection
Conjugated forms -> we should match tense, plurality etc.
 Expanding out keywords (e.g.
 Anagram indicators) 
\end_layout

\begin_layout Subsection
Knowledge -> capital of Paris 
\end_layout

\begin_layout Subsection
Derived knowledge -> Qulog to create knowlegebase?
\end_layout

\begin_layout Subsection
Unsupervised learned?
\end_layout

\begin_layout Section
A benchmarking suite to check performance + accuracy
\end_layout

\begin_layout Subsection
Clues from real newspapers 
\end_layout

\begin_layout Subsection
A solution markup and automated verification => is answer enough or do we
 just want to provide a method 
\end_layout

\begin_layout Subsection
Rating clues on a scale / on multiple scales 
\end_layout

\begin_layout Part
References
\end_layout

\begin_layout Paragraph
Cryptic crossword clues: generating text with a hidden meaning
\end_layout

\begin_layout Standard
David Hardcastle - 2007 
\end_layout

\begin_layout Paragraph
The Generation of Cryptic Crossword Clues
\end_layout

\begin_layout Standard
G.
 W.
 Smith, and J.
 B.
 H.
 du Boulay - 1986 
\end_layout

\begin_layout Paragraph
Crossword Compiler-Compilation 
\end_layout

\begin_layout Standard
H.
 Berghel and C.
 Yi.
 - 1989 
\end_layout

\begin_layout Paragraph
PROVERB: The Probabilistic Cruciverbalist 
\end_layout

\begin_layout Standard
Greg A.
 Keim, Noam M.
 Shazeer, Michael L.
 Littman - 1999 
\end_layout

\begin_layout Paragraph
Computer Assisted Analysis of Cryptic Crosswords 
\end_layout

\begin_layout Standard
P.W.Williams and D.
 Woodhead - 1977 
\end_layout

\begin_layout Paragraph
LACROSS language, formal definitions - good building material
\end_layout

\begin_layout Standard
Cryptic crossword clue interpreter M Hart, RH Davis - 1992
\end_layout

\begin_layout Paragraph
Microcomputer compilation and solution of crosswords 
\end_layout

\begin_layout Standard
RH Davis and E J Juvshol - 1985 
\end_layout

\begin_layout Paragraph
Give Us A Clue
\end_layout

\begin_layout Standard
Jon G.
 Hall and Lucia Rapanotti - 2010 
\end_layout

\begin_layout Paragraph
A Statistical Study of Failures In Solving Crossword Puzzles
\end_layout

\begin_layout Standard
Naranana, 2010 
\end_layout

\begin_layout Paragraph
Expertise in cryptic crossword performance
\end_layout

\begin_layout Standard
Kathryn Friedlander, Philip Fine, 2009 
\end_layout

\begin_layout Standard
Cattell, R.
 G.
 G.
 “Formalization and Automatic Derivation of Code Generators”.
 PhD thesis, 1978.
 Carnegie Mellon University, Pittsburgh, Pennsylvania, USA 
\end_layout

\end_body
\end_document
