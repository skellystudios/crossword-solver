#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{qtree}
\usepackage{pdflscape}
\AtBeginDocument{%
\let\ref\autoref
}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\begin_local_layout
InsetLayout Flex:Code
    LyxType               charstyle
    LabelString           code
    LatexType             command
    LatexName             code
    Font
      Family              Typewriter
    EndFont
    Preamble
    \newcommand{\code}[1]{\texttt{#1}}
    EndPreamble
    InToc                 true
    HTMLTag               code
End
\end_local_layout
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Solving Cryptic Crosswords through Functional Programming
\end_layout

\begin_layout Author
Michael Skelly
\begin_inset Newline newline
\end_inset

Department of Computer Science
\begin_inset Newline newline
\end_inset

Imperial College
\end_layout

\begin_layout Date
April 25
\begin_inset script superscript

\begin_layout Plain Layout
th
\end_layout

\end_inset

 2014
\end_layout

\begin_layout Part
Introduction to the Problem / Field
\end_layout

\begin_layout Standard
Cryptic crosswords are widely thought to be at the crossroads of various
 fields of human endevour considered to be right at the limit of current
 AI and Machine Learning – featuring wit, slang, allusion, linguistic ambiguity
 and generally deliberate trickery.
 Along with this, they possess other characteristics that make brute force
 solutions difficult, if not impossible: the state space of all possible
 crossword grids is of the order 10
\begin_inset script superscript

\begin_layout Plain Layout
90
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
citation needed
\end_layout

\end_inset

(compare, for example, an upper bound on all the possible chess positions
 is merely 10
\begin_inset script superscript

\begin_layout Plain Layout
50
\end_layout

\end_inset

), and worse still, a solution to a grid is non-trivial to verify (as the
 verification process is the nearly same as solving the clue!)
\end_layout

\begin_layout Standard
Nevertheless, techniques from combinatorics, compiler design and NLP and
 AI all have applications that can help elucidate and simplify the problem,
 along with heuristics adapted from both human solvers and analytical optimisati
ons that can help improve the time taken to arrive at at the correct solution.
\end_layout

\begin_layout Standard
I have developed a system which can solve a significat percentage of cryptic
 crossword clues 
\begin_inset Note Note
status open

\begin_layout Plain Layout
More here, obvs
\end_layout

\end_inset


\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

A provost at Eton once boasted that he could do The Times crossword in the
 time it took his morning egg to boil, prompting one wag to suggest that
 the school may have been Eton but the egg almost certainly wasn't.
\begin_inset Quotes erd
\end_inset

 
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

 –
\begin_inset space ~
\end_inset

Citation Needed
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Part
Literature Review
\end_layout

\begin_layout Section
Summary of Cryptic Crosswords 
\end_layout

\begin_layout Subsection
Definition of Cryptic Crosswords 
\end_layout

\begin_layout Standard
To start, let us provide some basic definitions around crosswords and their
 taxonomies.
 
\end_layout

\begin_layout Standard
A crossword is a puzzle, usually published in newspapers or magazines.
 They consist of a grid of squares, often 15 x 15.
 Some of the squares are white (i.e.
 blank) and some are blacked out.
 Any contiguous run of more than one white square, either down (vertically)
 or across (horizontally, left to right) is a space for a word, to be written.
 These are marked by numbers in the initial square (the top-leftmost one),
 and referred to by those numbers, and the direction (e.g.
 '5 down', '8 across').
 Horizontal runs can overlap vertical runs, and at the points at which they
 do, each of the two words, when written in, must have the same letter in
 that square.
 Along with the grid are a set of clues, which the solver can use to determine
 which word to write in each space (the 'answer' or 'solution').
 The aim of the puzzle is to find the set of solution words such that each
 clue's solution is correct for that clue, and fits in the grid correctly,
 with respect to the overlapping words.
\end_layout

\begin_layout Standard
Grids can be very densely white, with few black squares and most squares
 shared by two words (usually called 
\noun on
American Style
\noun default
) or more sparse, with fewer overlapped clues (called 
\emph on
\noun on
British Style
\emph default
\noun default
).
 Clues can also be in two styles.
 
\noun on
Straight
\noun default
 or 
\noun on
Quick
\noun default
 crossword clues usually provide a single straightforward indicator as to
 what the correct word might be - often a synonym for the clue ('Joyful'
 = 'Happy') or a missing word (
\begin_inset Quotes eld
\end_inset

Stitch in ____ saves nine
\begin_inset Quotes erd
\end_inset

 = 
\begin_inset Quotes eld
\end_inset

Time
\begin_inset Quotes erd
\end_inset

).
 
\noun on
Cryptic
\series bold
\noun default
 
\series default
clues are less straight-forward, appearing on the surface to be a valid
 syntactic utterance in English, but actually consisting of a definition
 (as in the Straight clue) and some wordplay which the solver can use to
 arrive at the same answer as with the definition by apply a series of transform
ations and operations.
 The challenge is that the definition and the wordplay are not clearly separated
, and that there are multiple ways to apply to the transformations, but
 with only on yielding the correct answer.
 
\end_layout

\begin_layout Standard
It is the task of determining the correct answer for this type of clue that
 this report will address.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Definitely do some more examples dotted throughout here
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Cryptic Crosswords in the Literature 
\end_layout

\begin_layout Standard
While not a topic well covered in scientific literature in general, what
 few analytical studies around cryptic crosswords there are tend to be classifia
ble into three main groups
\end_layout

\begin_layout Subsubsection
Generation of Cryptic Clues
\end_layout

\begin_layout Standard
The largest body of work that exists is centered around the generation of
 cryptic clues, focused largely around analysis of how string literals from
 a pre-determined answer can be transformed by set clueing patterns, as
 well as some work around measures of the quality of generated clues.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
More here
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Interpreting Clues
\end_layout

\begin_layout Standard
The next set are the select few who have done prior, similar investigations
 into interpreting cryptic clues, with some work put into formalizing definition
s and notation for the sorts of clue types that appear in the majority of
 cryptic crosswords, and some attempts at solving based on these interpretations.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
More here
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Other Work
\end_layout

\begin_layout Standard
There has also been some work done towards solving non-cryptic crosswords
 probabilistically, working on whole-grid solutions rather than individual
 clues.
 There are also some more left-of-field studies done: statistical studies
 into errors made during manual solving, and psychological studies into
 solving.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
More here
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Complexity
\end_layout

\begin_layout Standard
A variety of factors make solving cryptic crosswords a difficult problem:
 
\end_layout

\begin_layout Paragraph*
Ambiguity 
\end_layout

\begin_layout Standard
Cryptic crosswords are deliberately ambiguous.
 Instruction indicators are indistinguishable from string literals, which
 are identical to words’ semantic meanings.
 Often, the setter will deliberately chose words to give rise to further
 ambiguities.
 For example, the 
\emph on
Telegraph
\emph default
 printed
\end_layout

\begin_layout LyX-Code
Bug starts to move in dark, glowing endlessly (5)
\end_layout

\begin_layout Standard
cluing for 'MIDGE'.
 Usually "endlessly" and similar mean "remove the last letter", but here
 it is one of five consecutive words to form an acronym from, with the word
 "starts" as an indicator.
\end_layout

\begin_layout Paragraph
State Space 
\end_layout

\begin_layout Standard
Even with only a few different clue types, the number of different readings
 of one clue based on those grows exponentially with the length of the clue.
 This means that unless heuristics are applied, the evaluation time for
 a whole grid longer clues may be unfeasibly long.
 Even longer than it takes me to do the Times Crossword.
 
\end_layout

\begin_layout Paragraph
Lack of Standardization 
\end_layout

\begin_layout Standard
Although all cryptic crossword share some common conventions, there are
 no fixed rules shared between publications for what can and can’t be a
 clue, indicator etc..
 Although most publications have internal guidelines or style-guides, these
 are not accessible to the solver, and some publications (such as the 
\emph on
Guardian
\emph default
) have named setters whose styles and self-imposed rulesets differ, even
 between one publication.
 Alistair Ferguson Ricthie, who set for 
\emph on
Listener
\emph default
 for many years, referenced the concept of fairness in his book 
\emph on
Armchair Crosswords 
\emph default
in 1946.
 He defers the judgement of fairness to a notional rulebook:
\end_layout

\begin_layout Quote
We must expect the composer to play tricks, but we shall insist that he
 play fair.
 
\emph on
The Book of the Crossword
\emph default
 lays this injunction upon him: "You need not mean what you say, but you
 must say what you mean." This is a superior way of saying that he can't
 have it both ways.
 He may attempt to mislead by employing a form of words which can be taken
 in more than one way, and it is your fault if you take it the wrong way,
 but it is his fault if you can't logically take it the right way.
\end_layout

\begin_layout Standard
Although 
\emph on
The Book of the Crossword
\emph default
 there have been many books written on the subject of what should and should
 not constitute a valid cryptic crossword clue.
 One of the most notable and influential was written by 
\emph on
Observer
\emph default
 setter Derrick Somerset Macnutt, both cluing and writing under the name
 Ximenes, in his book 
\emph on
Ximenes on the Art of the Crossword Puzzle
\emph default
.
 The book contains many in-depth guidelines about what a fair clue entails,
 summed up by his successor Azed (Jonathan Crowther, born 1942):
\end_layout

\begin_layout Quote
A good cryptic clue contains three elements: 
\end_layout

\begin_deeper
\begin_layout Quote
1.
 a precise definition
\end_layout

\begin_layout Quote
2.
 a fair subsidiary indication 
\end_layout

\begin_layout Quote
3.
 nothing else
\end_layout

\end_deeper
\begin_layout Standard
A crossword setter following these rules is said to adhere to 'Ximenean
 principles' and their produced work to be Ximenean.
 Most mainstream crosswords exist on a continuum between being more closely
 Ximenean (examples include 
\emph on
The Times
\emph default
, the 
\emph on
Independent
\emph default
) to being very libertarian (e.g.
 
\emph on
Guardian
\emph default
).
 No crossword in a major UK newspaper is 'strictly Ximenean'.
 
\end_layout

\begin_layout Paragraph*
Knowledge Base
\end_layout

\begin_layout Standard
As well as being made up of encrypted and hidden meanings, cryptic crosswords
 also draws on a diverse knowledge base of synonyms, abbreviations, facts
 etc.
 These can include information as diverse as names of capital cities, common
 sayings, and the fact that one may carry a wallet in ones pocket.
 
\end_layout

\begin_layout Standard
In order to run a fully working cryptic crossword solver against any arbitrary
 clue, all of these pieces of information must be encoded, stored and accessible
 to the solver in a machine readable form.
 Understandably, this is subject to an entire field of study itself.
 
\end_layout

\begin_layout Subsection
Programming Language Analogues
\end_layout

\begin_layout Standard
Much of the current work on interpreting crosswords draws on work by Backus,
 Naur and Chomsky in creating a specification for the grammar of crosswords.
 While these frameworks are useful for describing many different languages,
 interpretations of the grammar of cryptic crosswords seem to be perversely
 somewhat closer to mathematical and programming languages than to natural
 language.
 In some ways, the cryptic clue as a whole can be thought of as a program
 that generates the output string as its answer.
 The wordplay section is analogous to a program, and the definition section
 of a clue could be thought of as a checksum to verify the final answer.
\end_layout

\begin_layout Subsubsection
Lexing, Parsing, Evaluating 
\end_layout

\begin_layout Standard
The steps for compiling and running a computer program apply also to solving
 (or 'running') a crossword as a program.
 Each word in the input string needs to be tokenized, parsed into a relevant
 structure and then that structure evaluated to produce the final answer.
 Unusually for a programming language, however, the grammar of a cryptic
 crossword is highly ambiguous, and requires complex parsing.
 Firstly, programming language are only usually required to output the one
 valid abstract syntax tree, however here we may need to output many thousands
 in order to evaluate them to see which yields the correct answer.
 Furthermore, the grammar cannot be expressed without using complex context-sens
itive features such as lookbacks, lookaheads and backtracking.
 Most major programming languages are parsed without these features, allowing
 information to flow in one direction from the lexer to the parser.
 To parse a cryptic crossword, lexing and parsing need to take place simultaneou
sly in a process referred to as called 
\begin_inset Quotes eld
\end_inset

Scannerless Parsing
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsection
There's No Accounting for Wit
\end_layout

\begin_layout Standard
Along with clearly defined and program-like cryptic crossword clues, there
 exist other clues that rely on humour, imagery and wit, rather than following
 the regimented classical structure, as set out by Ximenes.
 Some examples include:
\end_layout

\begin_layout LyX-Code
Flower of London? (6)    
\end_layout

\begin_layout LyX-Code
    (= THAMES, flower = that which flows)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
In which you can get three couples together and have sex (5) 
\end_layout

\begin_layout LyX-Code
    (= LATIN, 'sex' is 6 in Latin)
\end_layout

\begin_layout Standard
Clues such as these, and the question of computerised wit and humour, unfortunat
ely exist out of the scope of this project.
\end_layout

\begin_layout Section
Parsing Frameworks and Notation
\end_layout

\begin_layout Standard
Some different notations for denoting parsing of cryptic clues have come
 out of previous work – in order to properly provide a rigorous analysis
 of the structures and conventions of cryptic crosswords, it is necessary
 to analyze and choose a framework in which to do it.
 
\end_layout

\begin_layout Subsection
LACROSS
\end_layout

\begin_layout Standard
William and Woodhead produced language called LACROSS, which forms a sort
 of calculus for describing crossword clues.
 They also provide a BNF definition of this grammar.
 Their clues are of the general form 
\end_layout

\begin_layout LyX-Code
Clue := Δ = G | G = Δ 
\end_layout

\begin_layout Standard
the orientation of which corresponds to the order in which we find the definitio
n (Δ) and the wordplay (G) in the clue.
 The wordplay may be further expanded out – the wordplay section of the
 clue is expressed as a sequential annotation for the constituent parts,
 either as ‘text’ (t), ‘shortening’ (S) (etc.) or as placeholders for the
 operators (*), which are detailed afterwards, including a reference to
 the substituted indicator.
 So for instance: 
\end_layout

\begin_layout LyX-Code
Get in odd bit of colour (5) [= tinge] 
\end_layout

\begin_layout LyX-Code
t* = Δ, a (odd, a) 
\end_layout

\begin_layout Standard
There are several issues with this grammar.
 Firstly, all unitary operators are treated the same, as are all binary
 operators, and there is some issue with binding and precedence which they
 address with an underlining notation, in addition to brackets.
 Secondly, the grammar attempts to include both the structure of the parsed
 cluing and how that structure relates to the original sequence of words
 at the same time.
 As a result, we end up with complex grammar that does not aid human parsing
 of the solution well, nor does it lend itself easily to computer or mathematica
l manipulation
\end_layout

\begin_layout Standard
Still, they have provided the basis for future work, and begun a basic enumerati
on of clue types.
 
\end_layout

\begin_layout Subsection
Simple Clue Markup Language 
\end_layout

\begin_layout Standard
Proposed by Hall and Rapanotti, Simple Clue Markup Language (SCML) attempts
 to notate the structure of the solution directly onto the clue.
 
\end_layout

\begin_layout Standard
Double underlining is used to denote the definition, underlining denotes
 an operator, with its class as an optional subscript, with scope provided
 by brackets and concatenation (and definition/wordplay separation) given
 by a semi-colon.
 Thus in their given example: 
\end_layout

\begin_layout LyX-Code
Note the shuddering appliance Bill regularly installed, noisy thing (6,7)
 
\end_layout

\begin_layout LyX-Code

\bar under
Note
\bar default
;(the)
\bar under
shuddering
\bar default

\begin_inset script subscript

\begin_layout Plain Layout
a
\end_layout

\end_inset

;(appliance,(Bill)
\bar under
regularly
\bar default

\begin_inset script subscript

\begin_layout Plain Layout
t
\end_layout

\end_inset

)
\bar under
installed
\bar default

\begin_inset script subscript

\begin_layout Plain Layout
e
\end_layout

\end_inset

;
\uuline on
noisy thing
\uuline default
 
\end_layout

\begin_layout Quote
Note’ often indicates a musical note, resolving to one of ‘a’ to ‘g’, ‘do’,
 ‘re’, ‘mi’, etc; 
\end_layout

\begin_layout Quote
‘the shuddering’ may be an anagram indicator applied to ‘the’; 
\end_layout

\begin_layout Quote
the ‘regularly’ of ‘Bill regularly’ may indicate alternate letters (‘t’);
 i.e., ‘bl’ or ‘il’; and 
\end_layout

\begin_layout Quote
‘installed’ suggests the embedding (‘e’) of those letters within something
 meaning ‘ appliance’.
\end_layout

\begin_layout Standard
In this, we have no markup differentiation for literal strings (‘Bill’)
 against words with their semantic context (‘appliance’), and we also take
 certain words that reduce to abbreviations (‘Note’) to be non-deterministic
 nullary operators.
 With some changes and additions (tagging of string vs.
 semantic word, for example), this markup serves as a good way to represent
 a parsing of a clue in a human readable way.
 It even has the advantage that a printed clue could be annotated (carefully)
 by hand, as a teaching aid, for example.
 Unfortunately, the language as it stands is not expressible as a BNF grammar,
 nor is it a particularly good format for representing the clue and its
 parsings internally in a program (as it would need to be re-parsed to use!)
 
\end_layout

\begin_layout Subsection
Clue-answer notation 
\end_layout

\begin_layout Standard
There are several emergent solutions within online cryptic crossword communities
 for notation to explain solutions derived from clues.
 From http://cryptics.wikia.com: 
\end_layout

\begin_layout Quote
Consider the down clue A message from the setter, hauled up with broken
 arm after heroin withdrawal (8) yielding the answer TELEGRAM.
 The corresponding wordplay, having the prolix and possibly ambiguous explanatio
n THE next to LEG reversed next to an anagram of ARM, all with H (heroin)
 removed could be concisely represented in clue-answer notation simply as
 T[h]E,GEL<=,(ARM)*.
 
\end_layout

\begin_layout Standard
These meanings are not fixed, but some definitions are given here: 
\end_layout

\begin_layout Paragraph
ABC<= or ABC (rev.) ABC reversed.	
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
The (rev.) notation is most commonly used when the wordplay consists of a
 single reversal.					
\end_layout

\begin_layout Paragraph
[abc] or -abc or (abc) 
\end_layout

\begin_layout Standard
Letters abc removed, as in[c]OUNT to represent 'count' with c removed; the
 convention is to use lower case for the removed letters.
 
\end_layout

\begin_layout Paragraph
(ABC) 
\end_layout

\begin_layout Standard
Letters placed inside others, as inC(AND)ID to mean 'and' inside 'cid'.
 
\end_layout

\begin_layout Paragraph
"ABC" 
\end_layout

\begin_layout Standard
Homophone of ABC.
 
\end_layout

\begin_layout Paragraph
(ABC)* 
\end_layout

\begin_layout Standard
Anagram of ABC.
\end_layout

\begin_layout Paragraph
A+B or A,B 
\end_layout

\begin_layout Standard
A concatenated with B.
 Sometimes both notations are used together where ambiguities may arise.
 
\end_layout

\begin_layout Paragraph
aBcDeF 
\end_layout

\begin_layout Standard
Alternate letters of ABCDEF (shorthand for[ a]B[c]D[e]F).
 
\end_layout

\begin_layout Subsection
PICCUP
\end_layout

\begin_layout Standard
Hart and Davies define what is currently the most satisfying proposal for
 a formal syntactical definition of cryptic crossword syntax, in a loosely
 BNF grammar.
 Theirs is the only current definition that closely resembles a usable formally
 defined language.
\end_layout

\begin_layout Standard
Their interpretation only specifies the grammar in terms of building an
 abstract syntax tree, rather than attempting to include a notation for
 clue or answer.
\end_layout

\begin_layout LyX-Code
Anagram → Synonym(.Equ Indicator).AnagramSentence
\end_layout

\begin_layout LyX-Code
/AnagramSentence(.Equ Indicator).Synonym 
\end_layout

\begin_layout LyX-Code
AnagramSentence → AnagramPointer.AnagramMaterial
\end_layout

\begin_layout LyX-Code
/ Anagram Material.Anagram Pointer AnagramPointer~ Word(.Word)* 
\end_layout

\begin_layout LyX-Code
AnagramMaterial → Word(.Word)* 
\end_layout

\begin_layout LyX-Code
Synonym → Word(.Word)* 
\end_layout

\begin_layout LyX-Code
Equ Indicator → Word (.Word)*
\end_layout

\begin_layout Subsection
Syntactic and Metasyntactic Conventions
\end_layout

\begin_layout Standard
Here we apply a similar convention to Hart, in using a modified Backus Naur
 Form (BNF).
 We will later see that a context-free grammar may not be sufficient to
 model a cryptic crossword, and may have further deficiencies as a basis
 for finding a solution.
 Nevertheless, we will adopt a similar notation: 
\end_layout

\begin_layout LyX-Code
→ = is composed of 
\end_layout

\begin_layout LyX-Code
, = followed by 
\end_layout

\begin_layout LyX-Code
| = or
\end_layout

\begin_layout LyX-Code
(x) = x is optional 
\end_layout

\begin_layout LyX-Code
x* = 1 or more occurrences of x 
\end_layout

\begin_layout LyX-Code
(x)* = 0 or more occurrences of x 
\end_layout

\begin_layout Standard
We also take the BNF conventions 
\end_layout

\begin_layout LyX-Code
Word = non-terminal symbol 
\end_layout

\begin_layout LyX-Code
“word” = string literal 
\end_layout

\begin_layout LyX-Code
[x, y, z] = list containing x y and z 
\end_layout

\begin_layout LyX-Code
(x, y) = pair x and y 
\end_layout

\begin_layout Standard
For clarity, we additionally define: 
\end_layout

\begin_layout LyX-Code
String = [any string literal]
\end_layout

\begin_layout Subsection
Context Free?
\end_layout

\begin_layout Standard
The grammar described in this paper not a regular grammar (for example:
 any of the binary operators generate two non-terminals), but it can be
 formulated as a context-free grammar.
 
\end_layout

\begin_layout Standard
We define a 
\noun on
context-free grammar
\noun default
 (CFG) as one in which the expansion of a non-terminal is not affected by
 the symbols before and after it.
\end_layout

\begin_layout Standard
While we can certainly define a working grammar for cryptic crossword clues
 in terms of a CFG, it may be useful to consider other options as a means
 of reducing the number of trees generated during the parsing phase to speed
 up the evaluation phase.
 We could take, for example, the clue length as a contextual variable: in
 that case, a 6 letter clue whose parse tree contains an anagram of a 4-letter
 string cannot yield another anagram of 5 letters.
\end_layout

\begin_layout LyX-Code
        Cons Node
\end_layout

\begin_layout LyX-Code
   
\bar under
         |       
\end_layout

\begin_layout LyX-Code
Anagram        Wordplay
\end_layout

\begin_layout LyX-Code
  |               
\end_layout

\begin_layout LyX-Code
String
\end_layout

\begin_layout LyX-Code
  |
\end_layout

\begin_layout LyX-Code
\begin_inset Quotes eld
\end_inset

apples
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
In this example, the wordplay on the right should not be expanded out to
 an anagram node featuring a string of 5 characters (to consume, say, the
 string 
\begin_inset Quotes eld
\end_inset

mixed pears
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Subsection
Syntax vs Semantics
\end_layout

\begin_layout Standard
Due to the ambiguous and duplicitous nature of the structure of cryptic
 crosswords, especially the deliberate challenges in the lexing phase, unclarity
 between the boundaries between parsing the syntax and evaluating the semantics
 emerge.
 
\end_layout

\begin_layout Standard
Strings consisting of one or more words can be at once tokens representing
 different operators, they can be strings, and can be split in multiple
 ways into combinations.
 This is especially true when we have token that, in the original text,
 represent their semantic meaning in English, and evaluate out to a finite
 number of equivalent words (roughly, synonyms: see later for discussion
 about this equivalence relation).
 
\end_layout

\begin_layout Standard
Hall and Rapanotti treated these roughly as their own operators: so the
 string 
\begin_inset Quotes eld
\end_inset

rough
\begin_inset Quotes erd
\end_inset

 would parse to the token Rough, which later evaluates to a finite number
 of definitions.
 This may, indeed, be tempting if we had a limited number of candidate words.
 And, indeed, we do need to differentiate these from raw string literals
 that are subject to Hidden Word or Initial Letter operators, or occasionally
 concatenated in their raw form (for example the string 
\begin_inset Quotes eld
\end_inset

it
\begin_inset Quotes erd
\end_inset

 is sometimes taken as given where necessary) .
\end_layout

\begin_layout Standard
I think a more manageable way and satisfying way to consider these options
 is to consider them subject to an invisible 'word' operator.
 This keeps the semantics and syntax more separate, but certainly poses
 some challenges for a parser / lexer.
\end_layout

\begin_layout Section
The Cryptic Crossword Clue 
\end_layout

\begin_layout Subsection
Structure of a cryptic clue
\end_layout

\begin_layout Standard
A cryptic crossword differs from a normal crossword in that the clue for
 each answer consists of two parts.
 The first is the definition, which performs the same function as a clue
 in a 'regular' crossword.
 The answer to the clue is usually a synonym for the definition ('circular'
 and 'round') or may be an example of the definition ('farm animal' and
 'pig').
 Other forms that the definition may take will be discussed later on.
 The second part of the clue is the wordplay.
 This is an encoded and often ambiguous second method of deriving the answer,
 using techniques such as anagram, substitution and concatenation.
 The clue as a whole is presented as a concatenation of the two parts, sometimes
 with a subsidiary word indicating that one can be derived from the other
 (for example, 'from' or 'is').
 We can present this breakdown as: 
\end_layout

\begin_layout LyX-Code
Clue → Definition, (Indicator), Wordplay 
\end_layout

\begin_layout LyX-Code
       | Wordplay, (Indicator), Definition 
\end_layout

\begin_layout Standard
The final clue will often resemble a valid English utterance, although this
 'surface reading' (i.e.
 {clue} ) very rarely has any relation to the answer.
 Later on we will consider other information and context within the definition
 of a clue.
\end_layout

\begin_layout Subsection
Definition 
\end_layout

\begin_layout Standard
The definition of the clue consists of one or more English words.
 The answer to the clue will be a word or phrase that fits an appropriate
 equivalence function (that we will define later).
\end_layout

\begin_layout Standard
The definition carries a variety of linguistic features with it that the
 overall answer, and so the answer as derived by the wordplay, must match.
 These include aspect (noun, verb, adjective), plurality (tree, trees),
 tense (go, going, gone).
 These features may also be considered as 'context' to the clue itself.
 
\end_layout

\begin_layout Subsubsection
Formally 
\end_layout

\begin_layout Standard
We can define the definition as 
\end_layout

\begin_layout LyX-Code
Definition → Words
\end_layout

\begin_layout Subsection
Wordplay 
\end_layout

\begin_layout Standard
The wordplay section of a clue is a set of deliberately ambiguous instructions
 that allows the solver to arrive at the eventual answer.
 As the instructions are ambiguous, multiple possible parsings of the instructio
ns are possible.
 Some of these parsing will not lead to a valid English word: 
\end_layout

\begin_layout LyX-Code
Imbecile, bonkers, in a cult (7) 
\end_layout

\begin_layout LyX-Code
==> Wordplay ‘Imbecile, bonkers = definition ‘in a cult’
\end_layout

\begin_layout LyX-Code
==> Anagram ‘imbecile’ [indicator = bonkers] = definition ‘in a cult’ 
\end_layout

\begin_layout LyX-Code
==> ??? (no anagrams of imbecile in english language) 
\end_layout

\begin_layout LyX-Code
(correct reading was anagram of in a cult = lunatic)
\end_layout

\begin_layout Standard
Others will lead to a valid English word, but one that is not equivalent
 to the definition: 
\end_layout

\begin_layout LyX-Code
Minder shredded corset (6) 
\end_layout

\begin_layout LyX-Code
==> Wordplay ‘minder shredded’ = definition ‘corset’ 
\end_layout

\begin_layout LyX-Code
==> Anagram ‘minder’ [indicator = shredded] = definition ‘corset’ 
\end_layout

\begin_layout LyX-Code
==> ‘remind’ = definition ‘corset?’ X 
\begin_inset Newline newline
\end_inset

(correct reading was anagram ‘corset’ = escort = minder)
\end_layout

\begin_layout Standard
The solver must find the correct parsing of the wordplay that yields the
 correct definition: even though they may not know which part is wordplay
 and which is definition.
\end_layout

\begin_layout Subsection
Special Operators 
\end_layout

\begin_layout Standard
I include these two operators first, as they really form the backbone or
 basis of other clues.
 They are also unique in being implicitly clued, rather than requiring an
 indicator word to signify their presence.
 
\end_layout

\begin_layout Paragraph
Word Equivalence
\end_layout

\begin_layout Standard
In the most simple of clues, we have the definition, along with a word or
 phrase that is somehow semantically equivalent to that definition.
 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
In this case, it becomes a difficult task to be precise about exactly which
 of these is the definition and which is the wordplay! Sometimes there is
 a defined answer: From 'Oinking tendency? (8)' we get both 'pen chant'
 and 'penchant', and we can see from the letters required (no space) that
 the second half is the solution.
 In other cases, this may not be defined at all! 
\end_layout

\end_inset

 A clue that contains just this structure is said to be 'double definition'
\end_layout

\begin_layout LyX-Code
Metal guide (4) [= LEAD]
\end_layout

\begin_layout Standard
However, even in this simple example we see that this equivalence relationship
 is not at all straightforward.
 While 'guide' and 'lead' are synonyms (as verbs in the present tense),
 it's not true that 'lead' is a synonym for 'metal'.
 We must also include 'for example' in this relationship too, which causes
 us to have to discard reflexivity.
 Although 'metal' can be a clue for 'lead', it's not the case that 'lead'
 can be a clue for 'metal' (in that case, we signify 'an example of' by
 writing 'lead, say' or 'bronze, for instance').
 
\end_layout

\begin_layout Standard
We also include abbreviations, which are perhaps more closely related to
 synonyms, although not usually found in thesauruses, along with some useful
 'setters favourites', where an abbreviation of a synonym or of an example
 is particularly useful for cluing a difficult letter combination used in
 a wordplay ('Books' becomes 'NT', for 'New Testament').
\end_layout

\begin_layout LyX-Code
Words → Synonym | Abbreviation | Example 
\end_layout

\begin_layout LyX-Code
Synonym → String
\end_layout

\begin_layout LyX-Code
Abbreviation → String
\end_layout

\begin_layout LyX-Code
Example → String
\end_layout

\begin_layout Standard
The semantic task of evaluating this will be discussed later.
\end_layout

\begin_layout Paragraph
Concatenation
\end_layout

\begin_layout Standard
While not strictly necessary for this grammar (as we have included a concatenati
on in our metasemantics, we could define multiple definitions of each operator
 in the form Operator → Indicator, Wordplay, (Wordplay)*), it makes sense
 to add this explicitly as it mirrors the structure of an explanation of
 a computer solution (i.e.
 the parse tree).
\end_layout

\begin_layout LyX-Code
Concatenation → Wordplay (ConcatIndicator) Wordplay
\end_layout

\begin_layout Standard
This represents a key tool for cluers to create more complex wordplay clues
 in the form of a charade, where two or more parts can be split out (sometimes
 syllabically as in 'bath', 'tub', or sometimes otherwise 'bat','htub')
 and clued separately, and then later joined to form the overall solution.
\end_layout

\begin_layout Subsection
Other Wordplay Operators
\end_layout

\begin_layout Standard
For the other wordplay operators, we define them in terms of our grammar,
 as well as discussing their semantic meaning.
\end_layout

\begin_layout LyX-Code
Wordplay → Words | Concatenation | Anagram | Reversion | Contraction 
\end_layout

\begin_layout LyX-Code
          | Selection | Hidden Word | Containment | Subtraction 
\end_layout

\begin_layout LyX-Code
          | Homophone
\end_layout

\begin_layout Standard
These operators all include an indicator word to show they are being applied
 (as is far more common with operators in programming language parsing!)
 Each operator will usually have many different indicators (lists of anagram
 indicators on the web span multiple hundreds).
 Only select ones are included in the specification here.
\end_layout

\begin_layout Subsubsection
Unitary Operators 
\end_layout

\begin_layout Paragraph
Anagram 
\end_layout

\begin_layout Standard
A very commonly used operator in crossword clues is an anagram.
 These take the form of an indicator word that denotes that the anagram
 function is being used (called an ‘anagrind’ within cruciverbalist circles),
 along with the candidate letters to be anagrammed.
 The simplest form of this gets the candidate letters verbatim from the
 clue: 
\end_layout

\begin_layout LyX-Code
Anagram → Anagrind, String | String, Anagrind 
\end_layout

\begin_layout Standard
Sometimes, however sometimes there is some sort of operation applied to
 the letters before the anagram is applied.
 For example: 
\end_layout

\begin_layout LyX-Code
Comic bare for short comedy play (7,5) 
\end_layout

\begin_layout LyX-Code
==> Wordplay ‘Comic bare for short comedy’ = Definition ‘play’ 
\end_layout

\begin_layout LyX-Code
==> Anagram ‘bare for short comedy’ [anagrind = ‘comic’] 
\end_layout

\begin_layout LyX-Code
==> Anagram (“bare for” + Shorten ‘comedy’) 
\end_layout

\begin_layout LyX-Code
==> Anagram (“bare fore” + “comed”) 
\end_layout

\begin_layout LyX-Code
==> Anagram (“bare fore” + “comed”) 
\end_layout

\begin_layout LyX-Code
==> Anagram (“bareforecomed”) 
\end_layout

\begin_layout LyX-Code
==> “Bedroom Farce” 
\end_layout

\begin_layout Standard
In which case we find the more general case one proposed structure: 
\end_layout

\begin_layout LyX-Code
Anagram → Anagrind, Wordplay | Wordplay, Anagrind 
\end_layout

\begin_layout Standard
Wherein we know that the repeated evaluation of the Wordplay will eventually
 result in a string literal that can be anagrammed.
 In 
\emph on
Art of the Crossword Puzzle, 
\emph default
Ximenes argued against this form of indirect anagram: 
\end_layout

\begin_layout Quote
Secondly – and here, for once, I differ from Afrit – I hate what I call
 an indirect anagram.
 By that I mean "Tough form of monster" for HARDY (anagram of HYDRA).
 There may not be many monsters in five letters; but all the same I think
 the clue-writer is being mean and withholding information which the solver
 can reasonably demand.
 Why should he have to solve something before he can begin to use part of
 a clue? He has first to find "hydra" – and why shouldn't it be "giant"?
 – and then use the anagrammatic information to help him think of "hardy".
 ...
 My real point is that the secondary part of the clue – other than the definitio
n – is meant to help the solver.
 The indirect anagram, unless there are virtually no alternatives, hardly
 ever does.
 He only sees it after he has got his answer by other means.
 
\end_layout

\begin_layout Standard
Even so, most setters that claim to be Ximenean will allow small abbreviations
 and contractions (to be defined later) to be included in their clues.
 We therefore must define a new class which includes String Literals as
 well as the abbreviation where appropriate.
 
\end_layout

\begin_layout LyX-Code
Anagram → Anagrind, StringWordplay* | StringWordplay*, Anagrind
\end_layout

\begin_layout LyX-Code
Anagrind → “free” | “novel” | “comic” [...]
\end_layout

\begin_layout LyX-Code
StringWordPlay → String | Abbreviation | Contraction
\end_layout

\begin_layout Paragraph
Reversion 
\end_layout

\begin_layout Standard
Clues can also be reversed.
 While this is functionally a subset of anagrams, there are some crucial
 differences.
 Firstly the ‘directionality’ of the clue (i.e.
 whether it is a ‘down’ or an ‘across’) comes into effect, in determining
 the sorts of indicators that can form it: “turned back” may only apply
 to ‘across’ clues, where “taken up” may only apply to ‘down’ clues.
 Further, these clues are usually taken to be ‘fairer’ game for subsequent
 operations to be applied to the target of the reversion.
 Therefore, a clue with nested wordplay such as ("Stressed, made upside-down
 pudding (7)" = DESSERT) would be acceptable, where an equivalent clue as
 an anagram ("Stressed, cooked up pudding") would often not be seen as Ximenean.
 
\end_layout

\begin_layout LyX-Code
Anagram → ReversionIndictator, Wordplay | Wordplay, ReversionIndictator
\end_layout

\begin_layout LyX-Code
ReversionIndicator → 
\begin_inset Quotes eld
\end_inset

around
\begin_inset Quotes erd
\end_inset

 | 
\begin_inset Quotes eld
\end_inset

turned back
\begin_inset Quotes erd
\end_inset

 | 
\begin_inset Quotes eld
\end_inset

taken up
\begin_inset Quotes erd
\end_inset

 [...]
\end_layout

\begin_layout Paragraph
Contraction 
\end_layout

\begin_layout Standard
Clues of this form range from specific, such of first/last letters ('first
 in line' = 'l', 'last of the Mohicans' = 'm') to more general operators
 ('mostly harmless' can yield 'armless', 'harmles', 'harmle'...) whose definitions
 are more flexible.
\end_layout

\begin_layout LyX-Code
Contraction → FirstLetterContraction | LastLetterContraction | GeneralContractio
n 
\end_layout

\begin_layout LyX-Code
FirstLetterContraction → PreFLCIndicator, Wordplay | Wordplay, PostFLCIndicator
\end_layout

\begin_layout LyX-Code
LastLetterContraction → PreLLCIndicator, Wordplay | Wordplay, PostLLCIndicator
\end_layout

\begin_layout LyX-Code
GeneralContraction → PreGCIndicator, Wordplay | Wordplay, PostGCIndicator
\end_layout

\begin_layout Paragraph
Selection 
\end_layout

\begin_layout Standard
There are three similar operators here: A pair which select even or odd
 letters respectively, and one which takes initial letters across multiple
 words.
 These are rarely, if ever, applied to anything other than pure strings.
 The initials indicator needs to be applied to an argument consisting of
 multiple words.
\end_layout

\begin_layout LyX-Code
Selection → Evens | Odds | Initials
\end_layout

\begin_layout LyX-Code
Evens → EvensIndicator, String | String, EvensIndicator
\end_layout

\begin_layout LyX-Code
Odds → OddsIndicator, String | String, OddsIndicator
\end_layout

\begin_layout LyX-Code
Initials → InitialsIndicator, String, 
\begin_inset Quotes eld
\end_inset

 
\begin_inset Quotes eld
\end_inset

, String* | 
\begin_inset Newline newline
\end_inset

           String, 
\begin_inset Quotes eld
\end_inset

 
\begin_inset Quotes eld
\end_inset

, String*, InitialsIndicator
\end_layout

\begin_layout Paragraph
Hidden word 
\end_layout

\begin_layout Standard
The hidden word clue finds a word which appears as a substring (ignoring
 spaces) inside its operand.
 These typically only occur once per puzzle, and are always accompanied
 by a clear indicator.
 In this example clue:
\end_layout

\begin_layout LyX-Code
'Smack which appears in East Anglian ports.(4)' 
\end_layout

\begin_layout Standard
the solution to this example is 'TANG', (meaning 'smack' in the sense of
 'taste'), and which is concealed (indicated by 'which appears') in 'easT
 ANGlian ports'.
 
\end_layout

\begin_layout LyX-Code
HiddenWord → HWIndictator String | String HWIndicator
\end_layout

\begin_layout Standard

\series bold
Homophone
\end_layout

\begin_layout Standard
Also called 'sounds like', this operator produces homophones of a given
 word.
 They may be spelled differently ('right' and 'rite') or the same but said
 differently ('Polish' and 'polish').
 This operator is not applied to words that are both spelled and said the
 same, but with different meanings ('must' as an imperative and 'must' as
 a noun).
 
\end_layout

\begin_layout Standard
Often, if clues are straightforward, placement of this operator can determine
 the spelling of the answer.
 
\end_layout

\begin_layout LyX-Code
We hear twins shave (4)
\end_layout

\begin_layout Standard
yields 'pare' whereas
\end_layout

\begin_layout LyX-Code
Twins shave, we hear (4)
\end_layout

\begin_layout Standard
yields 'pair'.
 A formulation with the indicator in the middle, in this case, would result
 in a strong ambiguity.
 The homophone indicator is only applied to equivalence words, not to clued
 wordplay.
\end_layout

\begin_layout LyX-Code
Homophone → HomophoneIndicator Words | Words HomophoneIndicator
\end_layout

\begin_layout Subsubsection
Binary Operators 
\end_layout

\begin_layout Standard
As with the unitary operator, each of the arguments of binary operators
 can be one or more words.
\end_layout

\begin_layout Paragraph
Containment 
\end_layout

\begin_layout Standard
Here are two styles of wordplay which are clued very differently, but are
 actually the same operator, which places one set of letter inside another.
 This is either presented as a insertion ('end inside ls') or as a containment
 ('ls around end').
 This operation always preserves letter order, unless some nested indicator
 allows otherwise.
 
\end_layout

\begin_layout LyX-Code
Containment → Wordplay ContainmentIndicator Wordplay  
\end_layout

\begin_layout LyX-Code
ContainmentIndicator → 
\begin_inset Quotes eld
\end_inset

inside
\begin_inset Quotes erd
\end_inset

 | 
\begin_inset Quotes eld
\end_inset

around
\begin_inset Quotes erd
\end_inset

 [...]
\end_layout

\begin_layout Paragraph
Subtraction 
\end_layout

\begin_layout Standard
In a subtraction clue, a number of letters are removed from the target.
 Usually, the target is some wordplay itself, although sometimes just a
 string literal.
 The letters to be subtracted are also often the product of some sort of
 cluing, although this is usually fairly limited in scope (abbreviations,
 contractions, first letters of string literals).
 There are two constraints on this: all the letters from the subtraction
 set must be in the target, and the length of the subtraction set must be
 less than the length of the target.
 
\end_layout

\begin_layout LyX-Code
Subtraction → SubPreIndictator1 Wordplay (SubPreIndictator2) Wordplay 
\begin_inset Newline newline
\end_inset

   | Wordplay SubM
\noun on
function 
\noun default
idIndictator Wordplay 
\begin_inset Newline newline
\end_inset

   | Wordplay (SubPostIndictator1) Wordplay SubPostIndictator2 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
SubPreIndictator1 → 
\begin_inset Quotes eld
\end_inset

took
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

without
\begin_inset Quotes erd
\end_inset

 [...]
\end_layout

\begin_layout LyX-Code
SubPreIndictator2 → 
\begin_inset Quotes eld
\end_inset

from
\begin_inset Quotes erd
\end_inset

 [...]
\end_layout

\begin_layout LyX-Code
SubMidIndictator → 
\begin_inset Quotes eld
\end_inset

without
\begin_inset Quotes erd
\end_inset

 [...]
\end_layout

\begin_layout LyX-Code
SubPostIndictator1 → 
\begin_inset Quotes eld
\end_inset

with
\begin_inset Quotes erd
\end_inset

 [...]
\end_layout

\begin_layout LyX-Code
SubPostIndictator2 → 
\begin_inset Quotes eld
\end_inset

removed
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

deleted
\begin_inset Quotes erd
\end_inset

 [...]
\end_layout

\begin_layout Standard
Semantically here, we have the difference in pre- and post- as the difference
 between 
\begin_inset Quotes eld
\end_inset

wanted ant removed
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

removing ant wanted
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Standard
The letters in the set are thought to be removed in the order in which they’re
 found in order to be a properly clued wordplay.
 Thus “standing” with “tan” removed, gives “sanding”, whereas “ant” cannot
 be appropriately removed.
 Note though that the order in which nested clues are applied can change
 what the set is applied too.
 If we also had an anagram indicator, as in “Boy muddled standing missing
 trap” we can apply the muddled to standing to get “dansting” before removing
 “sting” to get the answer “Dan”.
\end_layout

\begin_layout Subsection
Meta-references 
\end_layout

\begin_layout Standard
Sometimes, clues contain references to that cannot be parsed in isolation,
 or contain a cluing structure that is incompatible with the main model
 of cluing.
\end_layout

\begin_layout Subsubsection
Self reference
\end_layout

\begin_layout Standard
A type of clue called an '&lit' clue allows the setter to not include a
 definition part if the text that makes up the wordplay also can also be
 read as the definition.
 Thus in 
\end_layout

\begin_layout LyX-Code
Spoil vote! (4)
\end_layout

\begin_layout Standard
we have the wordplay Anagram (=spoil) 
\begin_inset Quotes eld
\end_inset

vote
\begin_inset Quotes erd
\end_inset

 to give 'VETO', as well as the clue as a whole 'spoil vote' meaning 'veto'.
\end_layout

\begin_layout Subsubsection
Reference to other clues
\end_layout

\begin_layout Standard
Some publications will have clues that reference the answer to other clues
 ('8 across.
 Cake made badly by 7 down.').
 Sometimes these may also be cyclical (in this example, 7 down would reference
 8 across too).
 
\end_layout

\begin_layout Subsubsection
Contextual References
\end_layout

\begin_layout Standard
Sometimes references will refer outside of the crossword itself.
 For example, The 
\emph on
Sunday Telegraph
\emph default
 on Easter Sunday 2014 had an anagram clue whose answer was EASTER SUNDAY,
 and its definition part was "today".
 In a crossword by setter 
\emph on
Araucaria
\emph default
, "Araucaria is" coded for IAM (= "I am") as part of an answer.
\end_layout

\begin_layout Section
Convention 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Do some shit here, yeah?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Words
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Part
Naive Approach 
\end_layout

\begin_layout Section
Parsing and Evaluating everything 
\end_layout

\begin_layout Subsection
Solving a Clue
\end_layout

\begin_layout Standard
Our motivation here is to take a cryptic crossword clue, for example:
\end_layout

\begin_layout LyX-Code
[A]  Ship carrying right flag (8)
\end_layout

\begin_layout LyX-Code
[B]  Companion shredded corset (6)
\end_layout

\begin_layout LyX-Code
[C]  Companion shredded corset (6)
\end_layout

\begin_layout Standard
and attempt to parse and solve it to provide the correct answer.
 We will define the datatype of Clue thus:
\end_layout

\begin_layout LyX-Code
data Clue = Clue String AnswerLength
\end_layout

\begin_layout LyX-Code
where
\end_layout

\begin_layout LyX-Code
type Length = Int
\end_layout

\begin_layout Standard
In order to solve this clue, we want to find a function that takes a clue,
 which consists of a string containing the text of the clue and an integer
 representing the lenght of the required answer, and returns us the answer.
\end_layout

\begin_layout LyX-Code
solve :: Clue → Answer 
\end_layout

\begin_layout Standard
The intuition behind how our naive solver will work is that it will generated
 all possible ways of parsing a clue, then generate all possible answers
 that could be derived from those parses, and then attempt to match those
 up with the definition and the length constraints.
 In order to evaluate, measure and optimise each of these steps independently,
 we split the structure of our program into four parts:
\end_layout

\begin_layout LyX-Code
solve = choose .
 evaluate .
 parse .
 split
\end_layout

\begin_layout Standard
where the types are given below:
\end_layout

\begin_layout LyX-Code
split    :: Clue → [Split]
\end_layout

\begin_layout LyX-Code
parse    :: [Split] → [Parse]
\end_layout

\begin_layout LyX-Code
evaluate :: [Parse] → [Answer]
\end_layout

\begin_layout LyX-Code
choose   :: [Answer] → Answer
\end_layout

\begin_layout Subsection
Splitting
\end_layout

\begin_layout Standard
While a clue has a surface reading involving the semantic natural langage
 parsing of it as a sentence fragment (which would yield a phrase, with
 an subject, a past tense verb and an object), we are only interested in
 the crossword interpretation of this, which is of the form: 
\end_layout

\begin_layout LyX-Code
  Definition Indicator* Wordplay 
\end_layout

\begin_layout LyX-Code
| Wordplay Indicator* Definition
\end_layout

\begin_layout Standard
Let us forget about the optional indicators for now – we will deal with
 these properly later .
 We are looking to define a function 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
split
\end_layout

\end_inset

 which splits the clue into a wordplay portion and a definition portion.
 So for example, clue 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
A
\end_layout

\end_inset

 can be split 6 different ways:
\end_layout

\begin_layout LyX-Code
 wordplay  definition         definition  wordplay
\end_layout

\begin_layout LyX-Code
   
\begin_inset Formula $\mathtt{\overbrace{Ship}\:\overbrace{carrying\: right\: flag}}$
\end_inset

         
\begin_inset Formula $\mathtt{\overbrace{Ship}\:\overbrace{carrying\: right\: flag}}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \thinspace{}
\end_inset


\end_layout

\begin_layout LyX-Code
    wordplay  definition         definition  wordplay
\end_layout

\begin_layout LyX-Code
   
\begin_inset Formula $\mathtt{\overbrace{Ship\, carrying}\:\overbrace{right\: flag}}$
\end_inset

         
\begin_inset Formula $\mathtt{\overbrace{Ship\, carrying}\:\overbrace{right\: flag}}$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset space \thinspace{}
\end_inset


\end_layout

\begin_layout LyX-Code
       wordplay definition       definition   wordplay
\end_layout

\begin_layout LyX-Code
   
\begin_inset Formula $\mathtt{\overbrace{Ship\, carrying\, right}\:\overbrace{flag}}$
\end_inset

        
\begin_inset Formula $\mathtt{\overbrace{Ship\, carrying\, right}\:\overbrace{flag}}$
\end_inset

  
\end_layout

\begin_layout Standard
From the types of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Wordplay
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Definition
\end_layout

\end_inset

:
\end_layout

\begin_layout LyX-Code
type Definition = String
\end_layout

\begin_layout LyX-Code
type Wordplay = String
\end_layout

\begin_layout Standard
we can create a datatype
\end_layout

\begin_layout LyX-Code
data Split = Def Definition Wordplay AnswerLength
\end_layout

\begin_layout Standard
as well as the signature of a function 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
split
\end_layout

\end_inset

:
\end_layout

\begin_layout LyX-Code
split :: Clue → [Split]
\end_layout

\begin_layout LyX-Code
split (text length) = 
\end_layout

\begin_layout LyX-Code
    let parts = partitions .
 words $ text 
\end_layout

\begin_layout LyX-Code
    in [Def (unwords d) (unwords w) length | [d,w] <- parts]
\end_layout

\begin_layout Subsection
Parsing
\end_layout

\begin_layout Standard
Now we have consumed one portion of the string to form the definition in
 each of a list of splits.
 Now we need to parse the rest of the clue into a structure which we can
 evaluate to produce our answer.
 Let us take for an example the correct split (of the 6 available) of 
\end_layout

\begin_layout LyX-Code
       wordplay  definition       
\end_layout

\begin_layout LyX-Code
   
\begin_inset Formula $\mathtt{\overbrace{Ship\, carrying\, right}\:\overbrace{flag}}$
\end_inset

     
\end_layout

\begin_layout Standard
which would have the haskell structure of 
\end_layout

\begin_layout LyX-Code
Def 
\begin_inset Quotes eld
\end_inset

flag
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

ship carrying right
\begin_inset Quotes erd
\end_inset

 8
\end_layout

\begin_layout Standard
The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
parse
\end_layout

\end_inset

 function must, for each split, consume the wordplay and return all possible
 parses for that wordplay.
 Since each split will return multiple parses, we will want to collect these
 afterwards.
 We define datatype 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Parse
\end_layout

\end_inset

:
\end_layout

\begin_layout LyX-Code
data Parse = Parse Definition ParseTree AnswerLength
\end_layout

\begin_layout Standard
where 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
ParseTree
\end_layout

\end_inset

 will be an Abstract Syntax Tree based on the structure of our clue.
 So we can now define:
\end_layout

\begin_layout LyX-Code
parse :: [Split] → [Parse]
\end_layout

\begin_layout LyX-Code
parse = concatMap parse'
\end_layout

\begin_layout Standard
where
\end_layout

\begin_layout LyX-Code
parse' :: Split → [Parse]
\end_layout

\begin_layout Standard
In our example, we would require 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
parse'
\end_layout

\end_inset

 to consume the string 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Ship carrying right flag 
\end_layout

\end_inset

 to generate the parse trees – including the correct one:
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.INSERTION
\backslash
 ("carrying") [.SYNONYM "ship" ] [.ABBREVIATION "right" ]]
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
as well as many others:
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.CONCATENATION [.SYNONYM "ship" ][.LAST
\backslash
 LETTER
\backslash
 ("right") [.SYNONYM "carrying" ]]]
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.CONCATENATION [.SYNONYM "ship" ][.CONCATENATION [.SYNONYM "carrying" ][.SYNONYM
 "flag" ]]]
\end_layout

\end_inset

 
\begin_inset VSpace defskip
\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
and so on.
\end_layout

\begin_layout Subsubsection
Traditional Scanner-Based Parsing
\end_layout

\begin_layout Standard
The first step in the lexical analysis phase of a parse usually consists
 of tokenisation.
 This is the process of grouping characters together into functional groups
 called 
\noun on
tokens
\noun default
, to later pass to the parser to peform the semantic analysis on.
 Tokens consist of a 
\noun on
lexeme
\noun default
 the string of characters known to be of a certain type, and the value they
 represent (for example 
\noun on
integer 3
\noun default
 or 
\noun on
variable name 
\noun default
available_credit).
 The process is often split into two stages.
 
\end_layout

\begin_layout Paragraph
The Scanner
\end_layout

\begin_layout Standard
The first is the 
\noun on
scanner: 
\noun default
this is often a finite state machine, which will consumer characters based
 on rules to produce potential lexemes.
 Some more simple scanners can operate under greedy assumptions (called
 the Maximal Munch principle by R.G.G.
 Cattel), and some require backtracking (for example, the language 
\noun on
C
\noun default
).
 Due to the complexity and ambiguity of the language of cryptic crossword
 clues, it is not possible to produce an accurate scanner that produces
 anything other than a trivial tagging of lexical elements
\begin_inset Foot
status open

\begin_layout Plain Layout
It would, of course, be possible to produce a trivial parser for most languages,
 in which we lex every character or group of letters to a function with
 the value of itself, so instead of the desired 
\noun on
variable 
\noun default
x 
\noun on
equals integer 3 
\noun default
we could instead simply parse to 
\noun on
function 
\noun default
x 
\noun on
function 
\noun default
= 
\noun on
function 3
\noun default
, and leave it to the rest of the pipeline to determine that 
\noun on
function 3
\noun default
 is a constant function which always yields the integer literal 3, but this
 misses the point of having a scanner separately.
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
The Evaluator
\end_layout

\begin_layout Standard
This stage of the tokeniser...
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Yeha, finish this.
 This point is probably less interesting Maybe the above sections should
 be merged together?
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Scannerless Parsing
\end_layout

\begin_layout Standard
Some parsers, traditionally often ones for simple languages such as...
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
Todo: need to finish off this section and explain why my parser is more
 like a scannerless parser.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Parsing different clue types
\end_layout

\begin_layout Standard
So we need to define a function 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
parseClue
\end_layout

\end_inset

 which will produce a parse tree from an unconsumed string.
 So we have
\end_layout

\begin_layout LyX-Code
parseClue :: String → ParseTree
\end_layout

\begin_layout Standard
We will define parseString in terms of its parsing of various clue types,
 starting with one of the more simple unary ones:
\end_layout

\begin_layout LyX-Code
parseAnagram :: String → [ParseTree]
\end_layout

\begin_layout LyX-Code
parseAnagram xs = 
\end_layout

\begin_layout LyX-Code
 [AnagramNode (AIndicator x) y |
\end_layout

\begin_layout LyX-Code
              (x,y) <- includeReversals .
 twoPartitions $ xs
\end_layout

\begin_layout LyX-Code
                                     , isAnagramIndicator(x)]
\end_layout

\begin_layout Standard
where
\end_layout

\begin_layout LyX-Code
twoPartitions xs = [(x,y) | [x,y] <- partitions xs]
\end_layout

\begin_layout LyX-Code
includeReversals xs = xs ++ [(snd(x),fst(x)) | x <- xs]  
\end_layout

\begin_layout Standard
We allow both (x, y) and (y, x) through 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
includeReversals
\end_layout

\end_inset

 in order to allow 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
muddled word
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
word muddled
\end_layout

\end_inset

 both to indicate anagrams of 
\begin_inset Quotes eld
\end_inset

word
\begin_inset Quotes erd
\end_inset

.
 This means a that in example [B] we parse both 
\end_layout

\begin_layout Standard
.
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.DEFINITION
\backslash
 "companion" [.ANAGRAM
\backslash
 ("shredded") "corset" ]]
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "5col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Plain Layout
and
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.DEFINITION
\backslash
 "corset" [.ANAGRAM
\backslash
 ("shredded") "companion" ]]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
.
\end_layout

\begin_layout Standard
Anagram clues, along with Hidden Word clues only require a definition and
 a string, so their operands don't require any further parsing.
 Other clues, though, may require the operands to be parsed bef.
 For example, the parsing of the clue 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
SWEETHEART NEARLY FINISHED (5)
\end_layout

\end_inset

 as 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
(L)OVER
\end_layout

\end_inset

 requires 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
SWEETHEART
\end_layout

\end_inset

 to be parsed into a synonym node after we consumer nearly to be an indicator
 for a partial word node.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.DEFINITION
\backslash
 "finished" [.PARTIAL
\backslash
 ("nearly") [.
\backslash
emph{
\backslash
{unparsed: "sweetheart"
\backslash
}} ] ] ]
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "5col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

 ⇒ 
\end_layout

\begin_layout Plain Layout
parse
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.DEFINITION
\backslash
 "finished" [.PARTIAL
\backslash
 ("nearly") [.SYNONYM "sweetheart" ] ] ]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset

we therefore parse recursively, letting Haskell's list comprehension take
 care of matching the correct partition to the correct parse.
\end_layout

\begin_layout LyX-Code
parsePartialNode :: String → [ParseTree]
\end_layout

\begin_layout LyX-Code
parsePartialNode xs = [PartialNode (LLIndicator x) y' 
\end_layout

\begin_layout LyX-Code
         |(x,y) <- includeReversals .
 twoPartitions $ xs
\end_layout

\begin_layout LyX-Code
          , isPartialIndicator(x)
\end_layout

\begin_layout LyX-Code
          , y' <- parseClue y]
\end_layout

\begin_layout Standard
Still more complex clue types require splitting into three parts – two branches
 and an indicator – and often both of these branches require further parsing.
 For example, in the case of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
SHIP CARRYING RIGHT FLAG
\end_layout

\end_inset

, choosing 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
FLAG
\end_layout

\end_inset

 as the definition, we can generate
\end_layout

\begin_layout Verse
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.INSERTION
\backslash
 ("carrying") [.
\backslash
emph{
\backslash
{unparsed string:
\backslash
 "ship"
\backslash
}} ] [.
\backslash
emph{
\backslash
{unparsed string:
\backslash
 "right"
\backslash
}} ]]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and then consume each of the unparsed strings in turn to produce
\end_layout

\begin_layout Verse
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.INSERTION
\backslash
 ("carrying") [.SYNONYM "ship" ] [.ABBREVIATION "right" ]]
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
It is worth noting here that as well as the top-level parse generating multiple
 different options, each of these sub-parses may also generate several different
 parses, and these themselves may be complex with multiple sub-parses.
 In the clue 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
WORK HARD IN ATTEMPT TO GET CUP
\end_layout

\end_inset

, with definition (=
\begin_inset Flex Code
status open

\begin_layout Plain Layout
\begin_inset Quotes erd
\end_inset

to get
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

) of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
CUP
\end_layout

\end_inset

, we can parse the wordplay as
\end_layout

\begin_layout Verse
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.INSERTION
\backslash
 ("in") [.
\backslash
emph{
\backslash
{unparsed string:
\backslash
 "work hard"}
\backslash
} ] [.SYNONYM "attempt" ]]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
which may subsequently evaluate to the (correct, in this case) parse:
\end_layout

\begin_layout Verse
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.INSERTION
\backslash
 ("in") [.CONCATENATION [.SYNONYM "work" ]  [.ABBREVIATION "hard" ] ] [.SYNONYM
 "attempt" ]]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
as well as others, such as: 
\end_layout

\begin_layout Verse
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.INSERTION
\backslash
 ("in") [.ANAGRAM
\backslash
 ("work") "hard" ] [.SYNONYM "attempt" ]]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here, again, we allow Haskell's list comprehension take care of constructing
 the sub- parse-trees from our recursive calls and constructing them into
 our final list of trees.
\end_layout

\begin_layout LyX-Code
 parseInsertionNodes :: [String] -> Int -> [ClueTree] 
\end_layout

\begin_layout LyX-Code
 parseInsertionNodes xs n = let parts = threeParts xs                  
 
\end_layout

\begin_layout LyX-Code
       in [InsertionNode (IIndicator y) x' z' 
\end_layout

\begin_layout LyX-Code
           | (x,y,z) <- parts, isInsertionWord(y)
\end_layout

\begin_layout LyX-Code
             , x' <- (parseClue x n)
\end_layout

\begin_layout LyX-Code
             , z' <- (parseClue z n)] 
\end_layout

\begin_layout Subsubsection
Parse Multitudes 
\begin_inset Note Note
status open

\begin_layout Plain Layout
ok, call it something different
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These nested parses can cause the number of produced parses to grow exponentiall
y as the depth of the nesting increases.
 Longer strings with more indicators – especially indicators for binary
 expressions such as insertion indicators and subtraction indicators – are
 more likely to produce deeply nested parses, and therefore return a large
 number of parse trees.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Either give some numbers here, talk about the numbers from later on, or
 just push this whole thing later altogether
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Evaluation
\end_layout

\begin_layout Standard
In the evaluation stage we look to define a function 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
evaluate
\end_layout

\end_inset

with the type signature: 
\end_layout

\begin_layout LyX-Code
evaluate :: [Parse] → [Answer]
\end_layout

\begin_layout Standard
As the evaluation of each 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Parse
\end_layout

\end_inset

 will yield a list of multiple 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Answer
\end_layout

\end_inset

 (e.g.
 an anagram node of a five-letter word will evaluate to 120 different answers,
 although very few of them will be valid words), we can define 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
evaluate
\end_layout

\end_inset

as 
\end_layout

\begin_layout LyX-Code
evaluate = concatMap eval
\end_layout

\begin_layout Standard
where 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
evaluate
\end_layout

\end_inset

 will consume 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Parse
\end_layout

\end_inset

 data in the form 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Def Definition ParseTree AnswerLength
\end_layout

\end_inset

and produce 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
[Answer]
\end_layout

\end_inset

, where:
\end_layout

\begin_layout LyX-Code
data Answer = Answer String Parse
\end_layout

\begin_layout Standard
The parse is included along with the answer, as it contains the definition
 for that parse, which will later allow us to check that our generated answer
 has some relation to what we thought we were looking for in that parse,
 and also allows us to reconstruct the reasoning behind the clue by inspecing
 the parse tree.
\end_layout

\begin_layout Standard
We then define 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
eval
\end_layout

\end_inset

 as:
\end_layout

\begin_layout LyX-Code
eval (Def d pt l) = [Answer x (Def d pt l) |
\end_layout

\begin_layout LyX-Code
                                        x <- evalTree pt]
\end_layout

\begin_layout Standard
We can then define 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
evalTree
\end_layout

\end_inset

 in terms of the different types of node in our 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
ParseTree
\end_layout

\end_inset

 type.
 Those without subtrees will be defined simply with reference to a haskell
 function that performs their action:
\end_layout

\begin_layout LyX-Code
eval_tree (AnagramNode ind xs) c = anagrams xs
\end_layout

\begin_layout LyX-Code
eval_tree (SynonymNode xs) = synonyms xs
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code
anagrams :: String -> [String] 
\end_layout

\begin_layout LyX-Code
anagrams [] = [[]] 
\end_layout

\begin_layout LyX-Code
anagrams xs = [x:ys | x<- nub xs, ys <- anagrams $ delete x xs]
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code
synonyms :: String -> [String] 
\end_layout

\begin_layout LyX-Code
synonyms xs = Map.lookup xs thesaurus
\end_layout

\begin_layout Standard
and so on.
 Clues with sub-trees are treated with a similar recursive call, with either
 a map, or a list comprehension applying the expressions function to each
 generated sub-answer
\end_layout

\begin_layout LyX-Code
eval_tree (ReversalNode ind ys) = map reverse (eval_tree ys)
\end_layout

\begin_layout LyX-Code
eval_tree (ConcatNode ind xs ys) = [x ++ y | x <- eval_tree xs
\end_layout

\begin_layout LyX-Code
                                           , y <- eval_tree ys]
\end_layout

\begin_layout Subsection
Selection
\end_layout

\begin_layout Standard
Finally, given that we've produced our list of answers, most of which will
 be meaningless combinations of jumbled letters and synonyms pressed together,
 we need to filter down to the answer containing a string which in some
 way meets the criteria set for us in the clue, that is 1.
 finding an answer that is a synonym of the part of the clue we chose as
 the definition 2.
 being the right number of letters.
\end_layout

\begin_layout Standard
So we can define 
\end_layout

\begin_layout LyX-Code
choose :: [Answer] → Answer
\end_layout

\begin_layout LyX-Code
choose = head .
 filter valid 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code
valid (Answer ans (Def def pt len)) = (length ans == len) 
\end_layout

\begin_layout LyX-Code
                                      && (is_synonym ans def)
\end_layout

\begin_layout Standard
Of course, we may not have generated a valid solution, so we can redefine
 to include this uncertainty:
\end_layout

\begin_layout LyX-Code
choose :: [Answer] → Maybe Answer
\end_layout

\begin_layout LyX-Code
choose = headM .
 filter valid 
\end_layout

\begin_layout LyX-Code
\begin_inset Note Note
status open

\begin_layout LyX-Code

\end_layout

\begin_layout Plain Layout
6.
 Discussion of different clue types 
\end_layout

\begin_layout Plain Layout
6.1 Any interesting ones of note 
\end_layout

\begin_layout Plain Layout
Is there anything here?
\end_layout

\end_inset


\end_layout

\begin_layout Section
State space and performance analysis
\end_layout

\begin_layout Subsection
Overview - does it work? 
\end_layout

\begin_layout Standard
This approach has the required structure to correctly parse and solve most
 cryptic crossword clues — with some caveats.
 
\end_layout

\begin_layout Standard
Firstly, although in most cases the correct parse was generated, often the
 number of other parses to be evaluated before reaching the correct one
 was so great that the computation would effectively not end.
 In this case, the heap size wasn't continually growing, as each evaluation
 branched and then diminished in turn, but the running time was sufficiently
 large (>48hrs) such that the computation would be useless in a practical
 situation.
 The data for this is considered in 
\series bold
6.2
\end_layout

\begin_layout Standard
In other cases the correct parse was created, however the semantic data
 wasn't available to evaluate the clue correctly.
 In other, very rare cases, there is a clue which does not fit the structure
 of the grammar defined in 
\series bold
Part I
\series default
.
 These do not generate the correct parse trees, and so are not soluable.
 These are discussed in 
\series bold
6.3
\series default
.
\end_layout

\begin_layout Subsection
Correctly parsed and evaluated clues
\end_layout

\begin_layout Standard
Most clues, if they yield any results at all, yield them within 30 seconds
 of being run.
 Many others yield them a very long time afterwards – multiple hours of
 runtime is required to reach them.
 Others seem to run indefinitely.
 
\end_layout

\begin_layout Standard
Of those that do not terminate within an acceptable timeframe, the generated
 parse trees can be inspected and it can be shown that the correct one has
 been generated, and that since no individual evaluation takes infinite
 time, and each evaluation uses a non-problematic amount of stack space
 (that is to say –
\begin_inset space ~
\end_inset

the stack does not increase with each subsequent evaluation), then we can
 say that the clue is solveable, even if not in a reasonable amount of time.
 
\end_layout

\begin_layout Standard
The clue 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
FRIEND FOUND IN OKLAHOMA TERMINAL (4)
\end_layout

\end_inset

yields the correct parse:
\end_layout

\begin_layout LyX-Code
Def "friend" (HiddenWordNode (HWIndicator ["found","in"]) 
\end_layout

\begin_layout LyX-Code
                                    ["oklahoma","terminal"])
\end_layout

\begin_layout Standard
however it also generates 59 others, including:
\end_layout

\begin_layout LyX-Code
Def "friend" (InsertionNode (IIndicator ["in"]) (Leaf "found") 
\end_layout

\begin_layout LyX-Code
               (ConsNode (Leaf "oklahoma") (Leaf "terminal")))
\end_layout

\begin_layout LyX-Code
Def "terminal" (InsertionNode (IIndicator ["in"]) 
\end_layout

\begin_layout LyX-Code
            (Leaf "friend found") (Leaf "oklahoma"))
\end_layout

\begin_layout LyX-Code
Def "oklahoma terminal" (ConsNode (Leaf "friend") 
\end_layout

\begin_layout LyX-Code
                                  (Leaf "found"))
\end_layout

\begin_layout LyX-Code
Def "terminal" (ConsNode (Leaf "friend") (ConsNode (Leaf "found") 
\end_layout

\begin_layout LyX-Code
               (ConsNode (Leaf "in") (Leaf "oklahoma")))) 
\end_layout

\begin_layout LyX-Code
Def "terminal" (ConsNode (ConsNode (Leaf "friend") 
\end_layout

\begin_layout LyX-Code
                         (Leaf "found")) (Leaf "in oklahoma"))
\end_layout

\begin_layout LyX-Code
Def "friend found" (Leaf "in oklahoma terminal") 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
Def "in oklahoma terminal" (ConsNode (Leaf "friend") 
\end_layout

\begin_layout LyX-Code
                                     (Leaf "found")) 
\end_layout

\begin_layout LyX-Code
Def "in oklahoma terminal" (Leaf "friend found") 
\end_layout

\begin_layout Standard
While evaluation of the correct parse takes 0.05 seconds, the evaluation
 of the first of the other examples takes over 10 seconds - it is the cumulative
 effect of the evaluation of the others, as well as the order in which they
 appear in the list which determines how long the total solving time takes.
 Some of these effects can been seen in 
\series bold
Figure 1.

\series default
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Leadup
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways true
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="6">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Clue
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Solution
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Clue Length
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
# Parses
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
# Evaluations
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Solve Time
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
COMPANION SHREDDED CORSET (6)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ESCORT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
148,500
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.2s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HOPE FOR HIGH PRAISE (6)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ASPIRE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
105,718,343
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.39s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MARIA NOT A FICKLE LOVER (9)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
INAMORATA
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
60
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
84,855,252
\begin_inset script superscript

\begin_layout Plain Layout
2
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

—
\begin_inset script superscript

\begin_layout Plain Layout
1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FRIEND FOUND IN OKLAHOMA TERMINAL (4)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MATE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
59
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
92,995,844
\begin_inset script superscript

\begin_layout Plain Layout
2
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

—
\begin_inset script superscript

\begin_layout Plain Layout
1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PAUSE AT THESE I FANCY (8)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HESITATE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
54
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5,358,615
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.59s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ANKLE WAS TWISTED IN BALLET (8)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SWAN LAKE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
84
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
203,991,525
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12.13s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
NOTICE SUPERVISOR IS GOING NUTS AT FIRST (4)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SIGN
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
853
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

—
\begin_inset script superscript

\begin_layout Plain Layout
3
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

—
\begin_inset script superscript

\begin_layout Plain Layout
1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ATTEMPT TO SECURE ONE POUND FOR A HAT (6)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TRILBY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2930
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

—
\begin_inset script superscript

\begin_layout Plain Layout
3
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

—
\begin_inset script superscript

\begin_layout Plain Layout
1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Solving statistics for selected clues on a 2014 MacBook Pro
\end_layout

\end_inset


\end_layout

\begin_layout Verse
\begin_inset VSpace bigskip
\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Verse
\begin_inset VSpace bigskip
\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset script superscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

 Although the correct parse was generated, and selective evaluation of that
 parse yieleded the correct results (i.e.
 a solution would be available eventually), the normal solving procedure
 did not compute the correct answer within 48hrs of running time
\end_layout

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset script superscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

 Due to Haskell's lazy evaluation, this can sometimes be calculated without
 actually computing the solution
\end_layout

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset script superscript

\begin_layout Plain Layout
3
\end_layout

\end_inset

 Could not yield answer within 48hrs 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsubsection
The effect of clue length on the number of parses
\end_layout

\begin_layout Standard
The length of the clue has an exponential effect on the number of parses
 produced.
 This is due partly to the increasing number of ways in which binary trees
 can be constructed from N elements, as in:
\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "25col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.
 [.
 A B ] [.
 C D ]]
\end_layout

\end_inset

 
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "25col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.
 [.A ] [.
 [ B C ] D ]]
\end_layout

\end_inset

 
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "25col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.
 [.
 A [.
 B C ]] [.D ]]
\end_layout

\end_inset

 
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "25col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.
 [.A ] [.
 B [.
 C D ] ]]
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Verse
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "25col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[.
 [.
 [.
 A B ] [.C ]] [.D ]]
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It also increases the availability for function words to interact with each
 other - when any A, B, C, or D in the examples above also have multiple
 parses, this is when we see the exponential growth seen in 
\series bold
Figure 2
\series default
.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename results/clue-length-to-parses.pdf
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Number of parses generated for varying clue lengths over 600 sample clues
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
The effect of clue length on the number of evaluations
\end_layout

\begin_layout Standard
We see a similar but even greater effect on the number of evaluations, with
 the effect of the exponential growth per parse compounded by the fact that
 each parse can evaluate out to to thousands of options.
 This is due to two effects, Firstly, clues types like anagrams can have
 many thousand evaluations per parse (there are 120 anagrams of a 5-letter
 word, rising to 40,320 anagrams of an eight letter word).
 Secondly, compound clues like insertions, which can take the result of
 one wordplay and insert into the second, can magnify the effect of branching
 in its sub-clues.
 
\end_layout

\begin_layout Standard
There are 4 ways that a word 'A' can be inserted into a 5-letter word 'B'.
 There are 480 ways that it can be inserted into each of the 120 anagrams
 of word 'B', and if there are also 120 different anagrams of word 'A',
 then there are 57600 different evaluations for that parsed arrangement.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename results/clue-length-to-evaluations evaluations.pdf
	width 100col%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Number of evaluations generated for varying clue lengths over 75 sample
 clues
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The size of the thesaurus has a large impact on the number of evaluations
 produced, as all clue types (other than Anagram, Hidden Word and Initials,
 which use String) use Synonym as the lowest level node in their sub-trees.
\end_layout

\begin_layout Standard

\series bold
Figure 4
\series default
 shows how limiting the number of synonyms returned by the thesaurus affects
 the number of evaluations.
 The graph plateaus as the restriction exceeds the actual number of syonyms
 per entry for each word in the thesaurus.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename results/evals_vs_dictionary.pdf
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Number of evaluations generated by restricting the maximum thesaurus length
 for the clue 
\begin_inset Quotes eld
\end_inset

Good opportunity in school
\begin_inset Quotes erd
\end_inset

 (5)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Analysis of selected clues which are not correctly solved
\end_layout

\begin_layout Standard
It is difficult to perform a large-scale analysis of the numbers of clues
 for which the data does not exist, or where the correct parse is not generated,
 as often these will present themselves in the same way as the correct clues
 with too large a search space, that is by not terminating within an acceptable
 time.
 
\end_layout

\begin_layout Standard
These clues are therefore presented as an illustrative sample of the sorts
 of errors that prevent correct parse (
\series bold
6.3.4
\series default
) or correct evaluation (
\series bold
6.3.1 –
\begin_inset space ~
\end_inset

6.3.3) 
\series default
being generated.
\end_layout

\begin_layout Subsubsection
SHINY SILVER PAPER IN THE STREET (8)  (= 
\begin_inset Quotes eld
\end_inset

AGLITTER
\begin_inset Quotes erd
\end_inset

) [Guardian]
\end_layout

\begin_layout Standard
Although the correct parse is generated ([SILVER] + [PAPER IN THE STREET]),
 some natural language analysis would be required to derive the fact that
 
\begin_inset Quotes eld
\end_inset

PAPER IN THE STREET
\begin_inset Quotes erd
\end_inset

 = 
\begin_inset Quotes eld
\end_inset

litter
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
PLAYWRIGHT AT HOME HAVING CAUGHT DISEASE (5) (="IBSEN
\begin_inset Quotes erd
\end_inset

) [Everyman]
\end_layout

\begin_layout Standard
This clue requires two pieces of category knowledge, firstly that Ibsen
 is a member of the set of playwrights (and not a synonym for playwright),
 and that BSE is a member of the set of diseases 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
HE SCORED HARLEM WINDS (6)   (= 
\begin_inset Quotes eld
\end_inset

MAHLER
\begin_inset Quotes erd
\end_inset

) [Guardian]
\end_layout

\begin_layout Standard
Not only is knowledge of composer Gustav Mahler required, but also a cryptic
 understanding that 'HE SCORED' can refer to a member of the set of male
 composers.
 Note that this is structurally different from the examples above: while
 (1) was a more oblique version of a synonym (litter 
\series bold
is
\series default
 paper on the street), and (2) is membership of the set of of playwrights,
 we must now consider the set of people who fit the description 
\begin_inset Quotes eld
\end_inset

he scored
\begin_inset Quotes erd
\end_inset

, which may include composers, sportsmen, and maybe even engravers.
 
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
WHERE AND HOW A SUPERHERO MIGHT LABEL HIS FAUCET (4) (= 
\begin_inset Quotes eld
\end_inset

BATH
\begin_inset Quotes erd
\end_inset

) [Guardian]
\end_layout

\begin_layout Standard
This clue requires not just specialist knowledge, but also natural language
 parsing of the sentence of a whole.
 The answer can be derived from the concept that the superhero Batman would
 append bat- onto the names of objects (batmobile, etc.), and that a hot
 tap (or faucet) might be labeled H, so his faucet might be labelled BAT-H.
 
\end_layout

\begin_layout Standard
Along with that, the definition bears reference to the clue as a whole,
 and may be properly expanded as: 
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout --Separator--
\begin_inset Flex Code
status open

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

definition
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

wordplay
\end_layout

\end_inset


\end_layout

\begin_layout Address
\begin_inset Formula $\noindent\mathtt{\overbrace{where\, a\, superhero\, might\, label\, his\, faucet}\:\mathit{and}\,\overbrace{how\, a\, superhero\, might\, label\, his\, faucet}}$
\end_inset

   
\end_layout

\begin_layout Address
This clue represents the upper level of challenge for a computer based solver,
 being unique structure, self referential, using very specialist knowledge
 and oblique humour.
 
\end_layout

\begin_layout Part
Optimisations
\end_layout

\begin_layout Section
Algebraic + computational simplifications 
\end_layout

\begin_layout Subsection
Pruning out equivalent trees (Canonicalization) 
\end_layout

\begin_layout Subsection
Discussion of lazy evaluation 
\end_layout

\begin_layout Subsubsection
e.g.
 Anagram Nodes - should we pre-compute and thread through the program?
\end_layout

\begin_layout Subsection
Analysis of improved solution with respect to state space etc.
\end_layout

\begin_layout Section
Further heuristic simplification - 
\end_layout

\begin_layout Subsection
matching the Human Solver's thought process 
\end_layout

\begin_layout Subsection
Constrain length while parsing maximum and minimum 
\end_layout

\begin_layout Subsection
Constrain length while solving 
\end_layout

\begin_layout Subsection
Constain against known letters 
\end_layout

\begin_layout Subsection
Constrain against known wordlist 
\end_layout

\begin_layout Subsection
Constrain against synonyms 
\end_layout

\begin_layout Subsection
Analysis of improved solution with respect to state space etc.
\end_layout

\begin_layout Section
Solving based on most probable parse trees 
\end_layout

\begin_layout Subsection
Evaluation functions 
\end_layout

\begin_layout Subsubsection
Current weighting just ‘works’ 
\end_layout

\begin_layout Subsubsection
Could generate weighting based on ML + cost minimization 
\end_layout

\begin_layout Subsubsection
Providing a weighted list of possible answers
\end_layout

\begin_layout Section
Analysis of Single clue solving against benchmarks 
\end_layout

\begin_layout Subsection
Accuracy given data Accuracy 
\end_layout

\begin_layout Subsection
assuming reasonable data could be acquired 
\end_layout

\begin_layout Subsection
Computation required and feasibility in the real world 
\end_layout

\begin_layout Subsection
Discussion of parallelization 
\end_layout

\begin_layout Part
Future Work
\end_layout

\begin_layout Section
Whole Grid Solving
\end_layout

\begin_layout Subsection
By permutations of all possible parses (dull but effective?) 
\end_layout

\begin_layout Subsection
Lazy evaluation (massive branching issues?) 
\end_layout

\begin_layout Subsection
Repeated function application (probabilistic convergence) probabilistically
 constrain against likely evidence from other clue
\end_layout

\begin_layout Subsubsection
Convergence not guaranteed!
\end_layout

\begin_layout Section
Solving with missing information 
\end_layout

\begin_layout Subsection
Human as an oracle 
\end_layout

\begin_layout Subsection
Generating probable solutions with missing data 
\end_layout

\begin_layout Subsubsection
“if Lear means/is a King...” 
\end_layout

\begin_layout Section
Deployment as a web app
\end_layout

\begin_layout Section
Tweaking the values on the weighting function
\end_layout

\begin_layout Part
Appendix 
\end_layout

\begin_layout Section
Data considerations 
\end_layout

\begin_layout Subsection
Corpus / wordlist 
\end_layout

\begin_layout Subsubsection
Loading in an unsafe IO manner can 
\end_layout

\begin_layout Subsubsection
Conjugated forms -> we should match tense, plurality etc.
 Expanding out keywords (e.g.
 Anagram indicators) 
\end_layout

\begin_layout Subsection
Knowledge -> capital of Paris 
\end_layout

\begin_layout Subsection
Derived knowledge -> Qulog to create knowlegebase?
\end_layout

\begin_layout Subsection
Unsupervised learned?
\end_layout

\begin_layout Section
A benchmarking suite to check performance + accuracy
\end_layout

\begin_layout Subsection
Clues from real newspapers 
\end_layout

\begin_layout Subsection
A solution markup and automated verification => is answer enough or do we
 just want to provide a method 
\end_layout

\begin_layout Subsection
Rating clues on a scale / on multiple scales 
\end_layout

\begin_layout Part
References
\end_layout

\begin_layout Paragraph
Cryptic crossword clues: generating text with a hidden meaning
\end_layout

\begin_layout Standard
David Hardcastle - 2007 
\end_layout

\begin_layout Paragraph
The Generation of Cryptic Crossword Clues
\end_layout

\begin_layout Standard
G.
 W.
 Smith, and J.
 B.
 H.
 du Boulay - 1986 
\end_layout

\begin_layout Paragraph
Crossword Compiler-Compilation 
\end_layout

\begin_layout Standard
H.
 Berghel and C.
 Yi.
 - 1989 
\end_layout

\begin_layout Paragraph
PROVERB: The Probabilistic Cruciverbalist 
\end_layout

\begin_layout Standard
Greg A.
 Keim, Noam M.
 Shazeer, Michael L.
 Littman - 1999 
\end_layout

\begin_layout Paragraph
Computer Assisted Analysis of Cryptic Crosswords 
\end_layout

\begin_layout Standard
P.W.Williams and D.
 Woodhead - 1977 
\end_layout

\begin_layout Paragraph
LACROSS language, formal definitions - good building material
\end_layout

\begin_layout Standard
Cryptic crossword clue interpreter M Hart, RH Davis - 1992
\end_layout

\begin_layout Paragraph
Microcomputer compilation and solution of crosswords 
\end_layout

\begin_layout Standard
RH Davis and E J Juvshol - 1985 
\end_layout

\begin_layout Paragraph
Give Us A Clue
\end_layout

\begin_layout Standard
Jon G.
 Hall and Lucia Rapanotti - 2010 
\end_layout

\begin_layout Paragraph
A Statistical Study of Failures In Solving Crossword Puzzles
\end_layout

\begin_layout Standard
Naranana, 2010 
\end_layout

\begin_layout Paragraph
Expertise in cryptic crossword performance
\end_layout

\begin_layout Standard
Kathryn Friedlander, Philip Fine, 2009 
\end_layout

\begin_layout Standard
Cattell, R.
 G.
 G.
 “Formalization and Automatic Derivation of Code Generators”.
 PhD thesis, 1978.
 Carnegie Mellon University, Pittsburgh, Pennsylvania, USA 
\end_layout

\end_body
\end_document
